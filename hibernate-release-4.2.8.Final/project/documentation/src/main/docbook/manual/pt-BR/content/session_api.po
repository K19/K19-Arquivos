# translation of session_api.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# Michael H. Smith <mhideo@redhat.com>, 2007.
# Glaucia Cintra <gcintra@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: session_api\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-21 05:43+0000\n"
"PO-Revision-Date: 2010-03-19 10:25+1000\n"
"Last-Translator: \n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: session_api.xml:31
#, no-c-format
msgid "Working with objects"
msgstr "Trabalhando com objetos"

#. Tag: para
#: session_api.xml:33
#, no-c-format
msgid ""
"Hibernate is a full object/relational mapping solution that not only shields "
"the developer from the details of the underlying database management system, "
"but also offers <emphasis>state management</emphasis> of objects. This is, "
"contrary to the management of SQL <literal>statements</literal> in common "
"JDBC/SQL persistence layers, a natural object-oriented view of persistence "
"in Java applications."
msgstr ""
"O Hibernate é uma solução completa de mapeamento objeto/relacional que não "
"apenas poupa o desenvolvedor dos detalhes de baixo nível do sistema de "
"gerenciamento do banco de dados, como também oferece um "
"<emphasis>gerenciamento de estado</emphasis> para objetos. Isto é, ao "
"contrário do gerenciamento de <literal>instruções</literal> SQL em camadas "
"de persistência JDBC/SQL comuns, uma visão natural da persistência orientada "
"a objetos em aplicações Java. "

#. Tag: para
#: session_api.xml:40
#, no-c-format
msgid ""
"In other words, Hibernate application developers should always think about "
"the <emphasis>state</emphasis> of their objects, and not necessarily about "
"the execution of SQL statements. This part is taken care of by Hibernate and "
"is only relevant for the application developer when tuning the performance "
"of the system."
msgstr ""
"Em outras palavras, desenvolvedores de aplicações Hibernate podem sempre "
"considerar o <emphasis>estado</emphasis> de seus objetos, e não "
"necessariamente a execução de instruções SQL. O Hibernate é responsável por "
"esta parte e é relevante aos desenvolvedores de aplicações apenas quando "
"estão ajustando o desempenho do sistema."

#. Tag: title
#: session_api.xml:47
#, no-c-format
msgid "Hibernate object states"
msgstr "Estado dos objetos no Hibernate"

#. Tag: para
#: session_api.xml:49
#, no-c-format
msgid "Hibernate defines and supports the following object states:"
msgstr "O Hibernate define e suporta os seguintes estados de objetos:"

#. Tag: para
#: session_api.xml:53
#, no-c-format
msgid ""
"<emphasis>Transient</emphasis> - an object is transient if it has just been "
"instantiated using the <literal>new</literal> operator, and it is not "
"associated with a Hibernate <literal>Session</literal>. It has no persistent "
"representation in the database and no identifier value has been assigned. "
"Transient instances will be destroyed by the garbage collector if the "
"application does not hold a reference anymore. Use the Hibernate "
"<literal>Session</literal> to make an object persistent (and let Hibernate "
"take care of the SQL statements that need to be executed for this "
"transition)."
msgstr ""
"<emphasis>Transient</emphasis> - um objeto é transiente se ele foi "
"instanciando usando apenas o operador <literal>new</literal> e não foi "
"associado a uma <literal>Session</literal> do Hibernate. Ele não possui uma "
"representação persistente no banco de dados e não lhe foi atribuído nenhum "
"identificador. Instâncias transientes serão destruídas pelo coletor de lixo "
"se a aplicação não mantiver sua referência. Use uma <literal>Session</"
"literal> do Hibernate para tornar o objeto persistente (e deixe o Hibernate "
"gerenciar as instruções SQL que serão necessárias para executar esta "
"transição)."

#. Tag: para
#: session_api.xml:65
#, no-c-format
msgid ""
"<emphasis>Persistent</emphasis> - a persistent instance has a representation "
"in the database and an identifier value. It might just have been saved or "
"loaded, however, it is by definition in the scope of a <literal>Session</"
"literal>. Hibernate will detect any changes made to an object in persistent "
"state and synchronize the state with the database when the unit of work "
"completes. Developers do not execute manual <literal>UPDATE</literal> "
"statements, or <literal>DELETE</literal> statements when an object should be "
"made transient."
msgstr ""
"<emphasis>Persistent</emphasis> - uma instância persistente possui uma "
"representação no banco de dados e um identificador. Ela pode ter sido salva "
"ou carregada, portanto ela se encontra no escopo de uma <literal>Session</"
"literal>. O Hibernate irá detectar qualquer mudança feita a um objeto "
"persistente e sincronizar o seu estado com o banco de dados quando completar "
"a unidade de trabalho. Desenvolvedores não executam instruções manuais de "
"<literal>UPDATE</literal>, ou instruções de <literal>DELETE</literal> quando "
"o objeto se tornar transiente. "

#. Tag: para
#: session_api.xml:77
#, no-c-format
msgid ""
"<emphasis>Detached</emphasis> - a detached instance is an object that has "
"been persistent, but its <literal>Session</literal> has been closed. The "
"reference to the object is still valid, of course, and the detached instance "
"might even be modified in this state. A detached instance can be reattached "
"to a new <literal>Session</literal> at a later point in time, making it (and "
"all the modifications) persistent again. This feature enables a programming "
"model for long running units of work that require user think-time. We call "
"them <emphasis>application transactions</emphasis>, i.e., a unit of work "
"from the point of view of the user."
msgstr ""
"<emphasis>Detached</emphasis> – uma instância desanexada é um objeto que foi "
"persistido, mas sua <literal>Session</literal> foi fechada. A referência ao "
"objeto continua válida, é claro, e a instância desanexada pode ser acoplada "
"a uma nova <literal>Session</literal> no futuro, tornando-o novamente "
"persistente (e todas as modificações sofridas). Essa característica habilita "
"um modelo de programação para unidades de trabalho de longa execução, que "
"requeira um tempo de espera do usuário. Podemos chamá-las de "
"<emphasis>transações da aplicação</emphasis>, ou seja, uma unidade de "
"trabalho do ponto de vista do usuário."

#. Tag: para
#: session_api.xml:90
#, no-c-format
msgid ""
"We will now discuss the states and state transitions (and the Hibernate "
"methods that trigger a transition) in more detail."
msgstr ""
"Agora iremos discutir os estados e suas transições (e os métodos do "
"Hibernate que disparam uma transição) em mais detalhes."

#. Tag: title
#: session_api.xml:95
#, no-c-format
msgid "Making objects persistent"
msgstr "Tornando os objetos persistentes"

#. Tag: para
#: session_api.xml:97
#, no-c-format
msgid ""
"Newly instantiated instances of a persistent class are considered "
"<emphasis>transient</emphasis> by Hibernate. We can make a transient "
"instance <emphasis>persistent</emphasis> by associating it with a session:"
msgstr ""
"As instâncias recentemente instanciadas de uma classe persistente são "
"consideradas <emphasis>transientes </emphasis> pelo Hibernate. Podemos "
"transformar uma instância transiente em <emphasis>persistente</emphasis> "
"associando-a a uma sessão: "

#. Tag: programlisting
#: session_api.xml:102
#, no-c-format
msgid ""
"DomesticCat fritz = new DomesticCat();\n"
"fritz.setColor(Color.GINGER);\n"
"fritz.setSex('M');\n"
"fritz.setName(\"Fritz\");\n"
"Long generatedId = (Long) sess.save(fritz);"
msgstr ""

#. Tag: para
#: session_api.xml:104
#, no-c-format
msgid ""
"If <literal>Cat</literal> has a generated identifier, the identifier is "
"generated and assigned to the <literal>cat</literal> when <literal>save()</"
"literal> is called. If <literal>Cat</literal> has an <literal>assigned</"
"literal> identifier, or a composite key, the identifier should be assigned "
"to the <literal>cat</literal> instance before calling <literal>save()</"
"literal>. You can also use <literal>persist()</literal> instead of "
"<literal>save()</literal>, with the semantics defined in the EJB3 early "
"draft."
msgstr ""
"Se <literal>Cat</literal> possui um identificador gerado, o identificador é "
"gerado e atribuído à <literal>cat</literal> quando <literal>save()</literal> "
"for chamado. Se <literal>Cat</literal> possuir um identificador "
"<literal>Associado</literal>, ou uma chave composta, o identificador deverá "
"ser atribuído à instância de <literal>cat</literal> antes que <literal>save()"
"</literal> seja chamado. Pode-se usar também <literal>persist()</literal> ao "
"invés de <literal>save()</literal>, com a semântica definida no novo esboço "
"do EJB3. "

#. Tag: para
#: session_api.xml:115
#, no-c-format
msgid ""
"<literal>persist()</literal> makes a transient instance persistent. However, "
"it does not guarantee that the identifier value will be assigned to the "
"persistent instance immediately, the assignment might happen at flush time. "
"<literal>persist()</literal> also guarantees that it will not execute an "
"<literal>INSERT</literal> statement if it is called outside of transaction "
"boundaries. This is useful in long-running conversations with an extended "
"Session/persistence context."
msgstr ""
"<literal>persist()</literal> faz uma instância transciente persistente. No "
"entanto, isto não garante que o valor do identificador será determinado à "
"instância persistente imediatamente, pois a determinação pode acontecer no "
"período de limpeza. O <literal>persist()</literal> também garante que isto "
"não executará uma declaração <literal>INSERT</literal> caso esta seja "
"chamada fora dos limites da transação. Isto é útil em transações de longa-"
"execução com um contexto de Sessão/persistência estendido."

#. Tag: para
#: session_api.xml:126
#, no-c-format
msgid ""
"<literal>save()</literal> does guarantee to return an identifier. If an "
"INSERT has to be executed to get the identifier ( e.g. \"identity\" "
"generator, not \"sequence\"), this INSERT happens immediately, no matter if "
"you are inside or outside of a transaction. This is problematic in a long-"
"running conversation with an extended Session/persistence context."
msgstr ""
"<literal>save()</literal> garante retornar um identificador. Caso um INSERT "
"necessita ser executado para obter o identificador (ex.: gerador \"identidade"
"\" e não \"seqüência\"), este INSERT acontece imediatamente, independente de "
"você estar dentro ou fora da transação. Isto é problemático numa conversação "
"de longa execução com um contexto de Sessão/persistência estendido."

#. Tag: para
#: session_api.xml:135
#, no-c-format
msgid ""
"Alternatively, you can assign the identifier using an overloaded version of "
"<literal>save()</literal>."
msgstr ""
"Alternativamente, pode-se atribuir o identificador usando uma versão "
"sobrecarregada de <literal>save()</literal>. "

#. Tag: programlisting
#: session_api.xml:138
#, no-c-format
msgid ""
"DomesticCat pk = new DomesticCat();\n"
"pk.setColor(Color.TABBY);\n"
"pk.setSex('F');\n"
"pk.setName(\"PK\");\n"
"pk.setKittens( new HashSet() );\n"
"pk.addKitten(fritz);\n"
"sess.save( pk, new Long(1234) );"
msgstr ""

#. Tag: para
#: session_api.xml:140
#, no-c-format
msgid ""
"If the object you make persistent has associated objects (e.g. the "
"<literal>kittens</literal> collection in the previous example), these "
"objects can be made persistent in any order you like unless you have a "
"<literal>NOT NULL</literal> constraint upon a foreign key column. There is "
"never a risk of violating foreign key constraints. However, you might "
"violate a <literal>NOT NULL</literal> constraint if you <literal>save()</"
"literal> the objects in the wrong order."
msgstr ""
"Se o objeto persistido tiver associado objetos (ex.: a coleção "
"<literal>kittens</literal> no exemplo anterior), esses objetos podem se "
"tornar persistentes em qualquer ordem que se queira, a não ser que se tenha "
"uma restrição <literal>NOT NULL</literal> em uma coluna de chave "
"estrangeira. Nunca há risco de violação de restrições de chave estrangeira. "
"Assim, pode-se violar uma restrição <literal>NOT NULL</literal> se "
"<literal>save()</literal> for usado nos objetos em uma ordem errada. "

#. Tag: para
#: session_api.xml:148
#, no-c-format
msgid ""
"Usually you do not bother with this detail, as you will normally use "
"Hibernate's <emphasis>transitive persistence</emphasis> feature to save the "
"associated objects automatically. Then, even <literal>NOT NULL</literal> "
"constraint violations do not occur - Hibernate will take care of everything. "
"Transitive persistence is discussed later in this chapter."
msgstr ""
"Geralmente você não precisa se preocupar com esses detalhes, pois muito "
"provavelmente usará a característica de <emphasis>persistência transitiva </"
"emphasis> do Hibernate para salvar os objetos associados automaticamente. "
"Assim, enquanto uma restrição <literal>NOT NULL</literal> não ocorrer, o "
"Hibernate tomará conta de tudo. Persistência transitiva será discutida mais "
"adiante nesse mesmo capítulo. "

#. Tag: title
#: session_api.xml:157
#, no-c-format
msgid "Loading an object"
msgstr "Carregando o objeto"

#. Tag: para
#: session_api.xml:159
#, no-c-format
msgid ""
"The <literal>load()</literal> methods of <literal>Session</literal> provide "
"a way of retrieving a persistent instance if you know its identifier. "
"<literal>load()</literal> takes a class object and loads the state into a "
"newly instantiated instance of that class in a persistent state."
msgstr ""
"O método <literal>load()</literal> de uma <literal> Session</literal> "
"oferece uma maneira de recuperar uma instância persistente se o "
"identificador for conhecido. O <literal>load()</literal> escolhe uma classe "
"do objeto e carregará o estado em uma instância mais recente dessa classe, "
"em estado persistente."

#. Tag: programlisting
#: session_api.xml:165
#, no-c-format
msgid "Cat fritz = (Cat) sess.load(Cat.class, generatedId);"
msgstr ""

#. Tag: programlisting
#: session_api.xml:167
#, no-c-format
msgid ""
"// you need to wrap primitive identifiers\n"
"long id = 1234;\n"
"DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );"
msgstr ""

#. Tag: para
#: session_api.xml:169
#, no-c-format
msgid "Alternatively, you can load state into a given instance:"
msgstr "Alternativamente, pode-se carregar um estado em uma instância dada:"

#. Tag: programlisting
#: session_api.xml:171
#, no-c-format
msgid ""
"Cat cat = new DomesticCat();\n"
"// load pk's state into cat\n"
"sess.load( cat, new Long(pkId) );\n"
"Set kittens = cat.getKittens();"
msgstr ""

#. Tag: para
#: session_api.xml:173
#, no-c-format
msgid ""
"Be aware that <literal>load()</literal> will throw an unrecoverable "
"exception if there is no matching database row. If the class is mapped with "
"a proxy, <literal>load()</literal> just returns an uninitialized proxy and "
"does not actually hit the database until you invoke a method of the proxy. "
"This is useful if you wish to create an association to an object without "
"actually loading it from the database. It also allows multiple instances to "
"be loaded as a batch if <literal>batch-size</literal> is defined for the "
"class mapping."
msgstr ""
"Repare que <literal>load()</literal> irá lançar uma exceção irrecuperável se "
"não houver na tabela no banco de dados um registro que combine. Se a classe "
"for mapeada com um proxy, <literal>load()</literal> simplesmente retorna um "
"proxy não inicializado e realmente não chamará o banco de dados até que um "
"método do proxy seja invocado. Esse comportamento é muito útil para criar "
"uma associação com um objeto sem que realmente o carregue do bando de dados. "
"Isto também permite que sejam carregadas múltiplas instâncias como um grupo "
"se o <literal>batch-size</literal> estiver definido para o mapeamento da "
"classe. "

#. Tag: para
#: session_api.xml:182
#, no-c-format
msgid ""
"If you are not certain that a matching row exists, you should use the "
"<literal>get()</literal> method which hits the database immediately and "
"returns null if there is no matching row."
msgstr ""
"Se você não tiver certeza da existência do registro no banco, você deve usar "
"o método <literal>get()</literal>, que consulta o banco imediatamente e "
"retorna um null se não existir o registro. "

#. Tag: programlisting
#: session_api.xml:186
#, no-c-format
msgid ""
"Cat cat = (Cat) sess.get(Cat.class, id);\n"
"if (cat==null) {\n"
"    cat = new Cat();\n"
"    sess.save(cat, id);\n"
"}\n"
"return cat;"
msgstr ""

#. Tag: para
#: session_api.xml:188
#, no-c-format
msgid ""
"You can even load an object using an SQL <literal>SELECT ... FOR UPDATE</"
"literal>, using a <literal>LockMode</literal>. See the API documentation for "
"more information."
msgstr ""
"Também pode-se carregar um objeto usando <literal>SELECT ... FOR UPDATE</"
"literal>, usando um <literal>LockMode</literal>. Veja a documentação da API "
"para maiores informações. "

#. Tag: programlisting
#: session_api.xml:192
#, no-c-format
msgid "Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);"
msgstr ""

#. Tag: para
#: session_api.xml:194
#, no-c-format
msgid ""
"Any associated instances or contained collections will <emphasis>not</"
"emphasis> be selected <literal>FOR UPDATE</literal>, unless you decide to "
"specify <literal>lock</literal> or <literal>all</literal> as a cascade style "
"for the association."
msgstr ""
"Note que quaisquer instâncias associadas ou que contenham coleções, "
"<emphasis>não</emphasis> são selecionados <literal>FOR UPDATE</literal>, a "
"não ser que você decida especificar um <literal>lock</literal> ou "
"<literal>all</literal> como um estilo cascata para a associação. "

#. Tag: para
#: session_api.xml:199
#, no-c-format
msgid ""
"It is possible to re-load an object and all its collections at any time, "
"using the <literal>refresh()</literal> method. This is useful when database "
"triggers are used to initialize some of the properties of the object."
msgstr ""
"É possível realizar o recarregamento de um objeto e todas as suas coleções a "
"qualquer momento, usando o método <literal>refresh()</literal>.É útil quando "
"os disparos do banco de dados são usados para inicializar algumas "
"propriedades do objeto."

#. Tag: programlisting
#: session_api.xml:204
#, no-c-format
msgid ""
"sess.save(cat);\n"
"sess.flush(); //force the SQL INSERT\n"
"sess.refresh(cat); //re-read the state (after the trigger executes)"
msgstr ""

#. Tag: para
#: session_api.xml:206
#, fuzzy, no-c-format
msgid ""
"How much does Hibernate load from the database and how many SQL "
"<literal>SELECT</literal>s will it use? This depends on the "
"<emphasis>fetching strategy</emphasis>. This is explained in <xref linkend="
"\"performance-fetching\"/>."
msgstr ""
"O quanto Hibernate carrega do banco de dados e quantos SQL <literal>SELECT</"
"literal> ele irá usar? Isto depende da <emphasis>estratégia de busca</"
"emphasis> usada e explicada na <xref linkend=\"performance-fetching\" />."

#. Tag: title
#: session_api.xml:213
#, no-c-format
msgid "Querying"
msgstr "Consultando"

#. Tag: para
#: session_api.xml:215
#, no-c-format
msgid ""
"If you do not know the identifiers of the objects you are looking for, you "
"need a query. Hibernate supports an easy-to-use but powerful object oriented "
"query language (HQL). For programmatic query creation, Hibernate supports a "
"sophisticated Criteria and Example query feature (QBC and QBE). You can also "
"express your query in the native SQL of your database, with optional support "
"from Hibernate for result set conversion into objects."
msgstr ""
"Se o identificador do objeto que se está buscando não for conhecido, será "
"necessário realizar uma consulta. O Hibernate suporta uma linguagem de "
"consulta (HQL) orientada a objetos fáceis de usar, porém poderosos. Para "
"criação via programação de consultas, o Hibernate suporta características "
"sofisticadas de consulta por Critério e Exemplo (QBCe QBE). Pode-se também "
"expressar a consulta por meio de SQL nativa do banco de dados, com suporte "
"opcional do Hibernate para conversão do conjunto de resultados em objetos. "

#. Tag: title
#: session_api.xml:224
#, no-c-format
msgid "Executing queries"
msgstr "Executando consultas"

#. Tag: para
#: session_api.xml:226
#, no-c-format
msgid ""
"HQL and native SQL queries are represented with an instance of <literal>org."
"hibernate.Query</literal>. This interface offers methods for parameter "
"binding, result set handling, and for the execution of the actual query. You "
"always obtain a <literal>Query</literal> using the current <literal>Session</"
"literal>:"
msgstr ""
"Consultas HQL e SQL nativas são representadas por uma instância de "
"<literal>org.hibernate.Query</literal>. Esta interface oferece métodos para "
"associação de parâmetros, tratamento de conjunto de resultados e para a "
"execução de consultas reais. Você pode obter uma <literal>Query</literal> "
"usando a <literal>Session</literal> atual:"

#. Tag: programlisting
#: session_api.xml:232
#, no-c-format
msgid ""
"List cats = session.createQuery(\n"
"    \"from Cat as cat where cat.birthdate &lt; ?\")\n"
"    .setDate(0, date)\n"
"    .list();\n"
"\n"
"List mothers = session.createQuery(\n"
"    \"select mother from Cat as cat join cat.mother as mother where cat.name "
"= ?\")\n"
"    .setString(0, name)\n"
"    .list();\n"
"\n"
"List kittens = session.createQuery(\n"
"    \"from Cat as cat where cat.mother = ?\")\n"
"    .setEntity(0, pk)\n"
"    .list();\n"
"\n"
"Cat mother = (Cat) session.createQuery(\n"
"    \"select cat.mother from Cat as cat where cat = ?\")\n"
"    .setEntity(0, izi)\n"
"    .uniqueResult();]]\n"
"\n"
"Query mothersWithKittens = (Cat) session.createQuery(\n"
"    \"select mother from Cat as mother left join fetch mother.kittens\");\n"
"Set uniqueMothers = new HashSet(mothersWithKittens.list());"
msgstr ""

#. Tag: para
#: session_api.xml:234
#, no-c-format
msgid ""
"A query is usually executed by invoking <literal>list()</literal>. The "
"result of the query will be loaded completely into a collection in memory. "
"Entity instances retrieved by a query are in a persistent state. The "
"<literal>uniqueResult()</literal> method offers a shortcut if you know your "
"query will only return a single object. Queries that make use of eager "
"fetching of collections usually return duplicates of the root objects, but "
"with their collections initialized. You can filter these duplicates through "
"a <literal>Set</literal>."
msgstr ""
"Geralmente uma consulta é executada ao invocar <literal>list()</literal>.O "
"resultado da consulta será carregado completamente em uma coleção na "
"memória. Instâncias de entidades recuperadas por uma consulta estão no "
"estado persistente. O <literal>uniqueResult()</literal> oferece um atalho se "
"você souber previamente, que a consulta retornará apenas um único objeto. "
"Repare que consultas que fazem uso da busca antecipada (eager fetching) de "
"coleções, geralmente retornam duplicatas dos objetos raiz, mas com suas "
"coleções inicializadas. Pode-se filtrar estas duplicatas através de um "
"simples <literal>Set</literal>."

#. Tag: title
#: session_api.xml:244
#, no-c-format
msgid "Iterating results"
msgstr "Interagindo com resultados"

#. Tag: para
#: session_api.xml:246
#, no-c-format
msgid ""
"Occasionally, you might be able to achieve better performance by executing "
"the query using the <literal>iterate()</literal> method. This will usually "
"be the case if you expect that the actual entity instances returned by the "
"query will already be in the session or second-level cache. If they are not "
"already cached, <literal>iterate()</literal> will be slower than "
"<literal>list()</literal> and might require many database hits for a simple "
"query, usually <emphasis>1</emphasis> for the initial select which only "
"returns identifiers, and <emphasis>n</emphasis> additional selects to "
"initialize the actual instances."
msgstr ""
"Ocasionalmente, pode-se obter um melhor desempenho com a execução de "
"consultas, usando o método <literal>iterate()</literal>. Geralmente isso "
"acontece apenas se as instâncias das entidades reais retornadas pela "
"consulta já estiverem na sessão ou no cachê de segundo nível. Caso elas "
"ainda não tenham sido armazenadas, <literal>iterate()</literal> será mais "
"devagar do que <literal>list()</literal> e podem ser necessários vários "
"acessos ao banco de dados para uma simples consulta, geralmente <emphasis>1</"
"emphasis> para a seleção inicial que retorna apenas identificadores, e "
"<emphasis>n</emphasis> consultas adicionais para inicializar as instâncias "
"reais. "

#. Tag: programlisting
#: session_api.xml:257
#, no-c-format
msgid ""
"// fetch ids\n"
"Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\")."
"iterate();\n"
"while ( iter.hasNext() ) {\n"
"    Qux qux = (Qux) iter.next();  // fetch the object\n"
"    // something we couldnt express in the query\n"
"    if ( qux.calculateComplicatedAlgorithm() ) {\n"
"        // delete the current instance\n"
"        iter.remove();\n"
"        // dont need to process the rest\n"
"        break;\n"
"    }\n"
"}"
msgstr ""

#. Tag: title
#: session_api.xml:261
#, no-c-format
msgid "Queries that return tuples"
msgstr "Consultas que retornam tuplas"

#. Tag: para
#: session_api.xml:263
#, no-c-format
msgid ""
"Hibernate queries sometimes return tuples of objects. Each tuple is returned "
"as an array:"
msgstr ""
"Algumas vezes as consultas do Hibernate retornam tuplas de objetos. Cada "
"tupla é retornada como uma matriz:"

#. Tag: programlisting
#: session_api.xml:266
#, no-c-format
msgid ""
"Iterator kittensAndMothers = sess.createQuery(\n"
"            \"select kitten, mother from Cat kitten join kitten.mother mother"
"\")\n"
"            .list()\n"
"            .iterator();\n"
"\n"
"while ( kittensAndMothers.hasNext() ) {\n"
"    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
"    Cat kitten = (Cat) tuple[0];\n"
"    Cat mother = (Cat) tuple[1];\n"
"    ....\n"
"}"
msgstr ""

#. Tag: title
#: session_api.xml:270
#, no-c-format
msgid "Scalar results"
msgstr "Resultados escalares"

#. Tag: para
#: session_api.xml:272
#, no-c-format
msgid ""
"Queries can specify a property of a class in the <literal>select</literal> "
"clause. They can even call SQL aggregate functions. Properties or aggregates "
"are considered \"scalar\" results and not entities in persistent state."
msgstr ""
"As consultas devem especificar uma propriedade da classe na cláusula "
"<literal>select</literal>. Elas também podem chamar funções SQL de "
"agregações. Propriedades ou agregações são consideradas resultados agregados "
"e não entidades no estado persistente. "

#. Tag: programlisting
#: session_api.xml:277
#, no-c-format
msgid ""
"Iterator results = sess.createQuery(\n"
"        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat \" "
"+\n"
"        \"group by cat.color\")\n"
"        .list()\n"
"        .iterator();\n"
"\n"
"while ( results.hasNext() ) {\n"
"    Object[] row = (Object[]) results.next();\n"
"    Color type = (Color) row[0];\n"
"    Date oldest = (Date) row[1];\n"
"    Integer count = (Integer) row[2];\n"
"    .....\n"
"}"
msgstr ""

#. Tag: title
#: session_api.xml:281
#, no-c-format
msgid "Bind parameters"
msgstr "Parâmetros de vínculo"

#. Tag: para
#: session_api.xml:283
#, no-c-format
msgid ""
"Methods on <literal>Query</literal> are provided for binding values to named "
"parameters or JDBC-style <literal>?</literal> parameters. <emphasis>Contrary "
"to JDBC, Hibernate numbers parameters from zero.</emphasis> Named parameters "
"are identifiers of the form <literal>:name</literal> in the query string. "
"The advantages of named parameters are as follows:"
msgstr ""
"Métodos em <literal>Consulta</literal> são oferecidos para valores de "
"vínculo para parâmetros nomeados ou de estilo JDBC <literal>?</literal>. "
"<emphasis>Ao contrário do JDBC, o Hibernate numera parâmetros a partir de "
"zero.</emphasis> Parâmetros nomeados são identificadores da forma<literal>:"
"name</literal> na faixa de consulta. As vantagens de parâmetros nomeados "
"são: "

#. Tag: para
#: session_api.xml:292
#, no-c-format
msgid ""
"named parameters are insensitive to the order they occur in the query string"
msgstr ""
"Parâmetros nomeados são insensíveis à ordem que eles ocorrem na faixa de "
"consulta"

#. Tag: para
#: session_api.xml:297
#, no-c-format
msgid "they can occur multiple times in the same query"
msgstr "eles podem ocorrer em tempos múltiplos na mesma consulta "

#. Tag: para
#: session_api.xml:301
#, no-c-format
msgid "they are self-documenting"
msgstr "eles são auto documentáveis"

#. Tag: programlisting
#: session_api.xml:305
#, no-c-format
msgid ""
"//named parameter (preferred)\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name"
"\");\n"
"q.setString(\"name\", \"Fritz\");\n"
"Iterator cats = q.iterate();"
msgstr ""

#. Tag: programlisting
#: session_api.xml:307
#, no-c-format
msgid ""
"//positional parameter\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
"q.setString(0, \"Izi\");\n"
"Iterator cats = q.iterate();"
msgstr ""

#. Tag: programlisting
#: session_api.xml:309
#, no-c-format
msgid ""
"//named parameter list\n"
"List names = new ArrayList();\n"
"names.add(\"Izi\");\n"
"names.add(\"Fritz\");\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:"
"namesList)\");\n"
"q.setParameterList(\"namesList\", names);\n"
"List cats = q.list();"
msgstr ""

#. Tag: title
#: session_api.xml:313
#, no-c-format
msgid "Pagination"
msgstr "Paginação"

#. Tag: para
#: session_api.xml:315
#, no-c-format
msgid ""
"If you need to specify bounds upon your result set, that is, the maximum "
"number of rows you want to retrieve and/or the first row you want to "
"retrieve, you can use methods of the <literal>Query</literal> interface:"
msgstr ""
"Se você precisar especificar vínculos do conjunto de resultados, o máximo de "
"números por linha que quiser recuperar e/ou a primeira linha que quiser "
"recuperar, você deve usar métodos de interface <literal>Consulta</literal>:"

#. Tag: programlisting
#: session_api.xml:320
#, no-c-format
msgid ""
"Query q = sess.createQuery(\"from DomesticCat cat\");\n"
"q.setFirstResult(20);\n"
"q.setMaxResults(10);\n"
"List cats = q.list();"
msgstr ""

#. Tag: para
#: session_api.xml:322
#, no-c-format
msgid ""
"Hibernate knows how to translate this limit query into the native SQL of "
"your DBMS."
msgstr ""
"O Hibernate sabe como traduzir esta consulta de limite para a SQL nativa de "
"seu DBMS"

#. Tag: title
#: session_api.xml:327
#, no-c-format
msgid "Scrollable iteration"
msgstr "Iteração rolável"

#. Tag: para
#: session_api.xml:329
#, no-c-format
msgid ""
"If your JDBC driver supports scrollable <literal>ResultSet</literal>s, the "
"<literal>Query</literal> interface can be used to obtain a "
"<literal>ScrollableResults</literal> object that allows flexible navigation "
"of the query results."
msgstr ""
"Se seu driver JDBC driver suportar <literal>ResultSet</literal>s roláveis, a "
"interface da <literal>Consulta</literal> poderá ser usada para obter um "
"objeto de <literal>ScrollableResults</literal>, que permite uma navegação "
"flexível dos resultados de consulta.  "

#. Tag: programlisting
#: session_api.xml:334
#, no-c-format
msgid ""
"Query q = sess.createQuery(\"select cat.name, cat from DomesticCat cat \" +\n"
"                            \"order by cat.name\");\n"
"ScrollableResults cats = q.scroll();\n"
"if ( cats.first() ) {\n"
"\n"
"    // find the first name on each page of an alphabetical list of cats by "
"name\n"
"    firstNamesOfPages = new ArrayList();\n"
"    do {\n"
"        String name = cats.getString(0);\n"
"        firstNamesOfPages.add(name);\n"
"    }\n"
"    while ( cats.scroll(PAGE_SIZE) );\n"
"\n"
"    // Now get the first page of cats\n"
"    pageOfCats = new ArrayList();\n"
"    cats.beforeFirst();\n"
"    int i=0;\n"
"    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add"
"( cats.get(1) );\n"
"\n"
"}\n"
"cats.close()"
msgstr ""

#. Tag: para
#: session_api.xml:336
#, no-c-format
msgid ""
"Note that an open database connection and cursor is required for this "
"functionality. Use <literal>setMaxResult()</literal>/<literal>setFirstResult"
"()</literal> if you need offline pagination functionality."
msgstr ""
"Note que uma conexão aberta de banco de dados (e cursor) é requerida para "
"esta função, use <literal>setMaxResult()</literal>/<literal>setFirstResult()"
"</literal> se precisar da função de paginação offline. "

#. Tag: title
#: session_api.xml:343
#, no-c-format
msgid "Externalizing named queries"
msgstr "Externando consultas nomeadas"

#. Tag: para
#: session_api.xml:345
#, no-c-format
msgid ""
"Queries can also be configured as so called named queries using annotations "
"or Hibernate mapping documents. <literal>@NamedQuery</literal> and "
"<literal>@NamedQueries</literal> can be defined at the class level as seen "
"in <xref linkend=\"example-named-query-annotation\"/> . However their "
"definitions are global to the session factory/entity manager factory scope. "
"A named query is defined by its name and the actual query string."
msgstr ""

#. Tag: title
#: session_api.xml:355
#, no-c-format
msgid "Defining a named query using <classname>@NamedQuery</classname>"
msgstr ""

#. Tag: programlisting
#: session_api.xml:358
#, no-c-format
msgid ""
"@Entity\n"
"@NamedQuery(name=\"night.moreRecentThan\", query=\"select n from Night n "
"where n.date &gt;= :date\")\n"
"public class Night {\n"
"    ...\n"
"}\n"
"\n"
"public class MyDao {\n"
"    doStuff() {\n"
"        Query q = s.getNamedQuery(\"night.moreRecentThan\");\n"
"        q.setDate( \"date\", aMonthAgo );\n"
"        List results = q.list();\n"
"        ...\n"
"    }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: session_api.xml:361
#, fuzzy, no-c-format
msgid ""
"Using a mapping document can be configured using the <literal>&lt;query&gt;</"
"literal> node. Remember to use a <literal>CDATA</literal> section if your "
"query contains characters that could be interpreted as markup."
msgstr ""
"Você pode também definir consultas nomeadas no documento de mapeamento. "
"Lembre-se de usar uma seção <literal>CDATA</literal> se sua consulta "
"contiver caracteres que possam ser interpretados como marcação."

#. Tag: title
#: session_api.xml:367
#, no-c-format
msgid "Defining a named query using <literal>&lt;query&gt;</literal>"
msgstr ""

#. Tag: programlisting
#: session_api.xml:370
#, no-c-format
msgid ""
"&lt;query name=\"ByNameAndMaximumWeight\"&gt;&lt;![CDATA[\n"
"    from eg.DomesticCat as cat\n"
"        where cat.name = ?\n"
"        and cat.weight &gt; ?\n"
"] ]&gt;&lt;/query&gt;"
msgstr ""

#. Tag: para
#: session_api.xml:373
#, fuzzy, no-c-format
msgid ""
"Parameter binding and executing is done programatically as seen in <xref "
"linkend=\"example-parameter-binding-named-query\"/>."
msgstr "O vínculo e execução de parâmetro são feitos programaticamente :"

#. Tag: title
#: session_api.xml:377
#, no-c-format
msgid "Parameter binding of a named query"
msgstr ""

#. Tag: programlisting
#: session_api.xml:379
#, no-c-format
msgid ""
"Query q = sess.getNamedQuery(\"ByNameAndMaximumWeight\");\n"
"q.setString(0, name);\n"
"q.setInt(1, minWeight);\n"
"List cats = q.list();"
msgstr ""

#. Tag: para
#: session_api.xml:382
#, no-c-format
msgid ""
"The actual program code is independent of the query language that is used. "
"You can also define native SQL queries in metadata, or migrate existing "
"queries to Hibernate by placing them in mapping files."
msgstr ""
"Note que o código de programa atual é independente da linguagem de consulta "
"que é utilizada, você também pode definir as consultas SQL nativas no "
"metadado, ou migrar consultas existentes para o Hibernate, colocando-os em "
"arquivos de mapeamento. "

#. Tag: para
#: session_api.xml:387
#, no-c-format
msgid ""
"Also note that a query declaration inside a <literal>&lt;hibernate-"
"mapping&gt;</literal> element requires a global unique name for the query, "
"while a query declaration inside a <literal>&lt;class&gt;</literal> element "
"is made unique automatically by prepending the fully qualified name of the "
"class. For example <literal>eg.Cat.ByNameAndMaximumWeight</literal>."
msgstr ""
"Observe também que uma declaração de consulta dentro de um elemento "
"<literal>&lt;hibernate-mapping&gt;</literal> requer um nome único global "
"para a consulta, enquanto uma declaração de consulta dentro de um elemento "
"de <literal>&lt;classe&gt;</literal> torna-se único automaticamente, "
"aguardando o nome completo da classe qualificada, por exemplo: <literal>eg."
"Cat.ByNameAndMaximumWeight</literal>. "

#. Tag: title
#: session_api.xml:397
#, no-c-format
msgid "Filtering collections"
msgstr "Filtrando coleções"

#. Tag: para
#: session_api.xml:399
#, no-c-format
msgid ""
"A collection <emphasis>filter</emphasis> is a special type of query that can "
"be applied to a persistent collection or array. The query string can refer "
"to <literal>this</literal>, meaning the current collection element."
msgstr ""
"Uma coleção <emphasis>filter</emphasis> é um tipo especial de consulta que "
"pode ser aplicado a uma coleção persistente ou a uma matriz. A faixa de "
"consulta pode referir-se ao <literal>this</literal>, significando o elemento "
"de coleção atual. "

#. Tag: programlisting
#: session_api.xml:404
#, no-c-format
msgid ""
"Collection blackKittens = session.createFilter(\n"
"    pk.getKittens(), \n"
"    \"where this.color = ?\")\n"
"    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
"    .list()\n"
");"
msgstr ""

#. Tag: para
#: session_api.xml:406
#, no-c-format
msgid ""
"The returned collection is considered a bag that is a copy of the given "
"collection. The original collection is not modified. This is contrary to the "
"implication of the name \"filter\", but consistent with expected behavior."
msgstr ""
"A coleção retornada é considerada uma bolsa, e é a cópia da coleção dada. A "
"coleção original não é modificada. Ela é oposta à implicação do nome \"filtro"
"\", mas é consistente com o comportamento esperado."

#. Tag: para
#: session_api.xml:411
#, no-c-format
msgid ""
"Observe that filters do not require a <literal>from</literal> clause, "
"although they can have one if required. Filters are not limited to returning "
"the collection elements themselves."
msgstr ""
"Observe que os filtros não requerem uma cláusula <literal>from</literal> "
"embora possam ter um, se requerido. Os filtros não são limitados a retornar "
"aos elementos de coleção. "

#. Tag: programlisting
#: session_api.xml:415
#, no-c-format
msgid ""
"Collection blackKittenMates = session.createFilter(\n"
"    pk.getKittens(), \n"
"    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
"    .list();"
msgstr ""

#. Tag: para
#: session_api.xml:417
#, no-c-format
msgid ""
"Even an empty filter query is useful, e.g. to load a subset of elements in a "
"large collection:"
msgstr ""
"Até mesmo um filtro vazio é útil, ex.: para carregar um subconjunto em uma "
"coleção enorme:"

#. Tag: programlisting
#: session_api.xml:420
#, no-c-format
msgid ""
"Collection tenKittens = session.createFilter(\n"
"    mother.getKittens(), \"\")\n"
"    .setFirstResult(0).setMaxResults(10)\n"
"    .list();"
msgstr ""

#. Tag: title
#: session_api.xml:424
#, no-c-format
msgid "Criteria queries"
msgstr "Consulta por critério"

#. Tag: para
#: session_api.xml:426
#, no-c-format
msgid ""
"HQL is extremely powerful, but some developers prefer to build queries "
"dynamically using an object-oriented API, rather than building query "
"strings. Hibernate provides an intuitive <literal>Criteria</literal> query "
"API for these cases:"
msgstr ""
"O HQL é extremamente potente mas alguns desenvolvedores preferem construir "
"consultas de forma dinâmica, utilizando um API de objeto, ao invés de "
"construir faixas de consultas. O Hibernate oferece uma API de consulta de "
"<literal>Critério</literal> intuitiva para estes casos: "

#. Tag: programlisting
#: session_api.xml:431
#, no-c-format
msgid ""
"Criteria crit = session.createCriteria(Cat.class);\n"
"crit.add( Restrictions.eq( \"color\", eg.Color.BLACK ) );\n"
"crit.setMaxResults(10);\n"
"List cats = crit.list();"
msgstr ""

#. Tag: para
#: session_api.xml:433
#, fuzzy, no-c-format
msgid ""
"The <literal>Criteria</literal> and the associated <literal>Example</"
"literal> API are discussed in more detail in <xref linkend=\"querycriteria\"/"
">."
msgstr ""
"Um <literal>Criteria</literal> e API associado <literal>Example</literal> "
"serão discutidos em mais detalhes em <xref linkend=\"querycriteria\" />."

#. Tag: title
#: session_api.xml:439
#, no-c-format
msgid "Queries in native SQL"
msgstr "Consultas em SQL nativa"

#. Tag: para
#: session_api.xml:441
#, no-c-format
msgid ""
"You can express a query in SQL, using <literal>createSQLQuery()</literal> "
"and let Hibernate manage the mapping from result sets to objects. You can at "
"any time call <literal>session.connection()</literal> and use the JDBC "
"<literal>Connection</literal> directly. If you choose to use the Hibernate "
"API, you must enclose SQL aliases in braces:"
msgstr ""
"Você pode expressar uma consulta em SQL utilizando <literal>createSQLQuery()"
"</literal> e deixar o Hibernate tomar conta do mapeamento desde conjuntos de "
"resultados até objetos. Note que você pode chamar uma <literal>session."
"connection()</literal> a qualquer momento e usar a <literal>Connection</"
"literal> JDBC diretamente. Se você escolher utilizar a API Hibernate, você "
"deve incluir as aliases SQL dentro de chaves: "

#. Tag: programlisting
#: session_api.xml:448
#, no-c-format
msgid ""
"List cats = session.createSQLQuery(\"SELECT {cat.*} FROM CAT {cat} WHERE "
"ROWNUM&lt;10\")\n"
"    .addEntity(\"cat\", Cat.class)\n"
".list();"
msgstr ""

#. Tag: programlisting
#: session_api.xml:450
#, no-c-format
msgid ""
"List cats = session.createSQLQuery(\n"
"    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
"           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... \" "
"+\n"
"    \"FROM CAT {cat} WHERE ROWNUM&lt;10\")\n"
"    .addEntity(\"cat\", Cat.class)\n"
".list()"
msgstr ""

#. Tag: para
#: session_api.xml:452
#, fuzzy, no-c-format
msgid ""
"SQL queries can contain named and positional parameters, just like Hibernate "
"queries. More information about native SQL queries in Hibernate can be found "
"in <xref linkend=\"querysql\"/>."
msgstr ""
"As consultas SQL podem conter parâmetros nomeados e posicionais, assim como "
"as consultas Hibernate. Maiores informações sobre as consultas nativas SQL "
"no Hibernate poderão ser encontradas em <xref linkend=\"querysql\" />."

#. Tag: title
#: session_api.xml:459
#, no-c-format
msgid "Modifying persistent objects"
msgstr "Modificando objetos persistentes"

#. Tag: para
#: session_api.xml:461
#, no-c-format
msgid ""
"<emphasis>Transactional persistent instances</emphasis> (i.e. objects "
"loaded, saved, created or queried by the <literal>Session</literal>) can be "
"manipulated by the application, and any changes to persistent state will be "
"persisted when the <literal>Session</literal> is <emphasis>flushed</"
"emphasis>. This is discussed later in this chapter. There is no need to call "
"a particular method (like <literal>update()</literal>, which has a different "
"purpose) to make your modifications persistent. The most straightforward way "
"to update the state of an object is to <literal>load()</literal> it and then "
"manipulate it directly while the <literal>Session</literal> is open:"
msgstr ""
"<emphasis>Instâncias persistentes transacionais</emphasis> (ou seja, objetos "
"carregados, salvos, criados ou consultados pela <literal>Session</literal>) "
"podem ser manipuladas pela aplicação e qualquer mudança para estado "
"persistente será persistida quando a <literal>Sessão</literal> for "
"<emphasis>limpa</emphasis>. Isto será discutido mais adiante neste capítulo. "
"Não há necessidade de chamar um método em particular (como <literal>update()"
"</literal>, que possui um propósito diferente) para fazer modificações "
"persistentes. Portanto, a forma mais direta de atualizar o estado de um "
"objeto é <literal>carregá-lo()</literal> e depois manipulá-lo diretamente, "
"enquanto a <literal>Sessão</literal> estiver aberta:"

#. Tag: programlisting
#: session_api.xml:473
#, no-c-format
msgid ""
"DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );\n"
"cat.setName(\"PK\");\n"
"sess.flush();  // changes to cat are automatically detected and persisted"
msgstr ""

#. Tag: para
#: session_api.xml:475
#, no-c-format
msgid ""
"Sometimes this programming model is inefficient, as it requires in the same "
"session both an SQL <literal>SELECT</literal> to load an object and an SQL "
"<literal>UPDATE</literal> to persist its updated state. Hibernate offers an "
"alternate approach by using detached instances."
msgstr ""
"Algumas vezes, este modelo de programação é ineficiente, uma vez que ele "
"requer ambos SQL <literal>SELECT</literal> (para carregar um objeto) e um "
"SQL<literal>UPDATE</literal> (para persistir seu estado atualizado) na mesma "
"sessão. Por isso, o Hibernate oferece uma abordagem alternativa, usando "
"instâncias desanexadas."

#. Tag: title
#: session_api.xml:483
#, no-c-format
msgid "Modifying detached objects"
msgstr "Modificando objetos desacoplados"

#. Tag: para
#: session_api.xml:485
#, no-c-format
msgid ""
"Many applications need to retrieve an object in one transaction, send it to "
"the UI layer for manipulation, then save the changes in a new transaction. "
"Applications that use this kind of approach in a high-concurrency "
"environment usually use versioned data to ensure isolation for the \"long\" "
"unit of work."
msgstr ""
"Muitas aplicações precisam recuperar um objeto em uma transação, enviá-lo "
"para a camada UI para manipulação e somente então salvar as mudanças em uma "
"nova transação. As aplicações que usam este tipo de abordagem em ambiente de "
"alta concorrência, geralmente usam dados versionados para assegurar isolação "
"durante a \"longa\" unidade de trabalho."

#. Tag: para
#: session_api.xml:491
#, no-c-format
msgid ""
"Hibernate supports this model by providing for reattachment of detached "
"instances using the <literal>Session.update()</literal> or <literal>Session."
"merge()</literal> methods:"
msgstr ""
"O Hibernate suporta este modelo, oferecendo re-acoplamentos das instâncias "
"usando os métodos <literal>Session.update()</literal> ou<literal>Session."
"merge()</literal>:"

#. Tag: programlisting
#: session_api.xml:495
#, no-c-format
msgid ""
"// in the first session\n"
"Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
"Cat potentialMate = new Cat();\n"
"firstSession.save(potentialMate);\n"
"\n"
"// in a higher layer of the application\n"
"cat.setMate(potentialMate);\n"
"\n"
"// later, in a new session\n"
"secondSession.update(cat);  // update cat\n"
"secondSession.update(mate); // update mate"
msgstr ""

#. Tag: para
#: session_api.xml:497
#, no-c-format
msgid ""
"If the <literal>Cat</literal> with identifier <literal>catId</literal> had "
"already been loaded by <literal>secondSession</literal> when the application "
"tried to reattach it, an exception would have been thrown."
msgstr ""
"Se o <literal>Cat</literal> com identificador <literal>catId</literal> já "
"tivesse sido carregado pela<literal>segundaSessão</literal> quando a "
"aplicação tentou re-acoplá-lo, teria surgido uma exceção."

#. Tag: para
#: session_api.xml:502
#, no-c-format
msgid ""
"Use <literal>update()</literal> if you are certain that the session does not "
"contain an already persistent instance with the same identifier. Use "
"<literal>merge()</literal> if you want to merge your modifications at any "
"time without consideration of the state of the session. In other words, "
"<literal>update()</literal> is usually the first method you would call in a "
"fresh session, ensuring that the reattachment of your detached instances is "
"the first operation that is executed."
msgstr ""
"Use <literal>update()</literal> se você tiver certeza de que a sessão já não "
"contém uma instância persistente com o mesmo identificador, e <literal>merge"
"()</literal> se você quiser mesclar suas modificações a qualquer momento sem "
"considerar o estado da sessão. Em outras palavras, <literal>update()</"
"literal> é geralmente o primeiro método que você chama em uma nova sessão, "
"assegurando que o re-acoplamento de suas instâncias seja a primeira operação "
"executada. "

#. Tag: para
#: session_api.xml:510
#, fuzzy, no-c-format
msgid ""
"The application should individually <literal>update()</literal> detached "
"instances that are reachable from the given detached instance "
"<emphasis>only</emphasis> if it wants their state to be updated. This can be "
"automated using <emphasis>transitive persistence</emphasis>. See <xref "
"linkend=\"objectstate-transitive\"/> for more information."
msgstr ""
"A aplicação deve <literal>update()</literal> instâncias desanexadas "
"individualmente, ao alcance da atual instância desanexada, se e "
"<emphasis>somente</emphasis> se, esta requerer uma atualização também de seu "
"estado. Esta ação pode ser automatizada utilizando <emphasis>persistência "
"transitiva</emphasis>. Consulte <xref linkend=\"objectstate-transitive\"/> "
"para maiores informações. "

#. Tag: para
#: session_api.xml:516
#, no-c-format
msgid ""
"The <literal>lock()</literal> method also allows an application to "
"reassociate an object with a new session. However, the detached instance has "
"to be unmodified."
msgstr ""
"O método <literal>lock()</literal> também permite que um aplicativo re-"
"associe um objeto com uma nova sessão. No entanto, a instância desanexada "
"não pode ser modificada."

#. Tag: programlisting
#: session_api.xml:520
#, no-c-format
msgid ""
"//just reassociate:\n"
"sess.lock(fritz, LockMode.NONE);\n"
"//do a version check, then reassociate:\n"
"sess.lock(izi, LockMode.READ);\n"
"//do a version check, using SELECT ... FOR UPDATE, then reassociate:\n"
"sess.lock(pk, LockMode.UPGRADE);"
msgstr ""

#. Tag: para
#: session_api.xml:522
#, no-c-format
msgid ""
"Note that <literal>lock()</literal> can be used with various "
"<literal>LockMode</literal>s. See the API documentation and the chapter on "
"transaction handling for more information. Reattachment is not the only "
"usecase for <literal>lock()</literal>."
msgstr ""
"Note que <literal>lock()</literal> pode ser usado com diversos "
"<literal>LockMode</literal>s, veja a documentação API e o capítulo sobre "
"manuseio de transações para maiores informações. Re-acoplamento não é o "
"único caso de uso para <literal>lock()</literal>.  "

#. Tag: para
#: session_api.xml:527
#, fuzzy, no-c-format
msgid ""
"Other models for long units of work are discussed in <xref linkend="
"\"transactions-optimistic\"/>."
msgstr ""
"Outros modelos para unidades longas de trabalho serão discutidas em <xref "
"linkend=\"transactions-optimistic\" />."

#. Tag: title
#: session_api.xml:532
#, no-c-format
msgid "Automatic state detection"
msgstr "Detecção automática de estado"

#. Tag: para
#: session_api.xml:534
#, no-c-format
msgid ""
"Hibernate users have requested a general purpose method that either saves a "
"transient instance by generating a new identifier or updates/reattaches the "
"detached instances associated with its current identifier. The "
"<literal>saveOrUpdate()</literal> method implements this functionality."
msgstr ""
"Os usuários de Hibernate solicitaram um método geral, tanto para salvar uma "
"instância transiente, gerando um novo identificador, quanto para atualizar/ "
"re-acoplar as instâncias desanexadas associadas ao seu identificador atual. "
"O método <literal>saveOrUpdate()</literal> implementa esta funcionalidade."

#. Tag: programlisting
#: session_api.xml:540
#, no-c-format
msgid ""
"// in the first session\n"
"Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
"\n"
"// in a higher tier of the application\n"
"Cat mate = new Cat();\n"
"cat.setMate(mate);\n"
"\n"
"// later, in a new session\n"
"secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-"
"null id)\n"
"secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null "
"id)"
msgstr ""

#. Tag: para
#: session_api.xml:542
#, no-c-format
msgid ""
"The usage and semantics of <literal>saveOrUpdate()</literal> seems to be "
"confusing for new users. Firstly, so long as you are not trying to use "
"instances from one session in another new session, you should not need to "
"use <literal>update()</literal>, <literal>saveOrUpdate()</literal>, or "
"<literal>merge()</literal>. Some whole applications will never use either of "
"these methods."
msgstr ""
"O uso e semântica do <literal>saveOrUpdate()</literal> parecem ser confusos "
"para novos usuários. A princípio, enquanto você não tentar usar instâncias "
"de uma sessão em outra nova sessão, não precisará utilizar <literal>update()"
"</literal>, <literal>saveOrUpdate()</literal>, ou <literal>merge()</"
"literal>. Algumas aplicações inteiras nunca precisarão utilizar estes "
"métodos."

#. Tag: para
#: session_api.xml:549
#, no-c-format
msgid ""
"Usually <literal>update()</literal> or <literal>saveOrUpdate()</literal> are "
"used in the following scenario:"
msgstr ""
"Geralmente, <literal>update()</literal> ou <literal>saveOrUpdate()</"
"literal>são utilizados nos seguintes cenários:"

#. Tag: para
#: session_api.xml:555
#, no-c-format
msgid "the application loads an object in the first session"
msgstr "a aplicação carrega um objeto na primeira sessão"

#. Tag: para
#: session_api.xml:559
#, no-c-format
msgid "the object is passed up to the UI tier"
msgstr "o objeto é passado para a camada UI"

#. Tag: para
#: session_api.xml:563
#, no-c-format
msgid "some modifications are made to the object"
msgstr "algumas modificações são feitas ao objeto"

#. Tag: para
#: session_api.xml:567
#, no-c-format
msgid "the object is passed back down to the business logic tier"
msgstr "o objeto é retornado à camada lógica de negócios"

#. Tag: para
#: session_api.xml:571
#, no-c-format
msgid ""
"the application persists these modifications by calling <literal>update()</"
"literal> in a second session"
msgstr ""
"a aplicação persiste estas modificações, chamando <literal>update()</"
"literal> em uma segunda sessão."

#. Tag: para
#: session_api.xml:576
#, no-c-format
msgid "<literal>saveOrUpdate()</literal> does the following:"
msgstr "<literal>saveOrUpdate()</literal> faz o seguinte:"

#. Tag: para
#: session_api.xml:580
#, no-c-format
msgid "if the object is already persistent in this session, do nothing"
msgstr "se o objeto já estiver persistente nesta sessão, não faça nada"

#. Tag: para
#: session_api.xml:585
#, no-c-format
msgid ""
"if another object associated with the session has the same identifier, throw "
"an exception"
msgstr ""
"se outro objeto associado com a sessão possuir o mesmo identificador, jogue "
"uma exceção"

#. Tag: para
#: session_api.xml:590
#, no-c-format
msgid "if the object has no identifier property, <literal>save()</literal> it"
msgstr ""
"se o objeto não tiver uma propriedade de identificador <literal>salve-o()</"
"literal> "

#. Tag: para
#: session_api.xml:595
#, no-c-format
msgid ""
"if the object's identifier has the value assigned to a newly instantiated "
"object, <literal>save()</literal> it"
msgstr ""
"se o identificador do objeto possuir o valor atribuído ao objeto "
"recentemente instanciado, <literal>salve-o()</literal> "

#. Tag: para
#: session_api.xml:600
#, no-c-format
msgid ""
"if the object is versioned by a <literal>&lt;version&gt;</literal> or "
"<literal>&lt;timestamp&gt;</literal>, and the version property value is the "
"same value assigned to a newly instantiated object, <literal>save()</"
"literal> it"
msgstr ""
"se o objeto for versionado por um <literal>&lt;version&gt;</literal> ou "
"<literal>&lt;timestamp&gt;</literal>, e o valor da propriedade da versão for "
"o mesmo valor atribuído ao objeto recentemente instanciado, <literal>salve()"
"</literal> o mesmo"

#. Tag: para
#: session_api.xml:608
#, no-c-format
msgid "otherwise <literal>update()</literal> the object"
msgstr "do contrário <literal>atualize()</literal> o objeto"

#. Tag: para
#: session_api.xml:612
#, no-c-format
msgid "and <literal>merge()</literal> is very different:"
msgstr "e a <literal>mesclagem()</literal> é bastante diferente:"

#. Tag: para
#: session_api.xml:616
#, no-c-format
msgid ""
"if there is a persistent instance with the same identifier currently "
"associated with the session, copy the state of the given object onto the "
"persistent instance"
msgstr ""
"se existir uma instância persistente com um mesmo identificador associado "
"atualmente com a sessão, copie o estado do objeto dado para a instância "
"persistente."

#. Tag: para
#: session_api.xml:622
#, no-c-format
msgid ""
"if there is no persistent instance currently associated with the session, "
"try to load it from the database, or create a new persistent instance"
msgstr ""
"se não existir uma instância persistente atualmente associada com a sessão, "
"tente carregá-la a partir do banco de dados, ou crie uma nova instância "
"persistente"

#. Tag: para
#: session_api.xml:628
#, no-c-format
msgid "the persistent instance is returned"
msgstr "a instância persistente é retornada"

#. Tag: para
#: session_api.xml:632
#, no-c-format
msgid ""
"the given instance does not become associated with the session, it remains "
"detached"
msgstr ""
"a instância dada não se torna associada com a sessão, ela permanece "
"desanexada"

#. Tag: title
#: session_api.xml:639
#, no-c-format
msgid "Deleting persistent objects"
msgstr "Apagando objetos persistentes"

#. Tag: para
#: session_api.xml:641
#, no-c-format
msgid ""
"<literal>Session.delete()</literal> will remove an object's state from the "
"database. Your application, however, can still hold a reference to a deleted "
"object. It is best to think of <literal>delete()</literal> as making a "
"persistent instance, transient."
msgstr ""
"A <literal>Session.delete()</literal> removerá um estado de objeto do banco "
"de dados. É claro que seu aplicativo pode ainda reter uma referência à um "
"objeto apagado. É melhor pensar em <literal>delete()</literal> como fazer "
"uma instância persistente se tornar transiente.  "

#. Tag: programlisting
#: session_api.xml:646
#, no-c-format
msgid "sess.delete(cat);"
msgstr ""

#. Tag: para
#: session_api.xml:648
#, no-c-format
msgid ""
"You can delete objects in any order, without risk of foreign key constraint "
"violations. It is still possible to violate a <literal>NOT NULL</literal> "
"constraint on a foreign key column by deleting objects in the wrong order, e."
"g. if you delete the parent, but forget to delete the children."
msgstr ""
"Você poderá deletar objetos na ordem que desejar, sem risco de violação de "
"restrição da chave estrangeira.  É possível violar uma restrição "
"<literal>NOT NULL</literal> em uma coluna de chave estrangeira, apagando "
"objetos na ordem inversa, ex.: se apagar o pai, mas esquecer de apagar o "
"filho.  "

#. Tag: title
#: session_api.xml:656
#, no-c-format
msgid "Replicating object between two different datastores"
msgstr "Replicando objeto entre dois armazenamentos de dados diferentes."

#. Tag: para
#: session_api.xml:658
#, no-c-format
msgid ""
"It is sometimes useful to be able to take a graph of persistent instances "
"and make them persistent in a different datastore, without regenerating "
"identifier values."
msgstr ""
"Algumas vezes é útil poder tirar um gráfico de instâncias persistentes e "
"fazê-los persistentes em um armazenamento de dados diferente, sem gerar "
"novamente valores de identificador. "

#. Tag: programlisting
#: session_api.xml:662
#, no-c-format
msgid ""
"//retrieve a cat from one database\n"
"Session session1 = factory1.openSession();\n"
"Transaction tx1 = session1.beginTransaction();\n"
"Cat cat = session1.get(Cat.class, catId);\n"
"tx1.commit();\n"
"session1.close();\n"
"\n"
"//reconcile with a second database\n"
"Session session2 = factory2.openSession();\n"
"Transaction tx2 = session2.beginTransaction();\n"
"session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
"tx2.commit();\n"
"session2.close();"
msgstr ""

#. Tag: para
#: session_api.xml:664
#, no-c-format
msgid ""
"The <literal>ReplicationMode</literal> determines how <literal>replicate()</"
"literal> will deal with conflicts with existing rows in the database:"
msgstr ""
"O <literal>ReplicationMode</literal> determina como o <literal>replicate()</"
"literal> irá lidar com conflitos em linhas existentes no banco de dados: "

#. Tag: para
#: session_api.xml:670
#, no-c-format
msgid ""
"<literal>ReplicationMode.IGNORE</literal>: ignores the object when there is "
"an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.IGNORE</literal>: ignore o objeto quando houver uma "
"linha de banco de dados existente com o mesmo identificador."

#. Tag: para
#: session_api.xml:675
#, no-c-format
msgid ""
"<literal>ReplicationMode.OVERWRITE</literal>: overwrites any existing "
"database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.OVERWRITE</literal>: subscreva uma linha de banco "
"de dados existente com um mesmo identificador."

#. Tag: para
#: session_api.xml:680
#, no-c-format
msgid ""
"<literal>ReplicationMode.EXCEPTION</literal>: throws an exception if there "
"is an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.EXCEPTION</literal>: jogue uma exceção se houver "
"uma linha de banco de dados existente com o mesmo identificador. "

#. Tag: para
#: session_api.xml:686
#, no-c-format
msgid ""
"<literal>ReplicationMode.LATEST_VERSION</literal>: overwrites the row if its "
"version number is earlier than the version number of the object, or ignore "
"the object otherwise"
msgstr ""
"<literal>ReplicationMode.LATEST_VERSION</literal>: subscreva a linha se seu "
"número de versão for anterior ao número de versão do objeto, caso contrário, "
"ignore o objeto."

#. Tag: para
#: session_api.xml:692
#, no-c-format
msgid ""
"Usecases for this feature include reconciling data entered into different "
"database instances, upgrading system configuration information during "
"product upgrades, rolling back changes made during non-ACID transactions and "
"more."
msgstr ""
"O caso de uso para este recurso inclui dados de reconciliação em instâncias "
"de banco de dados diferentes, atualizando informações da configuração do "
"sistema durante a atualização do produto, retornando mudanças realizadas "
"durante transações não ACID entre outras funções."

#. Tag: title
#: session_api.xml:699
#, no-c-format
msgid "Flushing the Session"
msgstr "Limpando a Sessão"

#. Tag: para
#: session_api.xml:701
#, no-c-format
msgid ""
"Sometimes the <literal>Session</literal> will execute the SQL statements "
"needed to synchronize the JDBC connection's state with the state of objects "
"held in memory. This process, called <emphasis>flush</emphasis>, occurs by "
"default at the following points:"
msgstr ""
"De vez em quando, a <literal>Session</literal> irá executar as instruções "
"SQL, necessárias para sincronizar o estado de conexão JDBC com o estado de "
"objetos mantidos na memória. Este processo de <emphasis>flush</emphasis>, "
"ocorre por padrão nos seguintes pontos: "

#. Tag: para
#: session_api.xml:709
#, no-c-format
msgid "before some query executions"
msgstr "antes de algumas execuções de consultas"

#. Tag: para
#: session_api.xml:713
#, no-c-format
msgid "from <literal>org.hibernate.Transaction.commit()</literal>"
msgstr "a partir de<literal>org.hibernate.Transaction.commit()</literal>"

#. Tag: para
#: session_api.xml:718
#, no-c-format
msgid "from <literal>Session.flush()</literal>"
msgstr "a partir de <literal>Session.flush()</literal>"

#. Tag: para
#: session_api.xml:722
#, no-c-format
msgid "The SQL statements are issued in the following order:"
msgstr "As instruções SQL são editadas na seguinte ordem:"

#. Tag: para
#: session_api.xml:726
#, no-c-format
msgid ""
"all entity insertions in the same order the corresponding objects were saved "
"using <literal>Session.save()</literal>"
msgstr ""
"todas as inserções de entidade, na mesma ordem que os objetos "
"correspondentes foram salvos usando <literal>Session.save()</literal> "

#. Tag: para
#: session_api.xml:731
#, no-c-format
msgid "all entity updates"
msgstr "todas as atualizações de entidades"

#. Tag: para
#: session_api.xml:735
#, no-c-format
msgid "all collection deletions"
msgstr "todas as deleções de coleções"

#. Tag: para
#: session_api.xml:739
#, no-c-format
msgid "all collection element deletions, updates and insertions"
msgstr "todas as deleções, atualizações e inserções de elementos de coleção."

#. Tag: para
#: session_api.xml:743
#, no-c-format
msgid "all collection insertions"
msgstr "todas as inserções de coleção"

#. Tag: para
#: session_api.xml:747
#, no-c-format
msgid ""
"all entity deletions in the same order the corresponding objects were "
"deleted using <literal>Session.delete()</literal>"
msgstr ""
"todas as deleções de entidade, na mesma ordem que os objetos correspondentes "
"foram deletados usando <literal>Session.delete()</literal> "

#. Tag: para
#: session_api.xml:752
#, no-c-format
msgid ""
"An exception is that objects using <literal>native</literal> ID generation "
"are inserted when they are saved."
msgstr ""
"Uma exceção é que o objeto que utiliza a geração de ID <literal>native</"
"literal> é inserido quando salvo."

#. Tag: para
#: session_api.xml:755
#, no-c-format
msgid ""
"Except when you explicitly <literal>flush()</literal>, there are absolutely "
"no guarantees about <emphasis>when</emphasis> the <literal>Session</literal> "
"executes the JDBC calls, only the <emphasis>order</emphasis> in which they "
"are executed. However, Hibernate does guarantee that the <literal>Query.list"
"(..)</literal> will never return stale or incorrect data."
msgstr ""
"Exceto quando você explicitamente <literal>limpar()</literal>, não há "
"nenhuma garantia sobre <emphasis>quando</emphasis> a <literal>Sessão</"
"literal> executará as chamadas de JDBC, somente se sabe a <emphasis>ordem</"
"emphasis> na qual elas são executadas. No entanto, o Hibernate garante que a "
"<literal>Query.list(..)</literal> nunca retornará dados antigos, nem "
"retornará dados errados. "

#. Tag: para
#: session_api.xml:762
#, fuzzy, no-c-format
msgid ""
"It is possible to change the default behavior so that flush occurs less "
"frequently. The <literal>FlushMode</literal> class defines three different "
"modes: only flush at commit time when the Hibernate <literal>Transaction</"
"literal> API is used, flush automatically using the explained routine, or "
"never flush unless <literal>flush()</literal> is called explicitly. The last "
"mode is useful for long running units of work, where a <literal>Session</"
"literal> is kept open and disconnected for a long time (see <xref linkend="
"\"transactions-optimistic-longsession\"/>)."
msgstr ""
"É possível mudar o comportamento padrão para que a limpeza ocorra com menos "
"freqüência. A classe <literal>FlushMode</literal> define três modos "
"diferentes: somente limpe em um tempo submetido: somente quando a API da "
"<literal>Transaction</literal> do Hibernate for usada, limpe automaticamente "
"usando uma rotina explicada, ou nunca limpe a menos que o <literal>flush()</"
"literal> seja chamado explicitamente. O último modo é útil para execução de "
"unidades de trabalho longas, onde uma <literal>Session</literal> é mantida "
"aberta e disconectada por um longo tempo (veja <xref linkend=\"transactions-"
"optimistic-longsession\"/>). "

#. Tag: programlisting
#: session_api.xml:772
#, no-c-format
msgid ""
"sess = sf.openSession();\n"
"Transaction tx = sess.beginTransaction();\n"
"sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state\n"
"\n"
"Cat izi = (Cat) sess.load(Cat.class, id);\n"
"izi.setName(iznizi);\n"
"\n"
"// might return stale data\n"
"sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
"\n"
"// change to izi is not flushed!\n"
"...\n"
"tx.commit(); // flush occurs\n"
"sess.close();"
msgstr ""

#. Tag: para
#: session_api.xml:774
#, fuzzy, no-c-format
msgid ""
"During flush, an exception might occur (e.g. if a DML operation violates a "
"constraint). Since handling exceptions involves some understanding of "
"Hibernate's transactional behavior, we discuss it in <xref linkend="
"\"transactions\"/>."
msgstr ""
"Durante uma limpeza, pode ocorrer uma exceção (ex.: se uma operação DML "
"violar uma restrição). Como o manuseio de exceções envolve algum "
"entendimento do comportamento transacional do Hibernate, discutiremos sobre "
"isso em <xref linkend=\"transactions\" />."

#. Tag: title
#: session_api.xml:781
#, no-c-format
msgid "Transitive persistence"
msgstr "Persistência Transitiva"

#. Tag: para
#: session_api.xml:783
#, no-c-format
msgid ""
"It is quite cumbersome to save, delete, or reattach individual objects, "
"especially if you deal with a graph of associated objects. A common case is "
"a parent/child relationship. Consider the following example:"
msgstr ""
"É um tanto incômodo salvar, deletar ou reanexar objetos individuais, "
"especialmente ao lidar com um grafo de objetos associados. Um caso comum é "
"um relacionamento pai/filho. Considere o seguinte exemplo: "

#. Tag: para
#: session_api.xml:788
#, no-c-format
msgid ""
"If the children in a parent/child relationship would be value typed (e.g. a "
"collection of addresses or strings), their life cycle would depend on the "
"parent and no further action would be required for convenient \"cascading\" "
"of state changes. When the parent is saved, the value-typed child objects "
"are saved and when the parent is deleted, the children will be deleted, etc. "
"This works for operations such as the removal of a child from the "
"collection. Since value-typed objects cannot have shared references, "
"Hibernate will detect this and delete the child from the database."
msgstr ""
"Se os filhos em um relacionamento pai/filho fossem do tipo valor (ex.: "
"coleção de endereços ou strings), seus ciclos de vida dependeriam do pai e "
"nenhuma ação seria requerida para \"cascateamento\" de mudança de estado. "
"Quando o pai é salvo, os objetos filho de valor são salvos também, quando o "
"pai é deletado, os filhos também serão deletados, etc. Isto funciona até "
"para operações como remoção de filho da coleção. O Hibernate irá detectar "
"isto e como objetos de valor não podem ter referências compartilhadas, irá "
"deletar o filho do banco de dados.  "

#. Tag: para
#: session_api.xml:798
#, no-c-format
msgid ""
"Now consider the same scenario with parent and child objects being entities, "
"not value-types (e.g. categories and items, or parent and child cats). "
"Entities have their own life cycle and support shared references. Removing "
"an entity from the collection does not mean it can be deleted), and there is "
"by default no cascading of state from one entity to any other associated "
"entities. Hibernate does not implement <emphasis>persistence by "
"reachability</emphasis> by default."
msgstr ""
"Agora considere o mesmo cenário com objeto pai e filho sendo entidades, e "
"não de valores (ex.: categorias e ítens, ou cats pai e filho). As entidades "
"possuem seus próprios ciclos de vida, suportam referências compartilhadas "
"(portanto, remover uma entidade da coleção não significa que possa ter sido "
"deletada), e não existe efeito cascata de estado, por padrão, a partir de "
"uma entidade para outras entidades associadas. O Hibernate não implementa "
"<emphasis>persistência por alcance</emphasis> por padrão. "

#. Tag: para
#: session_api.xml:806
#, no-c-format
msgid ""
"For each basic operation of the Hibernate session - including "
"<literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), "
"evict(), replicate()</literal> - there is a corresponding cascade style. "
"Respectively, the cascade styles are named <literal>create, merge, save-"
"update, delete, lock, refresh, evict, replicate</literal>. If you want an "
"operation to be cascaded along an association, you must indicate that in the "
"mapping document. For example:"
msgstr ""
"Para cada operação básica da sessão do Hibernate, incluindo<literal>persistir"
"(), mesclar(), salvarOuAtualizar(), deletar(), bloquear(), atualizar(), "
"despejar(), replicar()</literal>, existe um estilo cascata correspondente. "
"Respectivamente, os estilos cascatas são nomeados <literal>criar, mesclar, "
"salvar-atualizar, deletar, bloquiar, atualizar, despejar, replicar</"
"literal>. Se desejar uma operação em cascata junto a associação, você deverá "
"indicar isto no documento de mapeamento. Por exemplo:"

#. Tag: programlisting
#: session_api.xml:814
#, no-c-format
msgid "&lt;one-to-one name=\"person\" cascade=\"persist\"/&gt;"
msgstr ""

#. Tag: para
#: session_api.xml:816
#, no-c-format
msgid "Cascade styles my be combined:"
msgstr "Estilo cascata pode ser combinado:"

#. Tag: programlisting
#: session_api.xml:818
#, no-c-format
msgid "&lt;one-to-one name=\"person\" cascade=\"persist,delete,lock\"/&gt;"
msgstr ""

#. Tag: para
#: session_api.xml:820
#, no-c-format
msgid ""
"You can even use <literal>cascade=\"all\"</literal> to specify that "
"<emphasis>all</emphasis> operations should be cascaded along the "
"association. The default <literal>cascade=\"none\"</literal> specifies that "
"no operations are to be cascaded."
msgstr ""
"Você pode até utilizar <literal>cascade=\"all\"</literal> para especificar "
"que <emphasis>todas</emphasis> as operações devem estar em cascata junto à "
"associação. O padrão <literal>cascade=\"none\"</literal> especifica que "
"nenhuma operação deve estar em cascata. "

#. Tag: para
#: session_api.xml:825
#, no-c-format
msgid ""
"In case you are using annotatons you probably have noticed the "
"<literal>cascade</literal> attribute taking an array of "
"<classname>CascadeType</classname> as a value. The cascade concept in JPA is "
"very is similar to the transitive persistence and cascading of operations as "
"described above, but with slightly different semantics and cascading types:"
msgstr ""

#. Tag: para
#: session_api.xml:834
#, no-c-format
msgid ""
"<literal>CascadeType.PERSIST</literal>: cascades the persist (create) "
"operation to associated entities persist() is called or if the entity is "
"managed"
msgstr ""

#. Tag: para
#: session_api.xml:840
#, no-c-format
msgid ""
"<literal>CascadeType.MERGE</literal>: cascades the merge operation to "
"associated entities if merge() is called or if the entity is managed"
msgstr ""

#. Tag: para
#: session_api.xml:846
#, no-c-format
msgid ""
"<literal>CascadeType.REMOVE</literal>: cascades the remove operation to "
"associated entities if delete() is called"
msgstr ""

#. Tag: para
#: session_api.xml:851
#, no-c-format
msgid ""
"<literal>CascadeType.REFRESH:</literal> cascades the refresh operation to "
"associated entities if refresh() is called"
msgstr ""

#. Tag: para
#: session_api.xml:856
#, no-c-format
msgid ""
"<literal>CascadeType.DETACH:</literal> cascades the detach operation to "
"associated entities if detach() is called"
msgstr ""

#. Tag: para
#: session_api.xml:861
#, fuzzy, no-c-format
msgid "<literal>CascadeType.ALL</literal>: all of the above"
msgstr "<literal>saveOrUpdate()</literal> faz o seguinte:"

#. Tag: para
#: session_api.xml:866
#, no-c-format
msgid ""
"CascadeType.ALL also covers Hibernate specific operations like save-update, "
"lock etc..."
msgstr ""

#. Tag: para
#: session_api.xml:870
#, no-c-format
msgid ""
"A special cascade style, <literal>delete-orphan</literal>, applies only to "
"one-to-many associations, and indicates that the <literal>delete()</literal> "
"operation should be applied to any child object that is removed from the "
"association. Using annotations there is no <literal>CascadeType.DELETE-"
"ORPHAN</literal> equivalent. Instead you can use the attribute "
"<literal>orphanRemoval as seen in </literal><xref linkend=\"example-one-to-"
"many-with-orphan-removal\"/>. If an entity is removed from a "
"<classname>@OneToMany</classname> collection or an associated entity is "
"dereferenced from a <classname>@OneToOne</classname> association, this "
"associated entity can be marked for deletion if <literal>orphanRemoval</"
"literal> is set to true."
msgstr ""

#. Tag: title
#: session_api.xml:883
#, no-c-format
msgid "<literal>@OneToMany</literal> with <literal>orphanRemoval</literal>"
msgstr ""

#. Tag: programlisting
#: session_api.xml:886
#, no-c-format
msgid ""
"@Entity \n"
"public class Customer {\n"
"   private Set&lt;Order&gt; orders;\n"
"\n"
"   @OneToMany(cascade=CascadeType.ALL, orphanRemoval=true) \n"
"   public Set&lt;Order&gt; getOrders() { return orders; }\n"
"\n"
"   public void setOrders(Set&lt;Order&gt; orders) { this.orders = orders; }\n"
"\n"
"   [...]\n"
"}\n"
"\n"
"@Entity \n"
"public class Order { ... }\n"
"\n"
"Customer customer = em.find(Customer.class, 1l);\n"
"Order order = em.find(Order.class, 1l);\n"
"customer.getOrders().remove(order); //order will be deleted by cascade"
msgstr ""

#. Tag: para
#: session_api.xml:889
#, no-c-format
msgid "Recommendations:"
msgstr "Recomendações:"

#. Tag: para
#: session_api.xml:893
#, fuzzy, no-c-format
msgid ""
"It does not usually make sense to enable cascade on a many-to-one or many-to-"
"many association. In fact the <literal>@ManyToOne</literal> and "
"<literal>@ManyToMany</literal> don't even offer a <literal>orphanRemoval</"
"literal> attribute. Cascading is often useful for one-to-one and one-to-many "
"associations."
msgstr ""
"Não faz sentido habilitar a cascata em uma associação. <literal>&lt;many-to-"
"one&gt;</literal> ou <literal>&lt;many-to-many&gt;</literal> A Cascata é "
"geralmente útil para associações <literal>&lt;one-to-one&gt;</literal> e "
"<literal>&lt;one-to-many&gt;</literal>."

#. Tag: para
#: session_api.xml:901
#, fuzzy, no-c-format
msgid ""
"If the child object's lifespan is bounded by the lifespan of the parent "
"object, make it a <emphasis>life cycle object</emphasis> by specifying "
"<literal>cascade=\"all,delete-orphan\"(<literal>@OneToMany"
"(cascade=CascadeType.ALL, orphanRemoval=true)</literal>)</literal>."
msgstr ""
"Se o tempo de vida do objeto filho estiver vinculado ao tempo de vida do "
"objeto pai, faça disto um <emphasis>objeto de ciclo de vida</emphasis> "
"especificando um <literal>cascade=\"all,delete-orphan\"</literal>."

#. Tag: para
#: session_api.xml:909
#, no-c-format
msgid ""
"Otherwise, you might not need cascade at all. But if you think that you will "
"often be working with the parent and children together in the same "
"transaction, and you want to save yourself some typing, consider using "
"<literal>cascade=\"persist,merge,save-update\"</literal>."
msgstr ""
"Caso contrário, você pode não precisar realizar a cascata. Mas se você achar "
"que irá trabalhar com o pai e filho juntos com freqüência, na mesma "
"transação, e quiser salvar você mesmo, considere o uso do <literal>cascata="
"\"persistir,mesclar,salvar-atualizar\"</literal>."

#. Tag: para
#: session_api.xml:917
#, no-c-format
msgid ""
"Mapping an association (either a single valued association, or a collection) "
"with <literal>cascade=\"all\"</literal> marks the association as a "
"<emphasis>parent/child</emphasis> style relationship where save/update/"
"delete of the parent results in save/update/delete of the child or children."
msgstr ""
"Ao mapear uma associação (tanto uma associação de valor único como uma "
"coleção) com  <literal>casca de=\"all\"</literal>, a associação é demarcada  "
"como um relacionamento de estilo <emphasis>parent/child</emphasis> onde "
"salvar/atualizar/deletar do pai, resulta em salvar/atualizar/deletar do(s) "
"filho(s)."

#. Tag: para
#: session_api.xml:923
#, fuzzy, no-c-format
msgid ""
"Furthermore, a mere reference to a child from a persistent parent will "
"result in save/update of the child. This metaphor is incomplete, however. A "
"child which becomes unreferenced by its parent is <emphasis>not</emphasis> "
"automatically deleted, except in the case of a one-to-many association "
"mapped with <literal>cascade=\"delete-orphan\"</literal>. The precise "
"semantics of cascading operations for a parent/child relationship are as "
"follows:"
msgstr ""
"Além disso, uma mera referência ao filho de um pai persistente irá resultar "
"em salvar/atualizar/ o filho. Entretanto, esta metáfora está incompleta. Um "
"filho, que não é referenciado por seu pai <emphasis>não</emphasis> é "
"deletado automaticamente, exceto no caso de uma associação <literal>&lt;one-"
"to-many&gt;</literal> mapeada com <literal>casca de=\"delete-orphan\"</"
"literal>. A semântica exata, de operações em cascata para o relacionamento "
"pai/filho, são como as que se seguem: "

#. Tag: para
#: session_api.xml:934
#, no-c-format
msgid ""
"If a parent is passed to <literal>persist()</literal>, all children are "
"passed to <literal>persist()</literal>"
msgstr ""
"Se um pai é passado para <literal>persist()</literal>, todos os filhos são "
"passados para <literal>persist()</literal>"

#. Tag: para
#: session_api.xml:939
#, no-c-format
msgid ""
"If a parent is passed to <literal>merge()</literal>, all children are passed "
"to <literal>merge()</literal>"
msgstr ""
"Se um pai é passado para <literal>merge()</literal>, todos os filhos são "
"passados para  <literal>merge()</literal>"

#. Tag: para
#: session_api.xml:944
#, no-c-format
msgid ""
"If a parent is passed to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, all children are passed to "
"<literal>saveOrUpdate()</literal>"
msgstr ""
"Se um pai for passado para <literal>save()</literal>, <literal>update()</"
"literal> ou <literal>saveOrUpdate()</literal>, todos os filhos passarão para "
"<literal>saveOrUpdate()</literal>"

#. Tag: para
#: session_api.xml:950
#, no-c-format
msgid ""
"If a transient or detached child becomes referenced by a persistent parent, "
"it is passed to <literal>saveOrUpdate()</literal>"
msgstr ""
"Se um filho transiente ou desanexado se tornar referenciado pelo pai "
"persistente, ele será passado para <literal>saveOrUpdate()</literal>"

#. Tag: para
#: session_api.xml:956
#, no-c-format
msgid ""
"If a parent is deleted, all children are passed to <literal>delete()</"
"literal>"
msgstr ""
"Se um pai for deletado, todos os filhos serão passados para <literal>delete()"
"</literal>"

#. Tag: para
#: session_api.xml:961
#, no-c-format
msgid ""
"If a child is dereferenced by a persistent parent, <emphasis>nothing special "
"happens</emphasis> - the application should explicitly delete the child if "
"necessary - unless <literal>cascade=\"delete-orphan\"</literal>, in which "
"case the \"orphaned\" child is deleted."
msgstr ""
"Se um filho for diferenciado pelo pai persistente, <emphasis>nada de "
"especial acontece</emphasis> - a aplicação deve explicitamente deletar o "
"filho se necessário, a não ser que <literal>casca de=\"delete-orphan\"</"
"literal>, nos quais casos o filho \"órfão\" é deletado."

#. Tag: para
#: session_api.xml:969
#, no-c-format
msgid ""
"Finally, note that cascading of operations can be applied to an object graph "
"at <emphasis>call time</emphasis> or at <emphasis>flush time</emphasis>. All "
"operations, if enabled, are cascaded to associated entities reachable when "
"the operation is executed. However, <literal>save-update</literal> and "
"<literal>delete-orphan</literal> are transitive for all associated entities "
"reachable during flush of the <literal>Session</literal>."
msgstr ""
"Finalmente, note que o cascateamento das operações podem ser aplicados a um "
"grafo de objeto em <emphasis>tempo de chamada</emphasis> ou em "
"<emphasis>tempo de limpeza</emphasis>. Todas as operações, se habilitadas, "
"são colocadas em cascata para entidades associadas atingíveis quando a "
"operação for executada. No entanto, <literal>save-upate</literal> e "
"<literal>delete-orphan</literal> são transitivas para todas as entidades "
"associadas atingíveis durante a limpeza da <literal>Sessão</literal>. "

#. Tag: title
#: session_api.xml:979
#, no-c-format
msgid "Using metadata"
msgstr "Usando metadados"

#. Tag: para
#: session_api.xml:981
#, no-c-format
msgid ""
"Hibernate requires a rich meta-level model of all entity and value types. "
"This model can be useful to the application itself. For example, the "
"application might use Hibernate's metadata to implement a \"smart\" deep-"
"copy algorithm that understands which objects should be copied (eg. mutable "
"value types) and which objects that should not (e.g. immutable value types "
"and, possibly, associated entities)."
msgstr ""
"O Hibernate requer um modelo muito rico, em nível de metadados, de todas as "
"entidades e tipos de valores. De tempos em tempos, este modelo é muito útil "
"à própria aplicação. Por exemplo, a aplicação pode usar os metadados do "
"Hibernate, que executa um algoritmo \"inteligente\", que compreende quais "
"objetos podem ser copiados (por exemplo, tipos de valores mutáveis) ou não "
"(por exemplo, tipos de valores imutáveis e, possivelmente, entidades "
"associadas). "

#. Tag: para
#: session_api.xml:988
#, no-c-format
msgid ""
"Hibernate exposes metadata via the <literal>ClassMetadata</literal> and "
"<literal>CollectionMetadata</literal> interfaces and the <literal>Type</"
"literal> hierarchy. Instances of the metadata interfaces can be obtained "
"from the <literal>SessionFactory</literal>."
msgstr ""
"O Hibernate expõe os metadados via interfaces <literal>ClassMetadata</"
"literal> e <literal>CollectionMetadata</literal> e pela hierarquia "
"<literal>Type</literal>. Instâncias das interfaces de metadados podem ser "
"obtidas a partir do <literal>SessionFactory</literal>. "

#. Tag: programlisting
#: session_api.xml:993
#, no-c-format
msgid ""
"Cat fritz = ......;\n"
"ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
"\n"
"Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
"String[] propertyNames = catMeta.getPropertyNames();\n"
"Type[] propertyTypes = catMeta.getPropertyTypes();\n"
"\n"
"// get a Map of all properties which are not collections or associations\n"
"Map namedValues = new HashMap();\n"
"for ( int i=0; i&lt;propertyNames.length; i++ ) {\n"
"    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i]."
"isCollectionType() ) {\n"
"        namedValues.put( propertyNames[i], propertyValues[i] );\n"
"    }\n"
"}"
msgstr ""

#, fuzzy
#~ msgid ""
#~ "Hibernate does not offer its own API for direct execution of "
#~ "<literal>UPDATE</literal> or <literal>DELETE</literal> statements. "
#~ "Hibernate is a <emphasis>state management</emphasis> service, you do not "
#~ "have to think in <emphasis>statements</emphasis> to use it. JDBC is a "
#~ "perfect API for executing SQL statements, you can get a JDBC "
#~ "<literal>Connection</literal> at any time by calling <literal>session."
#~ "connection()</literal>. Furthermore, the notion of mass operations "
#~ "conflicts with object/relational mapping for online transaction "
#~ "processing-oriented applications. Future versions of Hibernate can, "
#~ "however, provide special mass operation functions. See <xref linkend="
#~ "\"batch\"/> for some possible batch operation tricks."
#~ msgstr ""
#~ "Note que o Hibernate não oferece seu próprio API para execução direta de "
#~ "instruções <literal>UPDATE</literal> ou <literal>DELETE</literal>. O "
#~ "Hibernate é um serviço de <emphasis>gerenciamento de estado</emphasis> "
#~ "que você nem precisa se preocupar com <emphasis>instruções</emphasis> "
#~ "para utilizá-lo. O JDBC é um API perfeito para executar instruções SQL, "
#~ "você pode ter uma <literal>Connection</literal> JDBC a qualquer momento, "
#~ "chamando <literal>session.connection()</literal>. Além disso, a noção de "
#~ "operações em massa conflitua com o mapeamento de objeto/relacional para "
#~ "aplicativos de transações online com processamento. No entanto, versões "
#~ "futuras do Hibernate poderão oferecer funções especiais de operação em "
#~ "massa. Veja <xref linkend=\"batch\" />  para alguns possíveis truques de "
#~ "operação em lote. "

#~ msgid ""
#~ "A special cascade style, <literal>delete-orphan</literal>, applies only "
#~ "to one-to-many associations, and indicates that the <literal>delete()</"
#~ "literal> operation should be applied to any child object that is removed "
#~ "from the association."
#~ msgstr ""
#~ "Um estilo especial em cascata, <literal>delete-orphan</literal>, aplica "
#~ "somente associações um-para-um, e indica que a operação <literal>delete()"
#~ "</literal> deve ser aplicada em qualquer objeto filho que seja removido "
#~ "da associação."
