# translation of Collection_Mapping.po to
# Xi HUANG <xhuang@redhat.com>, 2007, 2010.
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-20 21:02+0000\n"
"PO-Revision-Date: 2010-01-18 15:09+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: query_sql.xml:31
#, no-c-format
msgid "Native SQL"
msgstr "ネイティブ SQL"

#. Tag: para
#: query_sql.xml:33
#, no-c-format
msgid ""
"You can also express queries in the native SQL dialect of your database. "
"This is useful if you want to utilize database-specific features such as "
"query hints or the <literal>CONNECT</literal> keyword in Oracle. It also "
"provides a clean migration path from a direct SQL/JDBC based application to "
"Hibernate."
msgstr ""
"データベースのネイティブ SQL 方言を使ってクエリを表現することもできます。クエ"
"リヒントや Oracle の <literal>CONNECT</literal> キーワードのように、データ"
"ベース独自の機能を利用したいときに使えます。 SQL/JDBC を直接使用しているアプ"
"リケーションから Hibernate への移行も容易にしています。"

#. Tag: para
#: query_sql.xml:39
#, no-c-format
msgid ""
"Hibernate3 allows you to specify handwritten SQL, including stored "
"procedures, for all create, update, delete, and load operations."
msgstr ""
"Hibernate3 では、生成、更新、削除、読み込み処理のようなすべての SQL （ストア"
"ドプロシージャを含む）を手書きできます。"

#. Tag: title
#: query_sql.xml:43
#, fuzzy, no-c-format
msgid "Using a <literal>SQLQuery</literal>"
msgstr "もしくは <literal>List</literal> として、"

#. Tag: para
#: query_sql.xml:45
#, no-c-format
msgid ""
"Execution of native SQL queries is controlled via the <literal>SQLQuery</"
"literal> interface, which is obtained by calling <literal>Session."
"createSQLQuery()</literal>. The following sections describe how to use this "
"API for querying."
msgstr ""
"ネイティブな SQL クエリの実行は <literal>SQLQuery</literal> インターフェース"
"を通して制御します。 <literal>SQLQuery</literal> インターフェースは "
"<literal>Session.createSQLQuery()</literal> を呼び出して取得します。この API "
"を使って問い合わせする方法を以下で説明します。"

#. Tag: title
#: query_sql.xml:51
#, no-c-format
msgid "Scalar queries"
msgstr "スカラーのクエリ"

#. Tag: para
#: query_sql.xml:53
#, no-c-format
msgid "The most basic SQL query is to get a list of scalars (values)."
msgstr "最も基本的な SQL クエリはスカラー（値）のリストを得ることです。"

#. Tag: programlisting
#: query_sql.xml:56
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();"
msgstr ""
"sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();"

#. Tag: para
#: query_sql.xml:58
#, no-c-format
msgid ""
"These will return a List of Object arrays (Object[]) with scalar values for "
"each column in the CATS table. Hibernate will use ResultSetMetadata to "
"deduce the actual order and types of the returned scalar values."
msgstr ""
"これらはどちらも、 CATS テーブルの各カラムのスカラー値を含む Object 配列"
"（Object[]）のリストを返します。返すスカラー値の実際の順番と型を推定するため"
"に、 Hibernate は ResultSetMetadata を使用します。"

#. Tag: para
#: query_sql.xml:63
#, no-c-format
msgid ""
"To avoid the overhead of using <literal>ResultSetMetadata</literal>, or "
"simply to be more explicit in what is returned, one can use "
"<literal>addScalar()</literal>:"
msgstr ""
"<literal>ResultSetMetadata</literal> を使用するオーバーヘッドを避けるため、も"
"しくは単に何が返されるか明確にするため、 <literal>addScalar()</literal> を使"
"えます。"

#. Tag: programlisting
#: query_sql.xml:67
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
" .addScalar(\"ID\", Hibernate.LONG)\n"
" .addScalar(\"NAME\", Hibernate.STRING)\n"
" .addScalar(\"BIRTHDATE\", Hibernate.DATE)"
msgstr ""
"sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
" .addScalar(\"ID\", Hibernate.LONG)\n"
" .addScalar(\"NAME\", Hibernate.STRING)\n"
" .addScalar(\"BIRTHDATE\", Hibernate.DATE)"

#. Tag: para
#: query_sql.xml:69 query_sql.xml:116 query_sql.xml:197 query_sql.xml:349
#, no-c-format
msgid "This query specified:"
msgstr "このクエリで指定されているものを下記に示します:"

#. Tag: para
#: query_sql.xml:73 query_sql.xml:120 query_sql.xml:353
#, no-c-format
msgid "the SQL query string"
msgstr "SQL クエリ文字列"

#. Tag: para
#: query_sql.xml:77
#, no-c-format
msgid "the columns and types to return"
msgstr "返されるカラムと型"

#. Tag: para
#: query_sql.xml:81
#, no-c-format
msgid ""
"This will return Object arrays, but now it will not use "
"<literal>ResultSetMetadata</literal> but will instead explicitly get the ID, "
"NAME and BIRTHDATE column as respectively a Long, String and a Short from "
"the underlying resultset. This also means that only these three columns will "
"be returned, even though the query is using <literal>*</literal> and could "
"return more than the three listed columns."
msgstr ""
"これはまだ Object 配列を返しますが、 <literal>ResultSetMetdata</literal> を使"
"用しません。ただし、その代わりに基礎にあるリザルトセットから ID、NAME、"
"BIRTHDATE カラムをそれぞれ Long、String、Short として明示的に取得します。これ"
"は３つのカラムを返すのみであることも意味します。たとえ、クエリが <literal>*</"
"literal> を使用し、列挙した３つより多くのカラムを返せるとしてもです。"

#. Tag: para
#: query_sql.xml:89
#, no-c-format
msgid ""
"It is possible to leave out the type information for all or some of the "
"scalars."
msgstr "スカラーの型情報を省くこともできます。"

#. Tag: programlisting
#: query_sql.xml:92
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
" .addScalar(\"ID\", Hibernate.LONG)\n"
" .addScalar(\"NAME\")\n"
" .addScalar(\"BIRTHDATE\")"
msgstr ""
"sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
" .addScalar(\"ID\", Hibernate.LONG)\n"
" .addScalar(\"NAME\")\n"
" .addScalar(\"BIRTHDATE\")"

#. Tag: para
#: query_sql.xml:94
#, no-c-format
msgid ""
"This is essentially the same query as before, but now "
"<literal>ResultSetMetaData</literal> is used to determine the type of NAME "
"and BIRTHDATE, where as the type of ID is explicitly specified."
msgstr ""
"これは本質的に前と同じクエリですが、 NAME と BIRTHDATE の型を決めるために "
"<literal>ResultSetMetaData</literal> を使用します。一方、 ID の型は明示的に指"
"定されています。"

#. Tag: para
#: query_sql.xml:99
#, no-c-format
msgid ""
"How the java.sql.Types returned from ResultSetMetaData is mapped to "
"Hibernate types is controlled by the Dialect. If a specific type is not "
"mapped, or does not result in the expected type, it is possible to customize "
"it via calls to <literal>registerHibernateType</literal> in the Dialect."
msgstr ""
"ResultSetMetaData から返される java.sql.Types を Hibernate の型に マッピング"
"することは、 Dialect が制御します。明示された型がマッピングされていないか、結"
"果の型が期待したものと異なる場合、 Dialect の "
"<literal>registerHibernateType</literal> を呼び出し、カスタマイズできます。"

#. Tag: title
#: query_sql.xml:107
#, no-c-format
msgid "Entity queries"
msgstr "エンティティのクエリ"

#. Tag: para
#: query_sql.xml:109
#, no-c-format
msgid ""
"The above queries were all about returning scalar values, basically "
"returning the \"raw\" values from the resultset. The following shows how to "
"get entity objects from a native sql query via <literal>addEntity()</"
"literal>."
msgstr ""
"ここまでのクエリは、すべてスカラー値を返すものでした。基本的に、リザルトセッ"
"トから「未加工」の値を返します。以降では、 <literal>addEntity()</literal> に"
"より、ネイティブ SQL クエリからエンティティオブジェクトを取得する方法を示しま"
"す。"

#. Tag: programlisting
#: query_sql.xml:114
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat."
"class);"
msgstr ""
"sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat."
"class);"

#. Tag: para
#: query_sql.xml:124
#, no-c-format
msgid "the entity returned by the query"
msgstr "クエリが返すエンティティと SQL テーブルの別名"

#. Tag: para
#: query_sql.xml:128
#, no-c-format
msgid ""
"Assuming that Cat is mapped as a class with the columns ID, NAME and "
"BIRTHDATE the above queries will both return a List where each element is a "
"Cat entity."
msgstr ""
"Cat が ID 、 NAME 、 BIRTHDATE のカラムを使ってクラスにマッピングされる場合、"
"上記のクエリはどちらも、要素が Cat エンティティであるリストを返します。"

#. Tag: para
#: query_sql.xml:132
#, no-c-format
msgid ""
"If the entity is mapped with a <literal>many-to-one</literal> to another "
"entity it is required to also return this when performing the native query, "
"otherwise a database specific \"column not found\" error will occur. The "
"additional columns will automatically be returned when using the * notation, "
"but we prefer to be explicit as in the following example for a <literal>many-"
"to-one</literal> to a <literal>Dog</literal>:"
msgstr ""
"エンティティを別のエンティティに <literal>多対一</literal> でマッピングしてい"
"る場合は、ネイティブクエリを実行する際に、この別のエンティティを返すことも要"
"求します。さもなければ、データベース固有の「column not found(カラムが見つかり"
"ません)」エラーが発生します。 * 表記を使用した際は、追加のカラムが自動的に返"
"されますが、次の例のように、 <literal>Dog</literal> に <literal>多対一</"
"literal> であることを明示することを私たちは好みます。"

#. Tag: programlisting
#: query_sql.xml:140
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\")."
"addEntity(Cat.class);"
msgstr ""
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\")."
"addEntity(Cat.class);"

#. Tag: para
#: query_sql.xml:142
#, no-c-format
msgid "This will allow cat.getDog() to function properly."
msgstr "これにより cat.getDog() が正しく機能します。"

#. Tag: title
#: query_sql.xml:146
#, no-c-format
msgid "Handling associations and collections"
msgstr "関連とコレクションの操作"

#. Tag: para
#: query_sql.xml:148
#, no-c-format
msgid ""
"It is possible to eagerly join in the <literal>Dog</literal> to avoid the "
"possible extra roundtrip for initializing the proxy. This is done via the "
"<literal>addJoin()</literal> method, which allows you to join in an "
"association or collection."
msgstr ""
"プロキシを初期化するための余分な処理を避けるため、 <literal>Dog</literal> の"
"中で即時結合できます。これは <literal>addJoin()</literal> メソッドにより行い"
"ます。関連もしくはコレクションに結合できます。"

#. Tag: programlisting
#: query_sql.xml:153
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME "
"FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addJoin(\"cat.dog\");"
msgstr ""
"sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME "
"FROM CATS c, DOGS d \n"
"    WHERE c.DOG_ID = d.D_ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addJoin(\"cat.dog\");"

#. Tag: para
#: query_sql.xml:155
#, no-c-format
msgid ""
"In this example, the returned <literal>Cat</literal>'s will have their "
"<literal>dog</literal> property fully initialized without any extra "
"roundtrip to the database. Notice that you added an alias name (\"cat\") to "
"be able to specify the target property path of the join. It is possible to "
"do the same eager joining for collections, e.g. if the <literal>Cat</"
"literal> had a one-to-many to <literal>Dog</literal> instead."
msgstr ""
"この例の中で、返される <literal>Cat</literal> は、データベースへの余分処理な"
"しで、完全に初期化された <literal>dog</literal> プロパティを持ちます。結合対"
"象のプロパティへのパスを指定できるように、別名（「cat」）を追加したことに注意"
"してください。コレクションの即時結合も同じようにできます。たとえば、 "
"<literal>Cat</literal> が一対多で <literal>Dog</literal> を持っていた場合、次"
"のようになります。"

#. Tag: programlisting
#: query_sql.xml:163
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM "
"CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addJoin(\"cat.dogs\");"
msgstr ""
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM "
"CATS c, DOGS d\n"
"    WHERE c.ID = d.CAT_ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addJoin(\"cat.dogs\");"

#. Tag: para
#: query_sql.xml:165
#, no-c-format
msgid ""
"At this stage you are reaching the limits of what is possible with native "
"queries, without starting to enhance the sql queries to make them usable in "
"Hibernate. Problems can arise when returning multiple entities of the same "
"type or when the default alias/column names are not enough."
msgstr ""
"現在のところ、 Hibernate で使いやすくするための SQL クエリの拡張なしに、ネイ"
"ティブクエリで何かを可能にする限界に来ています。同じ型のエンティティを複数返"
"す際や、デフォルトの別名や列名で十分ではない場合に、問題は起こり始めます。"

#. Tag: title
#: query_sql.xml:173
#, no-c-format
msgid "Returning multiple entities"
msgstr "複数エンティティの取得"

#. Tag: para
#: query_sql.xml:175
#, no-c-format
msgid ""
"Until now, the result set column names are assumed to be the same as the "
"column names specified in the mapping document. This can be problematic for "
"SQL queries that join multiple tables, since the same column names can "
"appear in more than one table."
msgstr ""
"ここまでは、リザルトセットのカラム名は、マッピングドキュメントで指定されたカ"
"ラム名と同じであると仮定していました。複数のテーブルが同じカラム名を持つ場合"
"があるため、複数テーブルを結合する SQL クエリで問題となる場合があります。"

#. Tag: para
#: query_sql.xml:180
#, no-c-format
msgid ""
"Column alias injection is needed in the following query (which most likely "
"will fail):"
msgstr ""
"下記のような（失敗しそうな）クエリでは、カラム別名インジェクション（column "
"alias injection）が必要です："

#. Tag: programlisting
#: query_sql.xml:183
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID "
"= c.ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addEntity(\"mother\", Cat.class)"
msgstr ""
"sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID "
"= c.ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addEntity(\"mother\", Cat.class)"

#. Tag: para
#: query_sql.xml:185
#, no-c-format
msgid ""
"The query was intended to return two Cat instances per row: a cat and its "
"mother. The query will, however, fail because there is a conflict of names; "
"the instances are mapped to the same column names. Also, on some databases "
"the returned column aliases will most likely be on the form \"c.ID\", \"c."
"NAME\", etc. which are not equal to the columns specified in the mappings "
"(\"ID\" and \"NAME\")."
msgstr ""
"このクエリの意図は、１行ごとに２つの Cat インスタンス、つまり猫とその母親を返"
"すということです。同じカラム名にマッピングすることにより名前が衝突するため、"
"このクエリは失敗します。ベータベースによっては、返されるカラムの別名が \"c.ID"
"\"、\"c.NAME\" などの形式であり、マッピングで指定されたカラム（\"ID\" と "
"\"NAME\"）と等しくないため、失敗します。"

#. Tag: para
#: query_sql.xml:192
#, no-c-format
msgid "The following form is not vulnerable to column name duplication:"
msgstr "下記の形式は、カラム名が重複しても大丈夫です："

#. Tag: programlisting
#: query_sql.xml:195
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE "
"c.MOTHER_ID = c.ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addEntity(\"mother\", Cat.class)"
msgstr ""
"sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE "
"c.MOTHER_ID = c.ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addEntity(\"mother\", Cat.class)"

#. Tag: para
#: query_sql.xml:201
#, no-c-format
msgid ""
"the SQL query string, with placeholders for Hibernate to inject column "
"aliases"
msgstr ""
"SQL クエリ文字列 （Hibernate がカラムの別名を挿入するためのプレースホルダを含"
"む）"

#. Tag: para
#: query_sql.xml:206
#, no-c-format
msgid "the entities returned by the query"
msgstr "クエリによって返されるエンティティ"

#. Tag: para
#: query_sql.xml:210
#, no-c-format
msgid ""
"The {cat.*} and {mother.*} notation used above is a shorthand for \"all "
"properties\". Alternatively, you can list the columns explicitly, but even "
"in this case Hibernate injects the SQL column aliases for each property. The "
"placeholder for a column alias is just the property name qualified by the "
"table alias. In the following example, you retrieve Cats and their mothers "
"from a different table (cat_log) to the one declared in the mapping "
"metadata. You can even use the property aliases in the where clause."
msgstr ""
"上記で使用している {cat.*} と {mother.*} という表記は、「すべてのプロパティ」"
"を表す省略形です。代わりに、明示的にカラムを列挙してもよいですが、その場合"
"は、 Hibernate に各プロパティに対応する SQL カラムの別名を挿入させるべきで"
"しょう。カラムの別名のためのプレースホルダは、テーブルの別名によって修飾され"
"たプロパティ名です。下記の例では、別のテーブル cat_log から マッピングメタ"
"データで定義された Cat とその母親を復元します。もし好むなら、 where 節の中で"
"も、プロパティの別名を使えます。"

#. Tag: programlisting
#: query_sql.xml:219
#, fuzzy, no-c-format
msgid ""
"String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" +\n"
"         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} "
"\" +\n"
"         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
"\n"
"List loggedCats = sess.createSQLQuery(sql)\n"
"        .addEntity(\"cat\", Cat.class)\n"
"        .addEntity(\"mother\", Cat.class).list()"
msgstr ""
"String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
"         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} "
"\" +\n"
"         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
"\n"
"List loggedCats = sess.createSQLQuery(sql)\n"
"        .addEntity(\"cat\", Cat.class)\n"
"        .addEntity(\"mother\", Cat.class).list()"

#. Tag: title
#: query_sql.xml:222
#, no-c-format
msgid "Alias and property references"
msgstr "別名とプロパティのリファレンス"

#. Tag: para
#: query_sql.xml:224
#, no-c-format
msgid ""
"In most cases the above alias injection is needed. For queries relating to "
"more complex mappings, like composite properties, inheritance "
"discriminators, collections etc., you can use specific aliases that allow "
"Hibernate to inject the proper aliases."
msgstr ""
"多くの場合、上記のような別名インジェクションが必要です。ただし、複合プロパ"
"ティ、継承識別子、コレクションなどのようなより複雑なマッピングと関連するクエ"
"リがなければです。ある特定の別名を使用することにより、 Hibernate は適切な別名"
"を挿入できます。"

#. Tag: para
#: query_sql.xml:229
#, no-c-format
msgid ""
"The following table shows the different ways you can use the alias "
"injection. Please note that the alias names in the result are simply "
"examples; each alias will have a unique and probably different name when "
"used."
msgstr ""
"別名インジェクションとして使用できるものを下表に示します。注記：下表の別名は"
"一例です。それぞれの別名は一意であり、使用する際にはおそらく異なる名前を持ち"
"ます。"

#. Tag: title
#: query_sql.xml:235
#, no-c-format
msgid "Alias injection names"
msgstr "別名に挿入する名前"

#. Tag: entry
#: query_sql.xml:246
#, no-c-format
msgid "Description"
msgstr "説明"

#. Tag: entry
#: query_sql.xml:248
#, no-c-format
msgid "Syntax"
msgstr "構文"

#. Tag: entry
#: query_sql.xml:250
#, no-c-format
msgid "Example"
msgstr "例"

#. Tag: entry
#: query_sql.xml:256
#, no-c-format
msgid "A simple property"
msgstr "単純なプロパティ"

#. Tag: literal
#: query_sql.xml:258
#, fuzzy, no-c-format
msgid "{[aliasname].[propertyname]"
msgstr "<literal>{[aliasname].[propertyname]</literal>"

#. Tag: literal
#: query_sql.xml:260
#, fuzzy, no-c-format
msgid "A_NAME as {item.name}"
msgstr "<literal>A_NAME as {item.name}</literal>"

#. Tag: entry
#: query_sql.xml:264
#, no-c-format
msgid "A composite property"
msgstr "複合プロパティ"

#. Tag: literal
#: query_sql.xml:266
#, fuzzy, no-c-format
msgid "{[aliasname].[componentname].[propertyname]}"
msgstr "<literal>{[aliasname].[componentname].[propertyname]}</literal>"

#. Tag: literal
#: query_sql.xml:268
#, fuzzy, no-c-format
msgid "CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}"
msgstr ""
"<literal>CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</"
"literal>"

#. Tag: entry
#: query_sql.xml:273
#, no-c-format
msgid "Discriminator of an entity"
msgstr "エンティティのクラスを識別する値"

#. Tag: literal
#: query_sql.xml:275
#, fuzzy, no-c-format
msgid "{[aliasname].class}"
msgstr "<literal>{[aliasname].class}</literal>"

#. Tag: literal
#: query_sql.xml:277
#, fuzzy, no-c-format
msgid "DISC as {item.class}"
msgstr "<literal>DISC as {item.class}</literal>"

#. Tag: entry
#: query_sql.xml:281
#, no-c-format
msgid "All properties of an entity"
msgstr "エンティティの全プロパティ"

#. Tag: literal
#: query_sql.xml:283 query_sql.xml:331
#, fuzzy, no-c-format
msgid "{[aliasname].*}"
msgstr "<literal>{[aliasname].*}</literal>"

#. Tag: literal
#: query_sql.xml:285
#, no-c-format
msgid "{item.*}"
msgstr "{item.*}"

#. Tag: entry
#: query_sql.xml:289
#, no-c-format
msgid "A collection key"
msgstr "コレクションのキー"

#. Tag: literal
#: query_sql.xml:291
#, fuzzy, no-c-format
msgid "{[aliasname].key}"
msgstr "<literal>{[aliasname].key}</literal>"

#. Tag: literal
#: query_sql.xml:293
#, fuzzy, no-c-format
msgid "ORGID as {coll.key}"
msgstr "<literal>ORGID as {coll.key}</literal>"

#. Tag: entry
#: query_sql.xml:297
#, no-c-format
msgid "The id of an collection"
msgstr "コレクションの ID"

#. Tag: literal
#: query_sql.xml:299
#, fuzzy, no-c-format
msgid "{[aliasname].id}"
msgstr "<literal>{[aliasname].id}</literal>"

#. Tag: literal
#: query_sql.xml:301
#, fuzzy, no-c-format
msgid "EMPID as {coll.id}"
msgstr "<literal>EMPID as {coll.id}</literal>"

#. Tag: entry
#: query_sql.xml:305
#, no-c-format
msgid "The element of an collection"
msgstr "コレクションの要素"

#. Tag: literal
#: query_sql.xml:307
#, fuzzy, no-c-format
msgid "{[aliasname].element}"
msgstr "<literal>{[aliasname].element}</literal>"

#. Tag: literal
#: query_sql.xml:309
#, fuzzy, no-c-format
msgid "XID as {coll.element}"
msgstr "<literal>XID as {coll.element}</literal>"

#. Tag: entry
#: query_sql.xml:313
#, no-c-format
msgid "property of the element in the collection"
msgstr "コレクションの要素のプロパティ"

#. Tag: literal
#: query_sql.xml:315
#, fuzzy, no-c-format
msgid "{[aliasname].element.[propertyname]}"
msgstr "<literal>{[aliasname].element.[propertyname]}</literal>"

#. Tag: literal
#: query_sql.xml:317
#, fuzzy, no-c-format
msgid "NAME as {coll.element.name}"
msgstr "<literal>NAME as {coll.element.name}</literal>"

#. Tag: entry
#: query_sql.xml:321
#, no-c-format
msgid "All properties of the element in the collection"
msgstr "コレクションの要素の全プロパティ"

#. Tag: literal
#: query_sql.xml:323
#, fuzzy, no-c-format
msgid "{[aliasname].element.*}"
msgstr "<literal>{[aliasname].element.*}</literal>"

#. Tag: literal
#: query_sql.xml:325
#, fuzzy, no-c-format
msgid "{coll.element.*}"
msgstr "{coll.*}"

#. Tag: entry
#: query_sql.xml:329
#, fuzzy, no-c-format
msgid "All properties of the collection"
msgstr "コレクションの全プロパティ"

#. Tag: literal
#: query_sql.xml:333
#, no-c-format
msgid "{coll.*}"
msgstr "{coll.*}"

#. Tag: title
#: query_sql.xml:342
#, no-c-format
msgid "Returning non-managed entities"
msgstr "管理されていないエンティティの取得"

#. Tag: para
#: query_sql.xml:344
#, no-c-format
msgid ""
"It is possible to apply a ResultTransformer to native SQL queries, allowing "
"it to return non-managed entities."
msgstr ""
"ネイティブ SQL クエリに ResultTransformer を適用できます。下記のように、例え"
"ば、管理されていないエンティティを返します。"

#. Tag: programlisting
#: query_sql.xml:347
#, fuzzy, no-c-format
msgid ""
"sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
"        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))"
msgstr ""
"sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
"        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))"

#. Tag: para
#: query_sql.xml:357
#, no-c-format
msgid "a result transformer"
msgstr "結果を変換したもの"

#. Tag: para
#: query_sql.xml:361
#, no-c-format
msgid ""
"The above query will return a list of <literal>CatDTO</literal> which has "
"been instantiated and injected the values of NAME and BIRTHNAME into its "
"corresponding properties or fields."
msgstr ""
"上記のクエリは、インスタンス化し、 NAME と BIRTHDATE の値を対応するプロパティ"
"もしくはフィールドに挿入した <literal>CatDTO</literal> のリストを返します。"

#. Tag: title
#: query_sql.xml:367
#, no-c-format
msgid "Handling inheritance"
msgstr "継承の制御"

#. Tag: para
#: query_sql.xml:369
#, no-c-format
msgid ""
"Native SQL queries which query for entities that are mapped as part of an "
"inheritance must include all properties for the baseclass and all its "
"subclasses."
msgstr ""
"継承の一部としてマッピングされたエンティティを問い合わせるネイティブ SQL クエ"
"リは、ベースのクラスとそのすべてのサブクラスのプロパティすべてを含まなければ"
"なりません。"

#. Tag: title
#: query_sql.xml:375
#, no-c-format
msgid "Parameters"
msgstr "パラメータ"

#. Tag: para
#: query_sql.xml:377
#, no-c-format
msgid "Native SQL queries support positional as well as named parameters:"
msgstr ""
"ネイティブ SQL クエリは、以下のように、名前付きパラメータ（:name）と同様に位"
"置パラメータをサポートします:"

#. Tag: programlisting
#: query_sql.xml:380
#, fuzzy, no-c-format
msgid ""
"Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?\")."
"addEntity(Cat.class);\n"
"List pusList = query.setString(0, \"Pus%\").list();\n"
"     \n"
"query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\")."
"addEntity(Cat.class);\n"
"List pusList = query.setString(\"name\", \"Pus%\").list();"
msgstr ""
"Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?\")."
"addEntity(Cat.class);\n"
"List pusList = query.setString(0, \"Pus&#37;\").list();\n"
"     \n"
"query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\")."
"addEntity(Cat.class);\n"
"List pusList = query.setString(\"name\", \"Pus&#37;\").list();"

#. Tag: title
#: query_sql.xml:385
#, no-c-format
msgid "Named SQL queries"
msgstr "名前付き SQL クエリ"

#. Tag: para
#: query_sql.xml:387
#, fuzzy, no-c-format
msgid ""
"Named SQL queries can also be defined in the mapping document and called in "
"exactly the same way as a named HQL query (see <xref linkend=\"objectstate-"
"querying-executing-named\"/>). In this case, you do <emphasis>not</emphasis> "
"need to call <literal>addEntity()</literal>."
msgstr ""
"名前付き SQL クエリはマッピングドキュメントで定義することができ、名前付き "
"HQL クエリと全く同じ方法で呼ぶことができます。この場合、 <literal>addEntity()"
"</literal> を呼び出す必要は <emphasis>ありません</emphasis> 。"

#. Tag: title
#: query_sql.xml:394
#, no-c-format
msgid "Named sql query using the &lt;sql-query&gt; maping element"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:397
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"persons\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex}\n"
"    FROM PERSON person\n"
"    WHERE person.NAME LIKE :namePattern\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"persons\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex}\n"
"    FROM PERSON person\n"
"    WHERE person.NAME LIKE :namePattern\n"
"&lt;/sql-query&gt;"

#. Tag: title
#: query_sql.xml:401
#, no-c-format
msgid "Execution of a named query"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:403
#, fuzzy, no-c-format
msgid ""
"List people = sess.getNamedQuery(\"persons\")\n"
"    .setString(\"namePattern\", namePattern)\n"
"    .setMaxResults(50)\n"
"    .list();"
msgstr ""
"List people = sess.getNamedQuery(\"persons\")\n"
"    .setString(\"namePattern\", namePattern)\n"
"    .setMaxResults(50)\n"
"    .list();"

#. Tag: para
#: query_sql.xml:406
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;return-join&gt;</literal> element is use to join "
"associations and the <literal>&lt;load-collection&gt;</literal> element is "
"used to define queries which initialize collections,"
msgstr ""
"関連を結合するためとコレクションを初期化するクエリを定義するために、それぞれ "
"<literal>&lt;return-join&gt;</literal> と <literal>&lt;load-collection&gt;</"
"literal> 要素を使います。"

#. Tag: title
#: query_sql.xml:411
#, no-c-format
msgid "Named sql query with association"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:413
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"personsWith\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
"    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
"&gt;\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex},\n"
"           address.STREET AS {address.street},\n"
"           address.CITY AS {address.city},\n"
"           address.STATE AS {address.state},\n"
"           address.ZIP AS {address.zip}\n"
"    FROM PERSON person\n"
"    JOIN ADDRESS address\n"
"        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"    WHERE person.NAME LIKE :namePattern\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"personsWith\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
"    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
"&gt;\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex},\n"
"           adddress.STREET AS {address.street},\n"
"           adddress.CITY AS {address.city},\n"
"           adddress.STATE AS {address.state},\n"
"           adddress.ZIP AS {address.zip}\n"
"    FROM PERSON person\n"
"    JOIN ADDRESS adddress\n"
"        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"    WHERE person.NAME LIKE :namePattern\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:416
#, no-c-format
msgid ""
"A named SQL query may return a scalar value. You must declare the column "
"alias and Hibernate type using the <literal>&lt;return-scalar&gt;</literal> "
"element:"
msgstr ""
"名前付き SQL クエリはスカラ値を返すこともできます。 <literal>&lt;return-"
"scalar&gt;</literal> 要素を使って、列の別名と Hibernate の型を宣言しなければ"
"なりません:"

#. Tag: title
#: query_sql.xml:421
#, no-c-format
msgid "Named query returning a scalar"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:423
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"mySqlQuery\"&gt;\n"
"    &lt;return-scalar column=\"name\" type=\"string\"/&gt;\n"
"    &lt;return-scalar column=\"age\" type=\"long\"/&gt;\n"
"    SELECT p.NAME AS name, \n"
"           p.AGE AS age,\n"
"    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"mySqlQuery\"&gt;\n"
"    &lt;return-scalar column=\"name\" type=\"string\"/&gt;\n"
"    &lt;return-scalar column=\"age\" type=\"long\"/&gt;\n"
"    SELECT p.NAME AS name,\n"
"           p.AGE AS age,\n"
"    FROM PERSON p WHERE p.NAME LIKE 'Hiber&#37;'\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:426
#, no-c-format
msgid ""
"You can externalize the resultset mapping information in a <literal>&lt;"
"resultset&gt;</literal> element which will allow you to either reuse them "
"across several named queries or through the <literal>setResultSetMapping()</"
"literal> API."
msgstr ""
"リザルトセットのマッピング情報を <literal>&lt;resultset&gt;</literal> に外部"
"化することができます。複数の名前付きクエリで再利用したり、 "
"<literal>setResultSetMapping()</literal> API を通して再利用したりできます。"

#. Tag: title
#: query_sql.xml:432
#, no-c-format
msgid "&lt;resultset&gt; mapping used to externalize mapping information"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:435
#, fuzzy, no-c-format
msgid ""
"&lt;resultset name=\"personAddress\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
"    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
"&gt;\n"
"&lt;/resultset&gt;\n"
"\n"
"&lt;sql-query name=\"personsWith\" resultset-ref=\"personAddress\"&gt;\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex},\n"
"           address.STREET AS {address.street},\n"
"           address.CITY AS {address.city},\n"
"           address.STATE AS {address.state},\n"
"           address.ZIP AS {address.zip}\n"
"    FROM PERSON person\n"
"    JOIN ADDRESS address\n"
"        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"    WHERE person.NAME LIKE :namePattern\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;resultset name=\"personAddress\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
"    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
"&gt;\n"
"&lt;/resultset&gt;\n"
"\n"
"&lt;sql-query name=\"personsWith\" resultset-ref=\"personAddress\"&gt;\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex},\n"
"           adddress.STREET AS {address.street},\n"
"           adddress.CITY AS {address.city},\n"
"           adddress.STATE AS {address.state},\n"
"           adddress.ZIP AS {address.zip}\n"
"    FROM PERSON person\n"
"    JOIN ADDRESS adddress\n"
"        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"    WHERE person.NAME LIKE :namePattern\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:438
#, no-c-format
msgid ""
"You can, alternatively, use the resultset mapping information in your hbm "
"files directly in java code."
msgstr ""
"代わりに、 hbm ファイル内のリザルトセットのマッピング情報を直接 Java コードの"
"中で使用できます。"

#. Tag: title
#: query_sql.xml:442
#, no-c-format
msgid "Programmatically specifying the result mapping information"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:445
#, fuzzy, no-c-format
msgid ""
"List cats = sess.createSQLQuery(\n"
"        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten."
"mother = cat.id\"\n"
"    )\n"
"    .setResultSetMapping(\"catAndKitten\")\n"
"    .list();"
msgstr ""
"List cats = sess.createSQLQuery(\n"
"        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten."
"mother = cat.id\"\n"
"    )\n"
"    .setResultSetMapping(\"catAndKitten\")\n"
"    .list();"

#. Tag: para
#: query_sql.xml:448
#, no-c-format
msgid ""
"So far we have only looked at externalizing SQL queries using Hibernate "
"mapping files. The same concept is also available with anntations and is "
"called named native queries. You can use <classname>@NamedNativeQuery</"
"classname> (<classname>@NamedNativeQueries</classname>) in conjunction with "
"<literal>@SqlResultSetMapping</literal> (<literal>@SqlResultSetMappings</"
"literal>). Like <literal>@NamedQuery</literal>, "
"<classname>@NamedNativeQuery</classname> and <literal>@SqlResultSetMapping</"
"literal> can be defined at class level, but their scope is global to the "
"application. Lets look at a view examples."
msgstr ""

#. Tag: para
#: query_sql.xml:460
#, no-c-format
msgid ""
"shows how a <literal>resultSetMapping</literal> parameter is defined in "
"<literal>@NamedNativeQuery</literal>. It represents the name of a defined "
"<literal>@SqlResultSetMapping</literal>. The resultset mapping declares the "
"entities retrieved by this native query. Each field of the entity is bound "
"to an SQL alias (or column name). All fields of the entity including the "
"ones of subclasses and the foreign key columns of related entities have to "
"be present in the SQL query. Field definitions are optional provided that "
"they map to the same column name as the one declared on the class property. "
"In the example 2 entities, <literal>Night</literal> and <literal>Area</"
"literal>, are returned and each property is declared and associated to a "
"column name, actually the column name retrieved by the query."
msgstr ""

#. Tag: para
#: query_sql.xml:475
#, no-c-format
msgid ""
"In <xref linkend=\"example-implicit-result-set-mapping\"/> the result set "
"mapping is implicit. We only describe the entity class of the result set "
"mapping. The property / column mappings is done using the entity mapping "
"values. In this case the model property is bound to the model_txt column."
msgstr ""

#. Tag: para
#: query_sql.xml:481
#, no-c-format
msgid ""
"Finally, if the association to a related entity involve a composite primary "
"key, a <literal>@FieldResult</literal> element should be used for each "
"foreign key column. The <literal>@FieldResult</literal> name is composed of "
"the property name for the relationship, followed by a dot (\".\"), followed "
"by the name or the field or property of the primary key. This can be seen in "
"<xref linkend=\"example-field-result-annotation-with-associations\"/>."
msgstr ""

#. Tag: title
#: query_sql.xml:490
#, no-c-format
msgid ""
"Named SQL query using <classname>@NamedNativeQuery</classname> together with "
"<classname>@SqlResultSetMapping</classname>"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:493
#, no-c-format
msgid ""
"@NamedNativeQuery(name=\"night&amp;area\", query=\"select night.id nid, "
"night.night_duration, \"\n"
"    + \" night.night_date, area.id aid, night.area_id, area.name \"\n"
"    + \"from Night night, Area area where night.area_id = area.id\", \n"
"                  resultSetMapping=\"joinMapping\")\n"
"@SqlResultSetMapping(name=\"joinMapping\", entities={\n"
"    @EntityResult(entityClass=Night.class, fields = {\n"
"        @FieldResult(name=\"id\", column=\"nid\"),\n"
"        @FieldResult(name=\"duration\", column=\"night_duration\"),\n"
"        @FieldResult(name=\"date\", column=\"night_date\"),\n"
"        @FieldResult(name=\"area\", column=\"area_id\"),\n"
"        discriminatorColumn=\"disc\"\n"
"    }),\n"
"    @EntityResult(entityClass=org.hibernate.test.annotations.query.Area."
"class, fields = {\n"
"        @FieldResult(name=\"id\", column=\"aid\"),\n"
"        @FieldResult(name=\"name\", column=\"name\")\n"
"    })\n"
"    }\n"
")"
msgstr ""

#. Tag: title
#: query_sql.xml:497
#, no-c-format
msgid "Implicit result set mapping"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:499
#, no-c-format
msgid ""
"@Entity\n"
"@SqlResultSetMapping(name=\"implicit\",\n"
"                     entities=@EntityResult(entityClass=SpaceShip.class))\n"
"@NamedNativeQuery(name=\"implicitSample\", \n"
"                  query=\"select * from SpaceShip\", \n"
"                  resultSetMapping=\"implicit\")\n"
"public class SpaceShip {\n"
"    private String name;\n"
"    private String model;\n"
"    private double speed;\n"
"\n"
"    @Id\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"\n"
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
"\n"
"    @Column(name=\"model_txt\")\n"
"    public String getModel() {\n"
"        return model;\n"
"    }\n"
"\n"
"    public void setModel(String model) {\n"
"        this.model = model;\n"
"    }\n"
"\n"
"    public double getSpeed() {\n"
"        return speed;\n"
"    }\n"
"\n"
"    public void setSpeed(double speed) {\n"
"        this.speed = speed;\n"
"    }\n"
"}"
msgstr ""

#. Tag: title
#: query_sql.xml:503
#, no-c-format
msgid "Using dot notation in @FieldResult for specifying associations"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:506
#, no-c-format
msgid ""
"@Entity\n"
"@SqlResultSetMapping(name=\"compositekey\",\n"
"        entities=@EntityResult(entityClass=SpaceShip.class,\n"
"            fields = {\n"
"                    @FieldResult(name=\"name\", column = \"name\"),\n"
"                    @FieldResult(name=\"model\", column = \"model\"),\n"
"                    @FieldResult(name=\"speed\", column = \"speed\"),\n"
"                    @FieldResult(name=\"captain.firstname\", column = "
"\"firstn\"),\n"
"                    @FieldResult(name=\"captain.lastname\", column = \"lastn"
"\"),\n"
"                    @FieldResult(name=\"dimensions.length\", column = "
"\"length\"),\n"
"                    @FieldResult(name=\"dimensions.width\", column = \"width"
"\")\n"
"                    }),\n"
"        columns = { @ColumnResult(name = \"surface\"),\n"
"                    @ColumnResult(name = \"volume\") } )\n"
"\n"
"@NamedNativeQuery(name=\"compositekey\",\n"
"    query=\"select name, model, speed, lname as lastn, fname as firstn, "
"length, width, length * width as surface from SpaceShip\", \n"
"    resultSetMapping=\"compositekey\")\n"
"} )\n"
"public class SpaceShip {\n"
"    private String name;\n"
"    private String model;\n"
"    private double speed;\n"
"    private Captain captain;\n"
"    private Dimensions dimensions;\n"
"\n"
"    @Id\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"\n"
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
"\n"
"    @ManyToOne(fetch= FetchType.LAZY)\n"
"    @JoinColumns( {\n"
"            @JoinColumn(name=\"fname\", referencedColumnName = \"firstname"
"\"),\n"
"            @JoinColumn(name=\"lname\", referencedColumnName = \"lastname"
"\")\n"
"            } )\n"
"    public Captain getCaptain() {\n"
"        return captain;\n"
"    }\n"
"\n"
"    public void setCaptain(Captain captain) {\n"
"        this.captain = captain;\n"
"    }\n"
"\n"
"    public String getModel() {\n"
"        return model;\n"
"    }\n"
"\n"
"    public void setModel(String model) {\n"
"        this.model = model;\n"
"    }\n"
"\n"
"    public double getSpeed() {\n"
"        return speed;\n"
"    }\n"
"\n"
"    public void setSpeed(double speed) {\n"
"        this.speed = speed;\n"
"    }\n"
"\n"
"    public Dimensions getDimensions() {\n"
"        return dimensions;\n"
"    }\n"
"\n"
"    public void setDimensions(Dimensions dimensions) {\n"
"        this.dimensions = dimensions;\n"
"    }\n"
"}\n"
"\n"
"@Entity\n"
"@IdClass(Identity.class)\n"
"public class Captain implements Serializable {\n"
"    private String firstname;\n"
"    private String lastname;\n"
"\n"
"    @Id\n"
"    public String getFirstname() {\n"
"        return firstname;\n"
"    }\n"
"\n"
"    public void setFirstname(String firstname) {\n"
"        this.firstname = firstname;\n"
"    }\n"
"\n"
"    @Id\n"
"    public String getLastname() {\n"
"        return lastname;\n"
"    }\n"
"\n"
"    public void setLastname(String lastname) {\n"
"        this.lastname = lastname;\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: query_sql.xml:510
#, no-c-format
msgid ""
"If you retrieve a single entity using the default mapping, you can specify "
"the <literal>resultClass</literal> attribute instead of "
"<literal>resultSetMapping</literal>:"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:514
#, no-c-format
msgid ""
"@NamedNativeQuery(name=\"implicitSample\", query=\"select * from SpaceShip"
"\", resultClass=SpaceShip.class)\n"
"public class SpaceShip {"
msgstr ""

#. Tag: para
#: query_sql.xml:517
#, no-c-format
msgid ""
"In some of your native queries, you'll have to return scalar values, for "
"example when building report queries. You can map them in the "
"<literal>@SqlResultsetMapping</literal> through <literal>@ColumnResult</"
"literal>. You actually can even mix, entities and scalar returns in the same "
"native query (this is probably not that common though)."
msgstr ""

#. Tag: title
#: query_sql.xml:525
#, no-c-format
msgid "Scalar values via <classname>@ColumnResult</classname>"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:527
#, no-c-format
msgid ""
"@SqlResultSetMapping(name=\"scalar\", columns=@ColumnResult(name=\"dimension"
"\"))\n"
"@NamedNativeQuery(name=\"scalar\", query=\"select length*width as dimension "
"from SpaceShip\", resultSetMapping=\"scalar\")"
msgstr ""

#. Tag: para
#: query_sql.xml:530
#, no-c-format
msgid ""
"An other query hint specific to native queries has been introduced: "
"<literal>org.hibernate.callable</literal> which can be true or false "
"depending on whether the query is a stored procedure or not."
msgstr ""

#. Tag: title
#: query_sql.xml:535
#, no-c-format
msgid "Using return-property to explicitly specify column/alias names"
msgstr "列と列の別名を明示的に指定するために return-property を使う"

#. Tag: para
#: query_sql.xml:538
#, no-c-format
msgid ""
"You can explicitly tell Hibernate what column aliases to use with "
"<literal>&lt;return-property&gt;</literal>, instead of using the <literal>{}"
"</literal>-syntax to let Hibernate inject its own aliases.For example:"
msgstr ""
"別名を挿入するために <literal>{}</literal> 構文を使う代わりに、 <literal>&lt;"
"return-property&gt;</literal> を使い、どの列の別名を使うのかを明示できます。"

#. Tag: programlisting
#: query_sql.xml:543
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"mySqlQuery\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"&gt;\n"
"        &lt;return-property name=\"name\" column=\"myName\"/&gt;\n"
"        &lt;return-property name=\"age\" column=\"myAge\"/&gt;\n"
"        &lt;return-property name=\"sex\" column=\"mySex\"/&gt;\n"
"    &lt;/return&gt;\n"
"    SELECT person.NAME AS myName,\n"
"           person.AGE AS myAge,\n"
"           person.SEX AS mySex,\n"
"    FROM PERSON person WHERE person.NAME LIKE :name\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"mySqlQuery\"&gt;\n"
"    &lt;return alias=\"person\" class=\"eg.Person\"&gt;\n"
"        &lt;return-property name=\"name\" column=\"myName\"/&gt;\n"
"        &lt;return-property name=\"age\" column=\"myAge\"/&gt;\n"
"        &lt;return-property name=\"sex\" column=\"mySex\"/&gt;\n"
"    &lt;/return&gt;\n"
"    SELECT person.NAME AS myName,\n"
"           person.AGE AS myAge,\n"
"           person.SEX AS mySex,\n"
"    FROM PERSON person WHERE person.NAME LIKE :name\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:545
#, no-c-format
msgid ""
"<literal>&lt;return-property&gt;</literal> also works with multiple columns. "
"This solves a limitation with the <literal>{}</literal>-syntax which cannot "
"allow fine grained control of multi-column properties."
msgstr ""
"<literal>&lt;return-property&gt;</literal> は複数の列も扱えます。これは、複数"
"列のプロパティをきめ細かく制御できないという、 <literal>{}</literal> 構文の制"
"限を解決します。"

#. Tag: programlisting
#: query_sql.xml:550
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"organizationCurrentEmployments\"&gt;\n"
"    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
"        &lt;return-property name=\"salary\"&gt;\n"
"            &lt;return-column name=\"VALUE\"/&gt;\n"
"            &lt;return-column name=\"CURRENCY\"/&gt;\n"
"        &lt;/return-property&gt;\n"
"        &lt;return-property name=\"endDate\" column=\"myEndDate\"/&gt;\n"
"    &lt;/return&gt;\n"
"        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
"        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
"        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
"        FROM EMPLOYMENT\n"
"        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
"        ORDER BY STARTDATE ASC\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"organizationCurrentEmployments\"&gt;\n"
"    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
"        &lt;return-property name=\"salary\"&gt;\n"
"            &lt;return-column name=\"VALUE\"/&gt;\n"
"            &lt;return-column name=\"CURRENCY\"/&gt;\n"
"        &lt;/return-property&gt;\n"
"        &lt;return-property name=\"endDate\" column=\"myEndDate\"/&gt;\n"
"    &lt;/return&gt;\n"
"        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
"        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
"        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
"        FROM EMPLOYMENT\n"
"        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
"        ORDER BY STARTDATE ASC\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:552
#, no-c-format
msgid ""
"In this example <literal>&lt;return-property&gt;</literal> was used in "
"combination with the <literal>{}</literal>-syntax for injection. This allows "
"users to choose how they want to refer column and properties."
msgstr ""
"この例では、挿入のための <literal>{}</literal> 構文といっしょに、 "
"<literal>&lt;return-property&gt;</literal> を使っていることに注意してくださ"
"い。列とプロパティをどのように参照するかを選べます。"

#. Tag: para
#: query_sql.xml:557
#, no-c-format
msgid ""
"If your mapping has a discriminator you must use <literal>&lt;return-"
"discriminator&gt;</literal> to specify the discriminator column."
msgstr ""
"マッピングに discriminator が含まれている場合、 discriminator の列を指定する"
"ために、 <literal>&lt;return-discriminator&gt;</literal> を使わなければなりま"
"せん。"

#. Tag: title
#: query_sql.xml:563
#, no-c-format
msgid "Using stored procedures for querying"
msgstr "問い合わせするためにストアドプロシージャを使う"

#. Tag: para
#: query_sql.xml:565
#, no-c-format
msgid ""
"Hibernate3 provides support for queries via stored procedures and functions. "
"Most of the following documentation is equivalent for both. The stored "
"procedure/function must return a resultset as the first out-parameter to be "
"able to work with Hibernate. An example of such a stored function in Oracle "
"9 and higher is as follows:"
msgstr ""
"Hibernate はバージョン3から、ストアドプロシージャとストアド関数経由の問い合わ"
"せがサポートされました。以降の文書の多くは、両方に当てはまります。ストアドプ"
"ロシージャやストアド関数を Hibernate で使うためには、1番目の出力パラメータと"
"してリザルトセットを返さなければなりません。 Oracle 9（もしくはそれ以上のバー"
"ジョン）のストアドプロシージャの例を以下に示します:"

#. Tag: programlisting
#: query_sql.xml:571
#, fuzzy, no-c-format
msgid ""
"CREATE OR REPLACE FUNCTION selectAllEmployments\n"
"    RETURN SYS_REFCURSOR\n"
"AS\n"
"    st_cursor SYS_REFCURSOR;\n"
"BEGIN\n"
"    OPEN st_cursor FOR\n"
" SELECT EMPLOYEE, EMPLOYER,\n"
" STARTDATE, ENDDATE,\n"
" REGIONCODE, EID, VALUE, CURRENCY\n"
" FROM EMPLOYMENT;\n"
"      RETURN  st_cursor;\n"
" END;"
msgstr ""
"CREATE OR REPLACE FUNCTION selectAllEmployments\n"
"    RETURN SYS_REFCURSOR\n"
"AS\n"
"    st_cursor SYS_REFCURSOR;\n"
"BEGIN\n"
"    OPEN st_cursor FOR\n"
" SELECT EMPLOYEE, EMPLOYER,\n"
" STARTDATE, ENDDATE,\n"
" REGIONCODE, EID, VALUE, CURRENCY\n"
" FROM EMPLOYMENT;\n"
"      RETURN  st_cursor;\n"
" END;"

#. Tag: para
#: query_sql.xml:573
#, no-c-format
msgid "To use this query in Hibernate you need to map it via a named query."
msgstr ""
"Hibernate でこのクエリを使うためには、名前付きクエリでマッピングする必要があ"
"ります。"

#. Tag: programlisting
#: query_sql.xml:576
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"selectAllEmployees_SP\" callable=\"true\"&gt;\n"
"    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
"        &lt;return-property name=\"employee\" column=\"EMPLOYEE\"/&gt;\n"
"        &lt;return-property name=\"employer\" column=\"EMPLOYER\"/&gt;\n"
"        &lt;return-property name=\"startDate\" column=\"STARTDATE\"/&gt;\n"
"        &lt;return-property name=\"endDate\" column=\"ENDDATE\"/&gt;\n"
"        &lt;return-property name=\"regionCode\" column=\"REGIONCODE\"/&gt;\n"
"        &lt;return-property name=\"id\" column=\"EID\"/&gt;\n"
"        &lt;return-property name=\"salary\"&gt;\n"
"            &lt;return-column name=\"VALUE\"/&gt;\n"
"            &lt;return-column name=\"CURRENCY\"/&gt;\n"
"        &lt;/return-property&gt;\n"
"    &lt;/return&gt;\n"
"    { ? = call selectAllEmployments() }\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"selectAllEmployees_SP\" callable=\"true\"&gt;\n"
"    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
"        &lt;return-property name=\"employee\" column=\"EMPLOYEE\"/&gt;\n"
"        &lt;return-property name=\"employer\" column=\"EMPLOYER\"/&gt;\n"
"        &lt;return-property name=\"startDate\" column=\"STARTDATE\"/&gt;\n"
"        &lt;return-property name=\"endDate\" column=\"ENDDATE\"/&gt;\n"
"        &lt;return-property name=\"regionCode\" column=\"REGIONCODE\"/&gt;\n"
"        &lt;return-property name=\"id\" column=\"EID\"/&gt;\n"
"        &lt;return-property name=\"salary\"&gt;\n"
"            &lt;return-column name=\"VALUE\"/&gt;\n"
"            &lt;return-column name=\"CURRENCY\"/&gt;\n"
"        &lt;/return-property&gt;\n"
"    &lt;/return&gt;\n"
"    { ? = call selectAllEmployments() }\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:578
#, no-c-format
msgid ""
"Stored procedures currently only return scalars and entities. <literal>&lt;"
"return-join&gt;</literal> and <literal>&lt;load-collection&gt;</literal> are "
"not supported."
msgstr ""
"注記：今のところ、ストアドプロシージャはスカラとエンティティを返すのみです。 "
"<literal>&lt;return-join&gt;</literal> と <literal>&lt;load-collection&gt;</"
"literal> はサポートされていません。"

#. Tag: title
#: query_sql.xml:583
#, no-c-format
msgid "Rules/limitations for using stored procedures"
msgstr "ストアドプロシージャを使う上でのルールと制限"

#. Tag: para
#: query_sql.xml:585
#, no-c-format
msgid ""
"You cannot use stored procedures with Hibernate unless you follow some "
"procedure/function rules. If they do not follow those rules they are not "
"usable with Hibernate. If you still want to use these procedures you have to "
"execute them via <literal>session.connection()</literal>. The rules are "
"different for each database, since database vendors have different stored "
"procedure semantics/syntax."
msgstr ""
"Hibernate でストアドプロシージャや関数を使うためには、そのプロシージャはいく"
"つかのルールに準拠する必要があります。ルールに準拠していないプロシージャは、 "
"Hibernate で使うことはできません。それでも、準拠していないプロシージャを使い"
"たいのであれば、 <literal>session.connection()</literal> を通じて実行しなけれ"
"ばなりません。ルールはデータベースごとに異なります。ストアドプロシージャのセ"
"マンティックスとシンタックスは、データベースベンダごとに異なるためです。"

#. Tag: para
#: query_sql.xml:593
#, no-c-format
msgid ""
"Stored procedure queries cannot be paged with <literal>setFirstResult()/"
"setMaxResults()</literal>."
msgstr ""
"<literal>setFirstResult()/setMaxResults()</literal> を使って、ストアドプロ"
"シージャクエリをページ分けすることはできません。"

#. Tag: para
#: query_sql.xml:596
#, no-c-format
msgid ""
"The recommended call form is standard SQL92: <literal>{ ? = call functionName"
"(&lt;parameters&gt;) }</literal> or <literal>{ ? = call procedureName(&lt;"
"parameters&gt;}</literal>. Native call syntax is not supported."
msgstr ""
"推奨する呼び出し方は、標準である SQL92 に従うことです。 <literal>{ ? = call "
"functionName(&lt;parameters&gt;) }</literal> や <literal>{ ? = call "
"procedureName(&lt;parameters&gt;}</literal> です。ネイティブな呼び出し構文は"
"サポートされていません。"

#. Tag: para
#: query_sql.xml:601
#, no-c-format
msgid "For Oracle the following rules apply:"
msgstr "Oracle には下記のルールが適用されます:"

#. Tag: para
#: query_sql.xml:605
#, no-c-format
msgid ""
"A function must return a result set. The first parameter of a procedure must "
"be an <literal>OUT</literal> that returns a result set. This is done by "
"using a <literal>SYS_REFCURSOR</literal> type in Oracle 9 or 10. In Oracle "
"you need to define a <literal>REF CURSOR</literal> type. See Oracle "
"literature for further information."
msgstr ""
"関数はリザルトセットを返さなければなりません。プロシージャの第一引数はリザル"
"トセットを返すため、 <literal>OUT</literal> でなければなりません。 Oracle 9 "
"と 10 では、 <literal>SYS_REFCURSOR</literal> を使うことによってできます。 "
"Oracle では <literal>REF CURSOR</literal> 型を定義する必要があります。 "
"Oracle の文献を参照してください。"

#. Tag: para
#: query_sql.xml:614
#, no-c-format
msgid "For Sybase or MS SQL server the following rules apply:"
msgstr "Sybase と MS SQL サーバーに適用されるルールを下記に示します:"

#. Tag: para
#: query_sql.xml:618
#, no-c-format
msgid ""
"The procedure must return a result set. Note that since these servers can "
"return multiple result sets and update counts, Hibernate will iterate the "
"results and take the first result that is a result set as its return value. "
"Everything else will be discarded."
msgstr ""
"プロシージャはリザルトセットを返さなければなりません。サーバーは複数のリザル"
"トセットと更新カウントを返しますが、 Hibernate は1つ目のリザルトセットだけを"
"返すことに注意してください。その他はすべて捨てられます。"

#. Tag: para
#: query_sql.xml:626
#, no-c-format
msgid ""
"If you can enable <literal>SET NOCOUNT ON</literal> in your procedure it "
"will probably be more efficient, but this is not a requirement."
msgstr ""
"プロシージャの中で <literal>SET NOCOUNT ON</literal> を有効にできれば、おそら"
"く効率がよくなるでしょう。しかし、これは必要条件ではありません。"

#. Tag: title
#: query_sql.xml:636
#, no-c-format
msgid "Custom SQL for create, update and delete"
msgstr "作成、更新、削除のためのカスタム SQL"

#. Tag: para
#: query_sql.xml:638
#, no-c-format
msgid ""
"Hibernate3 can use custom SQL for create, update, and delete operations. The "
"SQL can be overridden at the statement level or inidividual column level. "
"This section describes statement overrides. For columns, see <xref linkend="
"\"mapping-column-read-and-write\"/>. <xref linkend=\"example-custom-crdu-via-"
"annotations\"/> shows how to define custom SQL operatons using annotations."
msgstr ""

#. Tag: title
#: query_sql.xml:646
#, no-c-format
msgid "Custom CRUD via annotations"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:648
#, no-c-format
msgid ""
"@Entity\n"
"@Table(name=\"CHAOS\")\n"
"@SQLInsert( sql=\"INSERT INTO CHAOS(size, name, nickname, id) VALUES(?,upper"
"(?),?,?)\")\n"
"@SQLUpdate( sql=\"UPDATE CHAOS SET size = ?, name = upper(?), nickname = ? "
"WHERE id = ?\")\n"
"@SQLDelete( sql=\"DELETE CHAOS WHERE id = ?\")\n"
"@SQLDeleteAll( sql=\"DELETE CHAOS\")\n"
"@Loader(namedQuery = \"chaos\")\n"
"@NamedNativeQuery(name=\"chaos\", query=\"select id, size, name, lower"
"( nickname ) as nickname from CHAOS where id= ?\", resultClass = Chaos."
"class)\n"
"public class Chaos {\n"
"    @Id\n"
"    private Long id;\n"
"    private Long size;\n"
"    private String name;\n"
"    private String nickname;"
msgstr ""

#. Tag: para
#: query_sql.xml:651
#, no-c-format
msgid ""
"<literal>@SQLInsert</literal>, <literal>@SQLUpdate</literal>, "
"<literal>@SQLDelete</literal>, <literal>@SQLDeleteAll</literal> respectively "
"override the INSERT, UPDATE, DELETE, and DELETE all statement. The same can "
"be achieved using Hibernate mapping files and the <literal>&lt;sql-insert&gt;"
"</literal>, <literal>&lt;sql-update&gt;</literal> and <literal>&lt;sql-"
"delete&gt;</literal> nodes. This can be seen in <xref linkend=\"example-"
"custom-crdu-via-xml\"/>."
msgstr ""

#. Tag: title
#: query_sql.xml:661
#, no-c-format
msgid "Custom CRUD XML"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:663
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;id name=\"id\"&gt;\n"
"        &lt;generator class=\"increment\"/&gt;\n"
"    &lt;/id&gt;\n"
"    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
"    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )"
"&lt;/sql-insert&gt;\n"
"    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-"
"update&gt;\n"
"    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;id name=\"id\"&gt;\n"
"        &lt;generator class=\"increment\"/&gt;\n"
"    &lt;/id&gt;\n"
"    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
"    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )"
"&lt;/sql-insert&gt;\n"
"    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-"
"update&gt;\n"
"    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: query_sql.xml:666
#, no-c-format
msgid ""
"If you expect to call a store procedure, be sure to set the "
"<literal>callable</literal> attribute to <constant>true</constant>. In "
"annotations as well as in xml."
msgstr ""

#. Tag: para
#: query_sql.xml:670
#, no-c-format
msgid ""
"To check that the execution happens correctly, Hibernate allows you to "
"define one of those three strategies:"
msgstr ""

#. Tag: para
#: query_sql.xml:675
#, no-c-format
msgid ""
"none: no check is performed: the store procedure is expected to fail upon "
"issues"
msgstr ""

#. Tag: para
#: query_sql.xml:680
#, no-c-format
msgid "count: use of rowcount to check that the update is successful"
msgstr ""

#. Tag: para
#: query_sql.xml:685
#, no-c-format
msgid ""
"param: like COUNT but using an output parameter rather that the standard "
"mechanism"
msgstr ""

#. Tag: para
#: query_sql.xml:690
#, no-c-format
msgid ""
"To define the result check style, use the <literal>check</literal> parameter "
"which is again available in annoations as well as in xml."
msgstr ""

#. Tag: para
#: query_sql.xml:693
#, no-c-format
msgid ""
"You can use the exact same set of annotations respectively xml nodes to "
"override the collection related statements -see <xref linkend=\"example-"
"overriding-sql-collections-annotations\"/>."
msgstr ""

#. Tag: title
#: query_sql.xml:698
#, no-c-format
msgid "Overriding SQL statements for collections using annotations"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:701
#, no-c-format
msgid ""
"@OneToMany\n"
"@JoinColumn(name=\"chaos_fk\")\n"
"@SQLInsert( sql=\"UPDATE CASIMIR_PARTICULE SET chaos_fk = ? where id = ?\")\n"
"@SQLDelete( sql=\"UPDATE CASIMIR_PARTICULE SET chaos_fk = null where id = ?"
"\")\n"
"private Set&lt;CasimirParticle&gt; particles = new HashSet&lt;"
"CasimirParticle&gt;();"
msgstr ""

#. Tag: para
#: query_sql.xml:705
#, fuzzy, no-c-format
msgid ""
"The parameter order is important and is defined by the order Hibernate "
"handles properties. You can see the expected order by enabling debug logging "
"for the <literal>org.hibernate.persister.entity</literal> level. With this "
"level enabled Hibernate will print out the static SQL that is used to "
"create, update, delete etc. entities. (To see the expected sequence, "
"remember to not include your custom SQL through annotations or mapping files "
"as that will override the Hibernate generated static sql)"
msgstr ""
"<literal>org.hiberante.persister.entity</literal> レベルのデバッグログを有効"
"にすることによって、期待される順番を確かめられます。このレベルを有効にするこ"
"とにより、エンティティの作成、更新、削除などで使用される静的な SQL が出力され"
"ます。（期待される順序を確認するためには、 Hibernate が生成する静的な SQL を"
"オーバーライドするカスタム SQL をマッピングファイルに含めないことを忘れないで"
"ください。）"

#. Tag: para
#: query_sql.xml:715
#, no-c-format
msgid ""
"Overriding SQL statements for secondary tables is also possible using "
"<literal>@org.hibernate.annotations.Table</literal> and either (or all) "
"attributes <literal>sqlInsert</literal>, <literal>sqlUpdate</literal>, "
"<literal>sqlDelete</literal>:"
msgstr ""

#. Tag: title
#: query_sql.xml:721
#, no-c-format
msgid "Overriding SQL statements for secondary tables"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:723
#, no-c-format
msgid ""
"@Entity\n"
"@SecondaryTables({\n"
"    @SecondaryTable(name = \"`Cat nbr1`\"),\n"
"    @SecondaryTable(name = \"Cat2\"})\n"
"@org.hibernate.annotations.Tables( {\n"
"    @Table(appliesTo = \"Cat\", comment = \"My cat table\" ),\n"
"    @Table(appliesTo = \"Cat2\", foreignKey = @ForeignKey(name=\"FK_CAT2_CAT"
"\"), fetch = FetchMode.SELECT,\n"
"        sqlInsert=@SQLInsert(sql=\"insert into Cat2(storyPart2, id) values"
"(upper(?), ?)\") )\n"
"} )\n"
"public class Cat implements Serializable {"
msgstr ""

#. Tag: para
#: query_sql.xml:726
#, no-c-format
msgid ""
"The previous example also shows that you can give a comment to a given table "
"(primary or secondary): This comment will be used for DDL generation."
msgstr ""

#. Tag: para
#: query_sql.xml:731
#, fuzzy, no-c-format
msgid ""
"The SQL is directly executed in your database, so you can use any dialect "
"you like. This will, however, reduce the portability of your mapping if you "
"use database specific SQL."
msgstr ""
"SQL を直接データベースで実行するため、好みの方言を自由に使用できます。データ"
"ベース独自の SQL を使えば、当然マッピングのポータビリティが下がります。"

#. Tag: para
#: query_sql.xml:736
#, fuzzy, no-c-format
msgid ""
"Last but not least, stored procedures are in most cases required to return "
"the number of rows inserted, updated and deleted. Hibernate always registers "
"the first statement parameter as a numeric output parameter for the CUD "
"operations:"
msgstr ""
"ストアドプロシージャは挿入/更新/削除された行数を返す必要があります（読み込み"
"の場合は、返さないよりは返す方がよいです）。実行時に Hibernate が SQL 文の成"
"功をチェックするからです。 Hibernate は、 CUD 処理のための数値の出力パラメー"
"タとして、 SQL 文の最初のパラメータをいつも記録します:"

#. Tag: title
#: query_sql.xml:742
#, no-c-format
msgid "Stored procedures and their return value"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:744
#, fuzzy, no-c-format
msgid ""
"CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)\n"
"    RETURN NUMBER IS\n"
"BEGIN\n"
"\n"
"    update PERSON\n"
"    set\n"
"        NAME = uname,\n"
"    where\n"
"        ID = uid;\n"
"\n"
"    return SQL%ROWCOUNT;\n"
"\n"
"END updatePerson;"
msgstr ""
"CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)\n"
"    RETURN NUMBER IS\n"
"BEGIN\n"
"\n"
"    update PERSON\n"
"    set\n"
"        NAME = uname,\n"
"    where\n"
"        ID = uid;\n"
"\n"
"    return SQL&#37;ROWCOUNT;\n"
"\n"
"END updatePerson;"

#. Tag: title
#: query_sql.xml:749
#, no-c-format
msgid "Custom SQL for loading"
msgstr "ロードのためのカスタム SQL"

#. Tag: para
#: query_sql.xml:751
#, no-c-format
msgid ""
"You can also declare your own SQL (or HQL) queries for entity loading. As "
"with inserts, updates, and deletes, this can be done at the individual "
"column level as described in <xref linkend=\"mapping-column-read-and-write\"/"
"> or at the statement level. Here is an example of a statement level "
"override:"
msgstr ""

#. Tag: programlisting
#: query_sql.xml:757
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"person\"&gt;\n"
"    &lt;return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/&gt;\n"
"    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
"    FROM PERSON\n"
"    WHERE ID=?\n"
"    FOR UPDATE\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"person\"&gt;\n"
"    &lt;return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/&gt;\n"
"    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
"    FROM PERSON\n"
"    WHERE ID=?\n"
"    FOR UPDATE\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:759
#, no-c-format
msgid ""
"This is just a named query declaration, as discussed earlier. You can "
"reference this named query in a class mapping:"
msgstr ""
"これは、まさに（以前議論した）名前付きクエリの宣言です。この名前付きクエリを"
"クラスのマッピングから参照できます:"

#. Tag: programlisting
#: query_sql.xml:762
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;id name=\"id\"&gt;\n"
"        &lt;generator class=\"increment\"/&gt;\n"
"    &lt;/id&gt;\n"
"    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
"    &lt;loader query-ref=\"person\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;id name=\"id\"&gt;\n"
"        &lt;generator class=\"increment\"/&gt;\n"
"    &lt;/id&gt;\n"
"    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
"    &lt;loader query-ref=\"person\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: query_sql.xml:764
#, no-c-format
msgid "This even works with stored procedures."
msgstr "これはストアドプロシージャでさえも動作します。"

#. Tag: para
#: query_sql.xml:766
#, no-c-format
msgid "You can even define a query for collection loading:"
msgstr "次のように、コレクションをロードするためのクエリさえ定義してよいです:"

#. Tag: programlisting
#: query_sql.xml:768
#, fuzzy, no-c-format
msgid ""
"&lt;set name=\"employments\" inverse=\"true\"&gt;\n"
"    &lt;key/&gt;\n"
"    &lt;one-to-many class=\"Employment\"/&gt;\n"
"    &lt;loader query-ref=\"employments\"/&gt;\n"
"&lt;/set&gt;"
msgstr ""
"&lt;set name=\"employments\" inverse=\"true\"&gt;\n"
"    &lt;key/&gt;\n"
"    &lt;one-to-many class=\"Employment\"/&gt;\n"
"    &lt;loader query-ref=\"employments\"/&gt;\n"
"&lt;/set&gt;"

#. Tag: programlisting
#: query_sql.xml:770
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"employments\"&gt;\n"
"    &lt;load-collection alias=\"emp\" role=\"Person.employments\"/&gt;\n"
"    SELECT {emp.*}\n"
"    FROM EMPLOYMENT emp\n"
"    WHERE EMPLOYER = :id\n"
"    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"employments\"&gt;\n"
"    &lt;load-collection alias=\"emp\" role=\"Person.employments\"/&gt;\n"
"    SELECT {emp.*}\n"
"    FROM EMPLOYMENT emp\n"
"    WHERE EMPLOYER = :id\n"
"    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:772
#, no-c-format
msgid ""
"You can also define an entity loader that loads a collection by join "
"fetching:"
msgstr ""
"次のように、結合フェッチによりコレクションをロードするエンティティローダーを"
"定義できます:"

#. Tag: programlisting
#: query_sql.xml:775
#, fuzzy, no-c-format
msgid ""
"&lt;sql-query name=\"person\"&gt;\n"
"    &lt;return alias=\"pers\" class=\"Person\"/&gt;\n"
"    &lt;return-join alias=\"emp\" property=\"pers.employments\"/&gt;\n"
"    SELECT NAME AS {pers.*}, {emp.*}\n"
"    FROM PERSON pers\n"
"    LEFT OUTER JOIN EMPLOYMENT emp\n"
"        ON pers.ID = emp.PERSON_ID\n"
"    WHERE ID=?\n"
"&lt;/sql-query&gt;"
msgstr ""
"&lt;sql-query name=\"person\"&gt;\n"
"    &lt;return alias=\"pers\" class=\"Person\"/&gt;\n"
"    &lt;return-join alias=\"emp\" property=\"pers.employments\"/&gt;\n"
"    SELECT NAME AS {pers.*}, {emp.*}\n"
"    FROM PERSON pers\n"
"    LEFT OUTER JOIN EMPLOYMENT emp\n"
"        ON pers.ID = emp.PERSON_ID\n"
"    WHERE ID=?\n"
"&lt;/sql-query&gt;"

#. Tag: para
#: query_sql.xml:777
#, no-c-format
msgid ""
"The annotation equivalent <literal>&lt;loader&gt;</literal> is the @Loader "
"annotation as seen in <xref linkend=\"example-custom-crdu-via-annotations\"/"
">."
msgstr ""

#, fuzzy
#~ msgid "<literal>A_NAME as {item.name}</literal>"
#~ msgstr "<literal>{item.*}</literal>"

#, fuzzy
#~ msgid "<literal>{[aliasname].class}</literal>"
#~ msgstr "<literal>{item.*}</literal>"

#, fuzzy
#~ msgid "<literal>DISC as {item.class}</literal>"
#~ msgstr "<literal>{item.*}</literal>"

#, fuzzy
#~ msgid "<literal>{[aliasname].*}</literal>"
#~ msgstr "<literal>{item.*}</literal>"

#~ msgid "<literal>{item.*}</literal>"
#~ msgstr "<literal>{item.*}</literal>"

#, fuzzy
#~ msgid "<literal>{[aliasname].key}</literal>"
#~ msgstr "<literal>{item.*}</literal>"

#, fuzzy
#~ msgid "<literal>ORGID as {coll.key}</literal>"
#~ msgstr "<literal>{coll.*}</literal>"

#, fuzzy
#~ msgid "<literal>{[aliasname].id}</literal>"
#~ msgstr "<literal>{item.*}</literal>"

#, fuzzy
#~ msgid "<literal>EMPID as {coll.id}</literal>"
#~ msgstr "<literal>{coll.*}</literal>"

#, fuzzy
#~ msgid "<literal>{[aliasname].element}</literal>"
#~ msgstr "<literal>{coll.element.*}</literal>"

#, fuzzy
#~ msgid "<literal>XID as {coll.element}</literal>"
#~ msgstr "<literal>{coll.element.*}</literal>"

#, fuzzy
#~ msgid "<literal>NAME as {coll.element.name}</literal>"
#~ msgstr "<literal>{coll.element.*}</literal>"

#, fuzzy
#~ msgid "<literal>{[aliasname].element.*}</literal>"
#~ msgstr "<literal>{coll.element.*}</literal>"

#~ msgid "<literal>{coll.element.*}</literal>"
#~ msgstr "<literal>{coll.element.*}</literal>"

#~ msgid "<literal>{coll.*}</literal>"
#~ msgstr "<literal>{coll.*}</literal>"

#, fuzzy
#~ msgid ""
#~ "The class and collection persisters in Hibernate already contain a set of "
#~ "configuration time generated strings (insertsql, deletesql, updatesql "
#~ "etc.). The mapping tags <literal>&lt;sql-insert&gt;</literal>, "
#~ "<literal>&lt;sql-delete&gt;</literal>, and <literal>&lt;sql-update&gt;</"
#~ "literal> override these strings:"
#~ msgstr ""
#~ "Hibernate3 は作成、更新、削除処理のためのカスタム SQL 文を使用できます。ク"
#~ "ラスとコレクションの永続化機構は、コンフィグレーション時に生成された文字"
#~ "列 （insertsql、deletesql、updatesql など）のセットをすでに保持していま"
#~ "す。これらの文字列より、 <literal>&lt;sql-insert&gt;</literal>、 "
#~ "<literal>&lt;sql-delete&gt;</literal>、 <literal>&lt;sql-update&gt;</"
#~ "literal> というマッピングタグが優先されます:"

#~ msgid ""
#~ "Stored procedures are supported if the <literal>callable</literal> "
#~ "attribute is set:"
#~ msgstr ""
#~ "<literal>callable</literal> 属性をセットすれば、ストアドプロシージャを使用"
#~ "できます:"

#~ msgid ""
#~ "The order of the positional parameters is vital, as they must be in the "
#~ "same sequence as Hibernate expects them."
#~ msgstr ""
#~ "今のところ、位置パラメータの順番はとても重要です。すなわち、 Hibernate が"
#~ "期待する順序でなければなりません。"

#~ msgid ""
#~ "You can also declare your own SQL (or HQL) queries for entity loading:"
#~ msgstr ""
#~ "エンティティを読み込むための独自の SQL （もしくは HQL）クエリも宣言できま"
#~ "す:"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"id\">\n"
#~ "        <generator class=\"increment\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\"/>\n"
#~ "    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-"
#~ "insert>\n"
#~ "    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-"
#~ "delete>\n"
#~ "    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-"
#~ "update>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"increment\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
#~ "    &lt;sql-insert callable=\"true\"&gt;{call createPerson (?, ?)}&lt;/"
#~ "sql-insert&gt;\n"
#~ "    &lt;sql-delete callable=\"true\"&gt;{? = call deletePerson (?)}&lt;/"
#~ "sql-delete&gt;\n"
#~ "    &lt;sql-update callable=\"true\"&gt;{? = call updatePerson (?, ?)}"
#~ "&lt;/sql-update&gt;\n"
#~ "&lt;/class&gt;"
