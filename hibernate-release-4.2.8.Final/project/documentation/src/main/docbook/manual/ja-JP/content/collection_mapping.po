# translation of Collection_Mapping.po to
# Xi HUANG <xhuang@redhat.com>, 2007, 2010.
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-20 21:02+0000\n"
"PO-Revision-Date: 2010-01-06 16:08+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: collection_mapping.xml:31
#, no-c-format
msgid "Collection mapping"
msgstr "コレクションのマッピング"

#. Tag: title
#: collection_mapping.xml:34
#, no-c-format
msgid "Persistent collections"
msgstr "コレクションの永続化"

#. Tag: para
#: collection_mapping.xml:36
#, fuzzy, no-c-format
msgid ""
"Naturally Hibernate also allows to persist collections. These persistent "
"collections can contain almost any other Hibernate type, including: basic "
"types, custom types, components and references to other entities. The "
"distinction between value and reference semantics is in this context very "
"important. An object in a collection might be handled with \"value\" "
"semantics (its life cycle fully depends on the collection owner), or it "
"might be a reference to another entity with its own life cycle. In the "
"latter case, only the \"link\" between the two objects is considered to be a "
"state held by the collection."
msgstr ""
"コレクションは他の Hibernate の型のほとんど（すべての基本型、カスタム型、コン"
"ポーネント、他のエンティティへの参照）を格納することができます。次の点は重要"
"な違いになります。コレクションに格納されたオブジェクトが「値」セマンティクス"
"として扱われるのか （ライフサイクルはコレクションのオーナーに完全に依存しま"
"す）、もしくはそれ自身のライフサイクルを持った別のエンティティへの参照である"
"かのかという違いです。後者は、2つのオブジェクト間の「リンク」をコレクションに"
"保持していると見なしているだけです。"

#. Tag: para
#: collection_mapping.xml:46
#, fuzzy, no-c-format
msgid ""
"As a requirement persistent collection-valued fields must be declared as an "
"interface type (see <xref linkend=\"example.collection.mapping.annotations\"/"
">). The actual interface might be <literal>java.util.Set</literal>, "
"<literal>java.util.Collection</literal>, <literal>java.util.List</literal>, "
"<literal>java.util.Map</literal>, <literal>java.util.SortedSet</literal>, "
"<literal>java.util.SortedMap</literal> or anything you like (\"anything you "
"like\" means you will have to write an implementation of <literal>org."
"hibernate.usertype.UserCollectionType</literal>)."
msgstr ""
"実在するインターフェースには <literal>java.util.Set</literal>、 "
"<literal>java.util.Collection</literal>、 <literal>java.util.List</"
"literal>、 <literal>java.util.Map</literal>、 <literal>java.util.SortedSet</"
"literal>、 <literal>java.util.SortedMap</literal> などがあります。または、任"
"意のインターフェースが使えます。 （ただし、「任意のインターフェース」を使用す"
"る場合は、 <literal>org.hibernate.usertype.UserCollectionType</literal> の実"
"装クラスを作成する必要があります。）"

#. Tag: para
#: collection_mapping.xml:57
#, fuzzy, no-c-format
msgid ""
"Notice how in <xref linkend=\"example.collection.mapping.annotations\"/> the "
"instance variable <literal>parts</literal> was initialized with an instance "
"of <literal>HashSet</literal>. This is the best way to initialize collection "
"valued properties of newly instantiated (non-persistent) instances. When you "
"make the instance persistent, by calling <literal>persist()</literal>, "
"Hibernate will actually replace the <literal>HashSet</literal> with an "
"instance of Hibernate's own implementation of <literal>Set</literal>. Be "
"aware of the following error:"
msgstr ""
"<literal>HashSet</literal> のインスタンスを持つインスタンス変数がどのように初"
"期化されるかに注目してみましょう。これは新たに生成された（永続化されていな"
"い）コレクション型のプロパティを初期化する最適な方法です。 （例えば "
"<literal>persist()</literal> により）インスタンスを永続化しようとしたとき、 "
"Hibernate は <literal>HashSet</literal> を Hibernate 独自の <literal>Set</"
"literal> の実装クラスに置き換えます。このため、次のようなエラーには注意が必要"
"です。"

#. Tag: title
#: collection_mapping.xml:68
#, no-c-format
msgid "Hibernate uses its own collection implementations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:70
#, fuzzy, no-c-format
msgid ""
"Cat cat = new DomesticCat();\n"
"Cat kitten = new DomesticCat();\n"
"....\n"
"Set kittens = new HashSet();\n"
"kittens.add(kitten);\n"
"cat.setKittens(kittens);\n"
"session.persist(cat);\n"
"\n"
"kittens = cat.getKittens(); // Okay, kittens collection is a Set\n"
"(HashSet) cat.getKittens(); // Error!"
msgstr ""
"Cat cat = new DomesticCat();\n"
"Cat kitten = new DomesticCat();\n"
"....\n"
"Set kittens = new HashSet();\n"
"kittens.add(kitten);\n"
"cat.setKittens(kittens);\n"
"session.persist(cat);\n"
"kittens = cat.getKittens(); // Okay, kittens collection is a Set\n"
"(HashSet) cat.getKittens(); // Error!"

#. Tag: para
#: collection_mapping.xml:73
#, no-c-format
msgid ""
"The persistent collections injected by Hibernate behave like "
"<literal>HashMap</literal>, <literal>HashSet</literal>, <literal>TreeMap</"
"literal>, <literal>TreeSet</literal> or <literal>ArrayList</literal>, "
"depending on the interface type."
msgstr ""
"Hibernate により注入された永続性コレクションは、インターフェース型に応じて、 "
"<literal>HashMap</literal> や <literal>HashSet</literal>、 <literal>TreeMap</"
"literal>、 <literal>TreeSet</literal>、 <literal>ArrayList</literal> のように"
"振舞います。"

#. Tag: para
#: collection_mapping.xml:78
#, no-c-format
msgid ""
"Collections instances have the usual behavior of value types. They are "
"automatically persisted when referenced by a persistent object and are "
"automatically deleted when unreferenced. If a collection is passed from one "
"persistent object to another, its elements might be moved from one table to "
"another. Two entities cannot share a reference to the same collection "
"instance. Due to the underlying relational model, collection-valued "
"properties do not support null value semantics. Hibernate does not "
"distinguish between a null collection reference and an empty collection."
msgstr ""
"コレクションインスタンスは、値型として普通に振舞います。永続化オブジェクトに"
"参照されたときに自動的に永続化され、参照がなくなったときに自動的に削除されま"
"す。もしある永続化オブジェクトから別の永続化オブジェクトに渡されたら、その要"
"素は現在のテーブルから別のテーブルに移動するかもしれません。２つのエンティ"
"ティが同じコレクションインスタンスを共有してはいけません。リレーショナルモデ"
"ルをベースにしているため、コレクション型のプロパティに null 値を代入しても意"
"味がありません。つまり Hibernate は参照先のないコレクションと空のコレクション"
"を区別しません。"

#. Tag: para
#: collection_mapping.xml:89
#, fuzzy, no-c-format
msgid ""
"Use persistent collections the same way you use ordinary Java collections. "
"However, ensure you understand the semantics of bidirectional associations "
"(see <xref linkend=\"collections-bidirectional\"/>)."
msgstr ""
"しかしそれほど心配しなくても構いません。普段使っている Java のコレクションと"
"同じように、永続化コレクションを使ってください。双方向関連の意味を理解すれば"
"よいのです（これは後ほど説明します）。"

#. Tag: title
#: collection_mapping.xml:97
#, fuzzy, no-c-format
msgid "How to map collections"
msgstr "ソートされたコレクション"

#. Tag: para
#: collection_mapping.xml:99
#, no-c-format
msgid ""
"Using annotations you can map <classname>Collection</classname>s, "
"<classname>List</classname>s, <classname>Map</classname>s and "
"<classname>Set</classname>s of associated entities using @OneToMany and "
"@ManyToMany. For collections of a basic or embeddable type use "
"@ElementCollection. In the simplest case a collection mapping looks like "
"this:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:107
#, no-c-format
msgid "Collection mapping using @OneToMany and @JoinColumn"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:109
#, fuzzy, no-c-format
msgid ""
"@Entity\n"
"public class Product {\n"
"\n"
"    private String serialNumber;\n"
"    private Set&lt;Part&gt; parts = new HashSet&lt;Part&gt;();\n"
"\n"
"    @Id\n"
"    public String getSerialNumber() { return serialNumber; }\n"
"    void setSerialNumber(String sn) { serialNumber = sn; }\n"
"   \n"
"    @OneToMany\n"
"    @JoinColumn(name=\"PART_ID\")\n"
"    public Set&lt;Part&gt; getParts() { return parts; }\n"
"    void setParts(Set parts) { this.parts = parts; }\n"
"}\n"
"\n"
"\n"
"@Entity\n"
"public class Part {\n"
"   ...\n"
"}"
msgstr ""
"public class Product {\n"
"    private String serialNumber;\n"
"    private Set parts = new HashSet();\n"
"    \n"
"    public Set getParts() { return parts; }\n"
"    void setParts(Set parts) { this.parts = parts; }\n"
"    public String getSerialNumber() { return serialNumber; }\n"
"    void setSerialNumber(String sn) { serialNumber = sn; }\n"
"}"

#. Tag: para
#: collection_mapping.xml:112
#, no-c-format
msgid ""
"Product describes a unidirectional relationship with Part using the join "
"column PART_ID. In this unidirectional one to many scenario you can also use "
"a join table as seen in <xref linkend=\"example-one-to-many-with-join-table"
"\"/>."
msgstr ""

#. Tag: title
#: collection_mapping.xml:118
#, no-c-format
msgid "Collection mapping using @OneToMany and @JoinTable"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:121
#, no-c-format
msgid ""
"@Entity\n"
"public class Product {\n"
"\n"
"    private String serialNumber;\n"
"    private Set&lt;Part&gt; parts = new HashSet&lt;Part&gt;();\n"
"\n"
"    @Id\n"
"    public String getSerialNumber() { return serialNumber; }\n"
"    void setSerialNumber(String sn) { serialNumber = sn; }\n"
"   \n"
"    @OneToMany\n"
"    @JoinTable(\n"
"            name=\"PRODUCT_PARTS\",\n"
"            joinColumns = @JoinColumn( name=\"PRODUCT_ID\"),\n"
"            inverseJoinColumns = @JoinColumn( name=\"PART_ID\")\n"
"    )\n"
"    public Set&lt;Part&gt; getParts() { return parts; }\n"
"    void setParts(Set parts) { this.parts = parts; }\n"
"}\n"
"\n"
"\n"
"@Entity\n"
"public class Part {\n"
"   ...\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:124
#, no-c-format
msgid ""
"Without describing any physical mapping (no <classname>@JoinColumn</"
"classname> or <classname>@JoinTable</classname>), a unidirectional one to "
"many with join table is used. The table name is the concatenation of the "
"owner table name, _, and the other side table name. The foreign key name(s) "
"referencing the owner table is the concatenation of the owner table, _, and "
"the owner primary key column(s) name. The foreign key name(s) referencing "
"the other side is the concatenation of the owner property name, _, and the "
"other side primary key column(s) name. A unique constraint is added to the "
"foreign key referencing the other side table to reflect the one to many."
msgstr ""

#. Tag: para
#: collection_mapping.xml:135
#, fuzzy, no-c-format
msgid ""
"Lets have a look now how collections are mapped using Hibernate mapping "
"files. In this case the first step is to chose the right mapping element. It "
"depends on the type of interface. For example, a <literal>&lt;set&gt;</"
"literal> element is used for mapping properties of type <literal>Set</"
"literal>."
msgstr ""
"コレクションをマッピングするためのマッピング要素は、インターフェースの型に依"
"存します。例えば、 <literal>&lt;set&gt;</literal> 要素は <literal>Set</"
"literal> 型のプロパティをマッピングするために使います。"

#. Tag: title
#: collection_mapping.xml:142
#, no-c-format
msgid "Mapping a Set using &lt;set&gt;"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:144
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Product\"&gt;\n"
"    &lt;id name=\"serialNumber\" column=\"productSerialNumber\"/&gt;\n"
"    &lt;set name=\"parts\"&gt;\n"
"        &lt;key column=\"productSerialNumber\" not-null=\"true\"/&gt;\n"
"        &lt;one-to-many class=\"Part\"/&gt;\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Product\"&gt;\n"
"    &lt;id name=\"serialNumber\" column=\"productSerialNumber\"/&gt;\n"
"    &lt;set name=\"parts\"&gt;\n"
"        &lt;key column=\"productSerialNumber\" not-null=\"true\"/&gt;\n"
"        &lt;one-to-many class=\"Part\"/&gt;\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: collection_mapping.xml:147
#, fuzzy, no-c-format
msgid ""
"In <xref linkend=\"example.collections.set\"/> a <emphasis>one-to-many "
"association</emphasis> links the <literal>Product</literal> and "
"<literal>Part</literal> entities. This association requires the existence of "
"a foreign key column and possibly an index column to the <literal>Part</"
"literal> table. This mapping loses certain semantics of normal Java "
"collections:"
msgstr ""
"<literal>Product</literal> から <literal>Part</literal> への関連は、 "
"<literal>Part</literal> テーブルへの外部キーカラムと、場合によってはインデッ"
"クスカラムが必要です。 <literal>&lt;one-to-many&gt;</literal> タグは、これが"
"一対多関連であることを表しています。"

#. Tag: para
#: collection_mapping.xml:156
#, no-c-format
msgid ""
"An instance of the contained entity class cannot belong to more than one "
"instance of the collection."
msgstr ""
"エンティティクラスのインスタンスは、2つ以上のコレクションのインスタンスに属し"
"てはいけません。"

#. Tag: para
#: collection_mapping.xml:161
#, no-c-format
msgid ""
"An instance of the contained entity class cannot appear at more than one "
"value of the collection index."
msgstr ""
"コレクションに含まれるエンティティクラスのインスタンスは、コレクションイン"
"デックスの値として2度以上現れてはいけません。"

#. Tag: para
#: collection_mapping.xml:166
#, no-c-format
msgid ""
"Looking closer at the used <literal>&lt;one-to-many&gt;</literal> tag we see "
"that it has the following options."
msgstr ""

#. Tag: title
#: collection_mapping.xml:170
#, no-c-format
msgid "options of &lt;one-to-many&gt; element"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:181
#, fuzzy, no-c-format
msgid ""
"&lt;one-to-many\n"
"        class=\"ClassName\"\n"
"        not-found=\"ignore|exception\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"\n"
"        embed-xml=\"true|false\"\n"
"    /&gt;"
msgstr ""
"&lt;one-to-many \n"
"        class=\"ClassName\"\n"
"        not-found=\"ignore|exception\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"\n"
"        embed-xml=\"true|false\"\n"
"    /&gt;"

#. Tag: para
#: collection_mapping.xml:185
#, no-c-format
msgid "<literal>class</literal> (required): the name of the associated class."
msgstr "<literal>class</literal> （必須）: 関連クラスの名前。"

#. Tag: para
#: collection_mapping.xml:190
#, no-c-format
msgid ""
"<literal>not-found</literal> (optional - defaults to <literal>exception</"
"literal>): specifies how cached identifiers that reference missing rows will "
"be handled. <literal>ignore</literal> will treat a missing row as a null "
"association."
msgstr ""
"<literal>not-found</literal> （オプション - デフォルトは <literal>exception</"
"literal>）: 参照先の行がないキャッシュされた識別子をどのように扱うかを指定し"
"ます: <literal>ignore</literal> を指定すると、行がないことを関連がないものと"
"して扱います。"

#. Tag: para
#: collection_mapping.xml:198
#, no-c-format
msgid ""
"<literal>entity-name</literal> (optional): the entity name of the associated "
"class, as an alternative to <literal>class</literal>."
msgstr ""
"<literal>entity-name</literal> （オプション）: <literal>class</literal> の代"
"替である関連クラスのエンティティ名。 <literal>class</literal> の代わりに指定"
"する、関連クラスのエンティティ名。"

#. Tag: para
#: collection_mapping.xml:206
#, no-c-format
msgid ""
"The <literal>&lt;one-to-many&gt;</literal> element does not need to declare "
"any columns. Nor is it necessary to specify the <literal>table</literal> "
"name anywhere."
msgstr ""
"<literal>&lt;one-to-many&gt;</literal> 要素はカラムを宣言する必要がないことに"
"注意してください。同様に <literal>テーブル</literal> 名を指定する必要もありま"
"せん。"

#. Tag: para
#: collection_mapping.xml:211
#, fuzzy, no-c-format
msgid ""
"If the foreign key column of a <literal>&lt;one-to-many&gt;</literal> "
"association is declared <literal>NOT NULL</literal>, you must declare the "
"<literal>&lt;key&gt;</literal> mapping <literal>not-null=\"true\"</literal> "
"or <emphasis>use a bidirectional association</emphasis> with the collection "
"mapping marked <literal>inverse=\"true\"</literal>. See <xref linkend="
"\"collections-bidirectional\"/>."
msgstr ""
"<emphasis>とても重要な注意:</emphasis> もし <literal>&lt;one-to-many&gt;</"
"literal> 関連の外部キーカラムが <literal>NOT NULL</literal>と宣言された場"
"合、 <literal>&lt;key&gt;</literal> マッピングに <literal>not-null=\"true\"</"
"literal> を宣言するか、コレクションマッピングに <literal>inverse=\"true\"</"
"literal> を付けた上で、 <emphasis>双方向関連を使う</emphasis> 必要がありま"
"す。双方向関連についてはこの章の後のほうで説明します。"

#. Tag: para
#: collection_mapping.xml:221
#, fuzzy, no-c-format
msgid ""
"Apart from the <literal>&lt;set&gt; </literal>tag as shown in <xref linkend="
"\"example.collections.set\"/>, there is also <literal>&lt;list&gt;</"
"literal>, <literal>&lt;map&gt;</literal>, <literal>&lt;bag&gt;</literal>, "
"<literal>&lt;array&gt;</literal> and <literal>&lt;primitive-array&gt;</"
"literal> mapping elements. The <literal>&lt;map&gt;</literal> element is "
"representative:"
msgstr ""
"マッピング要素には <literal>&lt;set&gt;</literal> の他に <literal>&lt;"
"list&gt;</literal>、 <literal>&lt;map&gt;</literal>、 <literal>&lt;bag&gt;</"
"literal>、 <literal>&lt;array&gt;</literal>、 <literal>&lt;primitive-"
"array&gt;</literal> があります。代表として、 <literal>&lt;map&gt;</literal> "
"要素を下記に示します。"

#. Tag: title
#: collection_mapping.xml:229
#, no-c-format
msgid "Elements of the &lt;map&gt; mapping"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:262
#, fuzzy, no-c-format
msgid ""
"&lt;map\n"
"    name=\"propertyName\"\n"
"    table=\"table_name\"\n"
"    schema=\"schema_name\"\n"
"    lazy=\"true|extra|false\"\n"
"    inverse=\"true|false\"\n"
"    cascade=\"all|none|save-update|delete|all-delete-orphan|delete-orphan\"\n"
"    sort=\"unsorted|natural|comparatorClass\"\n"
"    order-by=\"column_name asc|desc\"\n"
"    where=\"arbitrary sql where condition\"\n"
"    fetch=\"join|select|subselect\"\n"
"    batch-size=\"N\"\n"
"    access=\"field|property|ClassName\"\n"
"    optimistic-lock=\"true|false\"\n"
"    mutable=\"true|false\"\n"
"    node=\"element-name|.\"\n"
"    embed-xml=\"true|false\"\n"
"&gt;\n"
"\n"
"    &lt;key .... /&gt;\n"
"    &lt;map-key .... /&gt;\n"
"    &lt;element .... /&gt;\n"
"&lt;/map&gt;"
msgstr ""
"&lt;map\n"
"    name=\"propertyName\"\n"
"    table=\"table_name\"\n"
"    schema=\"schema_name\"\n"
"    lazy=\"true|extra|false\"\n"
"    inverse=\"true|false\"\n"
"    cascade=\"all|none|save-update|delete|all-delete-orphan|delete-orphan\"\n"
"    sort=\"unsorted|natural|comparatorClass\"\n"
"    order-by=\"column_name asc|desc\"\n"
"    where=\"arbitrary sql where condition\"\n"
"    fetch=\"join|select|subselect\"\n"
"    batch-size=\"N\"\n"
"    access=\"field|property|ClassName\"\n"
"    optimistic-lock=\"true|false\"\n"
"    mutable=\"true|false\"\n"
"    node=\"element-name|.\"\n"
"    embed-xml=\"true|false\"\n"
"&gt;\n"
"\n"
"    &lt;key .... /&gt;\n"
"    &lt;map-key .... /&gt;\n"
"    &lt;element .... /&gt;\n"
"&lt;/map&gt;"

#. Tag: para
#: collection_mapping.xml:266
#, no-c-format
msgid "<literal>name</literal>: the collection property name"
msgstr "<literal>name</literal> ：コレクション型であるプロパティの名前"

#. Tag: para
#: collection_mapping.xml:270
#, no-c-format
msgid ""
"<literal>table</literal> (optional - defaults to property name): the name of "
"the collection table. It is not used for one-to-many associations."
msgstr ""
"<literal>table</literal> （オプション - デフォルトはプロパティ名）：コレク"
"ションテーブルの名前（一対多関連では使用しません）。"

#. Tag: para
#: collection_mapping.xml:276
#, no-c-format
msgid ""
"<literal>schema</literal> (optional): the name of a table schema to override "
"the schema declared on the root element"
msgstr ""
"<literal>schema</literal> （オプション）：テーブルスキーマの名前。ルート要素"
"で宣言されているスキーマより優先されます。"

#. Tag: para
#: collection_mapping.xml:281
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>true</literal>): "
"disables lazy fetching and specifies that the association is always eagerly "
"fetched. It can also be used to enable \"extra-lazy\" fetching where most "
"operations do not initialize the collection. This is suitable for large "
"collections."
msgstr ""
"<literal>lazy</literal> （オプション - デフォルトは <literal>true</"
"literal>）： 遅延フェッチを無効にし、関連を常に即時にフェッチにするために使用"
"します。または、「extra-lazy」フェッチを有効にするために使用します。「extra-"
"lazy」フェッチは、ほとんどの操作ではコレクションを初期化しません （非常に大き"
"なコレクションに適しています）。"

#. Tag: para
#: collection_mapping.xml:290
#, no-c-format
msgid ""
"<literal>inverse</literal> (optional - defaults to <literal>false</"
"literal>): marks this collection as the \"inverse\" end of a bidirectional "
"association."
msgstr ""
"<literal>inverse</literal> （オプション - デフォルトは <literal>false</"
"literal>）：このコレクションが双方向関連の「逆」側であるとマークします。"

#. Tag: para
#: collection_mapping.xml:296
#, no-c-format
msgid ""
"<literal>cascade</literal> (optional - defaults to <literal>none</literal>): "
"enables operations to cascade to child entities."
msgstr ""
"<literal>cascade</literal> （オプション - デフォルトは <literal>none</"
"literal>）：子エンティティへのカスケード操作を有効にします。"

#. Tag: para
#: collection_mapping.xml:302
#, no-c-format
msgid ""
"<literal>sort</literal> (optional): specifies a sorted collection with "
"<literal>natural</literal> sort order or a given comparator class."
msgstr ""
"<literal>sort</literal> （オプション）：コレクションを自然な順序でソートする"
"場合は <literal>natural</literal> を指定します。あるいは Comparator クラスを"
"指定します。"

#. Tag: para
#: collection_mapping.xml:308
#, fuzzy, no-c-format
msgid ""
"<literal>order-by</literal> (optional): specifies a table column or columns "
"that define the iteration order of the <literal>Map</literal>, <literal>Set</"
"literal> or bag, together with an optional <literal>asc</literal> or "
"<literal>desc</literal>."
msgstr ""
"<literal>order-by</literal> （オプション、 JDK1.4 のみ） <literal>Map</"
"literal>、 <literal>Set</literal>、 bag のイテレーション順序を定義するテーブ"
"ルカラムを指定すると共に、オプションとして <literal>asc</literal>、 "
"<literal>desc</literal> を指定します。"

#. Tag: para
#: collection_mapping.xml:316
#, no-c-format
msgid ""
"<literal>where</literal> (optional): specifies an arbitrary SQL "
"<literal>WHERE</literal> condition that is used when retrieving or removing "
"the collection. This is useful if the collection needs to contain only a "
"subset of the available data."
msgstr ""
"<literal>where</literal> （オプション）：コレクションの検索や削除の際に使う任"
"意の SQL の<literal>WHERE</literal> 条件を指定します （利用可能なデータの一部"
"分だけをコレクションが含むべきときに、これは有用です）。"

#. Tag: para
#: collection_mapping.xml:324
#, no-c-format
msgid ""
"<literal>fetch</literal> (optional, defaults to <literal>select</literal>): "
"chooses between outer-join fetching, fetching by sequential select, and "
"fetching by sequential subselect."
msgstr ""
"<literal>fetch</literal> （オプション - デフォルトは <literal>select</"
"literal>）：外部結合によるフェッチ、順次選択フェッチ （sequential select "
"fetch） 、順次サブセレクトフェッチ （sequential subselect fetch） のどれかを"
"選択してください。"

#. Tag: para
#: collection_mapping.xml:331
#, no-c-format
msgid ""
"<literal>batch-size</literal> (optional, defaults to <literal>1</literal>): "
"specifies a \"batch size\" for lazily fetching instances of this collection."
msgstr ""
"<literal>batch-size</literal> （オプション - デフォルトは <literal>1</"
"literal>）：コレクションのインスタンスの遅延フェッチのための「バッチサイズ」"
"を指定します。"

#. Tag: para
#: collection_mapping.xml:337
#, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate uses for accessing the collection property "
"value."
msgstr ""
"<literal>access</literal> （オプション - デフォルトは <literal>property</"
"literal>）：コレクション型プロパティの値にアクセスするために使用する戦略で"
"す。"

#. Tag: para
#: collection_mapping.xml:343
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that changes to the state of the collection results in "
"increments of the owning entity's version. For one-to-many associations you "
"may want to disable this setting."
msgstr ""
"<literal>optimistic-lock</literal> （オプション - デフォルトは "
"<literal>true</literal>） コレクションの状態を変えることによって、そのオー"
"ナーであるエンティティのバージョンがインクリメントされるかを指定します。 （一"
"対多関連では、ほとんどの場合において無効に設定するのが妥当です。）"

#. Tag: para
#: collection_mapping.xml:351
#, no-c-format
msgid ""
"<literal>mutable</literal> (optional - defaults to <literal>true</literal>): "
"a value of <literal>false</literal> specifies that the elements of the "
"collection never change. This allows for minor performance optimization in "
"some cases."
msgstr ""
"<literal>mutable</literal>（オプション - デフォルトは <literal>true</"
"literal>） <literal>false</literal> 値は、コレクションの要素が変更されないこ"
"とを表します （ある場合には、少しパフォーマンスを高めます）。"

#. Tag: para
#: collection_mapping.xml:360
#, no-c-format
msgid ""
"After exploring the basic mapping of collections in the preceding paragraphs "
"we will now focus details like physical mapping considerations, indexed "
"collections and collections of value types."
msgstr ""

#. Tag: title
#: collection_mapping.xml:365
#, no-c-format
msgid "Collection foreign keys"
msgstr "コレクションの外部キー"

#. Tag: para
#: collection_mapping.xml:367
#, fuzzy, no-c-format
msgid ""
"On the database level collection instances are distinguished by the foreign "
"key of the entity that owns the collection. This foreign key is referred to "
"as the <emphasis>collection key column</emphasis>, or columns, of the "
"collection table. The collection key column is mapped by the "
"<literal>@JoinColumn</literal> annotation respectively the <literal>&lt;"
"key&gt;</literal> XML element."
msgstr ""
"コレクションのインスタンスは、データベース内では、そのコレクションを所有する"
"エンティティの外部キーによって識別されます。この外部キーはコレクションテーブ"
"ルの <emphasis>コレクションキーカラム</emphasis> (またはカラム) と呼ばれま"
"す。コレクションキーカラムは <literal>&lt;key&gt;</literal> 要素によりマッピ"
"ングします。"

#. Tag: para
#: collection_mapping.xml:374
#, fuzzy, no-c-format
msgid ""
"There can be a nullability constraint on the foreign key column. For most "
"collections, this is implied. For unidirectional one-to-many associations, "
"the foreign key column is nullable by default, so you may need to specify"
msgstr ""
"外部キーカラムには null 設定制約があるかもしれません。ほとんどのコレクション"
"に当てはまるでしょう。単方向の一対多関連において、外部キーカラムはデフォルト"
"で null を許す設定になっています。よって、 <literal>not-null=\"true\"</"
"literal> を指定する必要があるかもしれません。"

#. Tag: programlisting
#: collection_mapping.xml:379
#, no-c-format
msgid "@JoinColumn(nullable=false)"
msgstr ""

#. Tag: para
#: collection_mapping.xml:381
#, no-c-format
msgid "<para>or</para>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:383
#, fuzzy, no-c-format
msgid "&lt;key column=\"productSerialNumber\" not-null=\"true\"/&gt;"
msgstr "&lt;key column=\"productSerialNumber\" not-null=\"true\"/&gt;"

#. Tag: para
#: collection_mapping.xml:385
#, fuzzy, no-c-format
msgid ""
"The foreign key constraint can use <literal>ON DELETE CASCADE</literal>. In "
"XML this can be expressed via:"
msgstr ""
"外部キーの制約が <literal>ON DELETE CASCADE</literal> を使うかもしれません。"

#. Tag: programlisting
#: collection_mapping.xml:388
#, fuzzy, no-c-format
msgid "&lt;key column=\"productSerialNumber\" on-delete=\"cascade\"/&gt;"
msgstr "&lt;key column=\"productSerialNumber\" on-delete=\"cascade\"/&gt;"

#. Tag: para
#: collection_mapping.xml:390
#, no-c-format
msgid ""
"In annotations the Hibernate specific annotation @OnDelete has to be used."
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:393
#, no-c-format
msgid "@OnDelete(action=OnDeleteAction.CASCADE)"
msgstr ""

#. Tag: para
#: collection_mapping.xml:395
#, fuzzy, no-c-format
msgid ""
"See <xref lang=\"\" linkend=\"section.key\"/> for more information about the "
"<literal>&lt;key&gt;</literal> element."
msgstr ""
"<literal>&lt;key&gt;</literal> 要素のすべての定義については前の章を参照してく"
"ださい。"

#. Tag: title
#: collection_mapping.xml:400
#, no-c-format
msgid "Indexed collections"
msgstr "インデックス付きのコレクション"

#. Tag: para
#: collection_mapping.xml:402
#, no-c-format
msgid ""
"In the following paragraphs we have a closer at the indexed collections "
"<classname>List</classname> and <classname>Map</classname> how the their "
"index can be mapped in Hibernate."
msgstr ""

#. Tag: title
#: collection_mapping.xml:407
#, no-c-format
msgid "Lists"
msgstr ""

#. Tag: para
#: collection_mapping.xml:409
#, no-c-format
msgid "Lists can be mapped in two different ways:"
msgstr ""

#. Tag: para
#: collection_mapping.xml:413
#, no-c-format
msgid "as ordered lists, where the order is not materialized in the database"
msgstr ""

#. Tag: para
#: collection_mapping.xml:418
#, no-c-format
msgid "as indexed lists, where the order is materialized in the database"
msgstr ""

#. Tag: para
#: collection_mapping.xml:423
#, no-c-format
msgid ""
"To order lists in memory, add <literal>@javax.persistence.OrderBy</literal> "
"to your property. This annotation takes as parameter a list of comma "
"separated properties (of the target entity) and orders the collection "
"accordingly (eg <code>firstname asc, age desc</code>), if the string is "
"empty, the collection will be ordered by the primary key of the target "
"entity."
msgstr ""

#. Tag: title
#: collection_mapping.xml:432
#, no-c-format
msgid "Ordered lists using <classname>@OrderBy</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:434
#, no-c-format
msgid ""
"@Entity\n"
"public class Customer {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   @OneToMany(mappedBy=\"customer\")\n"
"   @OrderBy(\"number\")\n"
"   public List&lt;Order&gt; getOrders() { return orders; }\n"
"   public void setOrders(List&lt;Order&gt; orders) { this.orders = "
"orders; }\n"
"   private List&lt;Order&gt; orders;\n"
"}\n"
"\n"
"@Entity\n"
"public class Order {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   public String getNumber() { return number; }\n"
"   public void setNumber(String number) { this.number = number; }\n"
"   private String number;\n"
"\n"
"   @ManyToOne\n"
"   public Customer getCustomer() { return customer; }\n"
"   public void setCustomer(Customer customer) { this.customer = customer; }\n"
"   private Customer number;\n"
"}\n"
"\n"
"-- Table schema\n"
"|-------------| |----------|\n"
"| Order       | | Customer |\n"
"|-------------| |----------|\n"
"| id          | | id       |\n"
"| number      | |----------| \n"
"| customer_id |\n"
"|-------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:437
#, no-c-format
msgid ""
"To store the index value in a dedicated column, use the <classname>@javax."
"persistence.OrderColumn</classname> annotation on your property. This "
"annotations describes the column name and attributes of the column keeping "
"the index value. This column is hosted on the table containing the "
"association foreign key. If the column name is not specified, the default is "
"the name of the referencing property, followed by underscore, followed by "
"<literal>ORDER</literal> (in the following example, it would be "
"<literal>orders_ORDER</literal>)."
msgstr ""

#. Tag: title
#: collection_mapping.xml:448
#, no-c-format
msgid "Explicit index column using <classname>@OrderColumn</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:451
#, no-c-format
msgid ""
"@Entity\n"
"public class Customer {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   @OneToMany(mappedBy=\"customer\")\n"
"   @OrderColumn(name=\"orders_index\")\n"
"   public List&lt;Order&gt; getOrders() { return orders; }\n"
"   public void setOrders(List&lt;Order&gt; orders) { this.orders = "
"orders; }\n"
"   private List&lt;Order&gt; orders;\n"
"}\n"
"\n"
"@Entity\n"
"public class Order {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   public String getNumber() { return number; }\n"
"   public void setNumber(String number) { this.number = number; }\n"
"   private String number;\n"
"\n"
"   @ManyToOne\n"
"   public Customer getCustomer() { return customer; }\n"
"   public void setCustomer(Customer customer) { this.customer = customer; }\n"
"   private Customer number;\n"
"}\n"
"\n"
"-- Table schema\n"
"|--------------| |----------|\n"
"| Order        | | Customer |\n"
"|--------------| |----------|\n"
"| id           | | id       |\n"
"| number       | |----------| \n"
"| customer_id  |\n"
"| orders_order |\n"
"|--------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:455
#, no-c-format
msgid ""
"We recommend you to convert <classname>the legacy @org.hibernate.annotations."
"IndexColumn</classname> usages to <classname>@OrderColumn</classname> unless "
"you are making use of the base property. The <literal>base</literal> "
"property lets you define the index value of the first element (aka as base "
"index). The usual value is <literal>0</literal> or <literal>1</literal>. The "
"default is 0 like in Java."
msgstr ""

#. Tag: para
#: collection_mapping.xml:464
#, no-c-format
msgid ""
"Looking again at the Hibernate mapping file equivalent, the index of an "
"array or list is always of type <literal>integer</literal> and is mapped "
"using the <literal>&lt;list-index&gt;</literal> element. The mapped column "
"contains sequential integers that are numbered from zero by default."
msgstr ""

#. Tag: title
#: collection_mapping.xml:471
#, no-c-format
msgid "index-list element for indexed collections in xml mapping"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:481
#, no-c-format
msgid ""
"&lt;list-index\n"
"        column=\"column_name\"\n"
"        base=\"0|1|...\"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:485
#, fuzzy, no-c-format
msgid ""
"<literal>column_name</literal> (required): the name of the column holding "
"the collection index values."
msgstr "<literal>class</literal> （必須）: 関連クラスの名前。"

#. Tag: para
#: collection_mapping.xml:490
#, fuzzy, no-c-format
msgid ""
"<literal>base</literal> (optional - defaults to <literal>0</literal>): the "
"value of the index column that corresponds to the first element of the list "
"or array."
msgstr ""
"<literal>cascade</literal> （オプション - デフォルトは <literal>none</"
"literal>）：子エンティティへのカスケード操作を有効にします。"

#. Tag: para
#: collection_mapping.xml:498
#, fuzzy, no-c-format
msgid ""
"If your table does not have an index column, and you still wish to use "
"<literal>List</literal> as the property type, you can map the property as a "
"Hibernate <emphasis>&lt;bag&gt;</emphasis>. A bag does not retain its order "
"when it is retrieved from the database, but it can be optionally sorted or "
"ordered."
msgstr ""
"もしテーブルにインデックスカラムがなくても、プロパティ型として "
"<literal>List</literal> を使いたければ、 Hibernate の <emphasis>&lt;bag&gt;</"
"emphasis> としてプロパティをマッピングします。 bag はデータベースから復元され"
"る時、順序を保持しません。しかし、（メモリ上で）ソートしたり、（SQLで）順序付"
"けしたり（order by）することもできます。"

#. Tag: title
#: collection_mapping.xml:506
#, no-c-format
msgid "Maps"
msgstr ""

#. Tag: para
#: collection_mapping.xml:508
#, no-c-format
msgid ""
"The question with <classname>Map</classname>s is where the key value is "
"stored. There are everal options. Maps can borrow their keys from one of the "
"associated entity properties or have dedicated columns to store an explicit "
"key."
msgstr ""

#. Tag: para
#: collection_mapping.xml:513
#, no-c-format
msgid ""
"To use one of the target entity property as a key of the map, use "
"<literal>@MapKey(name=\"myProperty\")</literal>, where <literal>myProperty</"
"literal> is a property name in the target entity. When using "
"<literal>@MapKey</literal> without the name attribuate, the target entity "
"primary key is used. The map key uses the same column as the property "
"pointed out. There is no additional column defined to hold the map key, "
"because the map key represent a target property. Be aware that once loaded, "
"the key is no longer kept in sync with the property. In other words, if you "
"change the property value, the key will not change automatically in your "
"Java model."
msgstr ""

#. Tag: title
#: collection_mapping.xml:525
#, no-c-format
msgid ""
"Use of target entity property as map key via <classname>@MapKey</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:528
#, no-c-format
msgid ""
"@Entity\n"
"public class Customer {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   @OneToMany(mappedBy=\"customer\")\n"
"   @MapKey(name=\"number\")\n"
"   public Map&lt;String,Order&gt; getOrders() { return orders; }\n"
"   public void setOrders(Map&lt;String,Order&gt; order) { this.orders = "
"orders; }\n"
"   private Map&lt;String,Order&gt; orders;\n"
"}\n"
"\n"
"@Entity\n"
"public class Order {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   public String getNumber() { return number; }\n"
"   public void setNumber(String number) { this.number = number; }\n"
"   private String number;\n"
"\n"
"   @ManyToOne\n"
"   public Customer getCustomer() { return customer; }\n"
"   public void setCustomer(Customer customer) { this.customer = customer; }\n"
"   private Customer number;\n"
"}\n"
"\n"
"-- Table schema\n"
"|-------------| |----------|\n"
"| Order       | | Customer |\n"
"|-------------| |----------|\n"
"| id          | | id       |\n"
"| number      | |----------| \n"
"| customer_id |\n"
"|-------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:531
#, no-c-format
msgid ""
"Alternatively the map key is mapped to a dedicated column or columns. In "
"order to customize the mapping use one of the following annotations:"
msgstr ""

#. Tag: para
#: collection_mapping.xml:537
#, no-c-format
msgid ""
"@<classname>MapKeyColumn</classname> if the map key is a basic type. If you "
"don't specify the column name, the name of the property followed by "
"underscore followed by <literal>KEY</literal> is used (for example "
"<literal>orders_KEY</literal>)."
msgstr ""

#. Tag: para
#: collection_mapping.xml:544
#, no-c-format
msgid ""
"<classname>@MapKeyEnumerated</classname> / <classname>@MapKeyTemporal</"
"classname> if the map key type is respectively an enum or a <classname>Date</"
"classname>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:550
#, no-c-format
msgid ""
"<classname>@MapKeyJoinColumn</classname>/<classname>@MapKeyJoinColumns</"
"classname> if the map key type is another entity."
msgstr ""

#. Tag: para
#: collection_mapping.xml:555
#, no-c-format
msgid ""
"<classname>@AttributeOverride</classname>/<classname>@AttributeOverrides</"
"classname> when the map key is a embeddable object. Use <literal>key.</"
"literal> as a prefix for your embeddable object property names."
msgstr ""

#. Tag: para
#: collection_mapping.xml:562
#, no-c-format
msgid ""
"You can also use <classname>@MapKeyClass</classname> to define the type of "
"the key if you don't use generics."
msgstr ""

#. Tag: title
#: collection_mapping.xml:566
#, no-c-format
msgid "Map key as basic type using <classname>@MapKeyColumn</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:569
#, no-c-format
msgid ""
"@Entity\n"
"public class Customer {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   @OneToMany @JoinTable(name=\"Cust_Order\")\n"
"   @MapKeyColumn(name=\"orders_number\")\n"
"   public Map&lt;String,Order&gt; getOrders() { return orders; }\n"
"   public void setOrders(Map&lt;String,Order&gt; orders) { this.orders = "
"orders; }\n"
"   private Map&lt;String,Order&gt; orders;\n"
"}\n"
"\n"
"@Entity\n"
"public class Order {\n"
"   @Id @GeneratedValue public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   public String getNumber() { return number; }\n"
"   public void setNumber(String number) { this.number = number; }\n"
"   private String number;\n"
"\n"
"   @ManyToOne\n"
"   public Customer getCustomer() { return customer; }\n"
"   public void setCustomer(Customer customer) { this.customer = customer; }\n"
"   private Customer number;\n"
"}\n"
"\n"
"-- Table schema\n"
"|-------------| |----------| |---------------|\n"
"| Order       | | Customer | | Cust_Order    |\n"
"|-------------| |----------| |---------------|\n"
"| id          | | id       | | customer_id   |\n"
"| number      | |----------| | order_id      |\n"
"| customer_id |              | orders_number |\n"
"|-------------|              |---------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:573
#, no-c-format
msgid ""
"We recommend you to migrate from <classname>@org.hibernate.annotations."
"MapKey</classname> / <classname>@org.hibernate.annotation.MapKeyManyToMany</"
"classname> to the new standard approach described above"
msgstr ""

#. Tag: para
#: collection_mapping.xml:579
#, fuzzy, no-c-format
msgid ""
"Using Hibernate mapping files there exists equivalent concepts to the "
"descibed annotations. You have to use <literal>&lt;map-key&gt;</literal>, "
"<literal>&lt;map-key-many-to-many&gt;</literal> and <literal>&lt;composite-"
"map-key&gt;</literal>. <literal>&lt;map-key&gt;</literal> is used for any "
"basic type, <literal>&lt;map-key-many-to-many&gt;</literal> for an entity "
"reference and <literal>&lt;composite-map-key&gt;</literal> for a composite "
"type."
msgstr ""
"マッピング要素には <literal>&lt;set&gt;</literal> の他に <literal>&lt;"
"list&gt;</literal>、 <literal>&lt;map&gt;</literal>、 <literal>&lt;bag&gt;</"
"literal>、 <literal>&lt;array&gt;</literal>、 <literal>&lt;primitive-"
"array&gt;</literal> があります。代表として、 <literal>&lt;map&gt;</literal> "
"要素を下記に示します。"

#. Tag: title
#: collection_mapping.xml:590
#, no-c-format
msgid "map-key xml mapping element"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:601
#, no-c-format
msgid ""
"&lt;map-key\n"
"        column=\"column_name\"\n"
"        formula=\"any SQL expression\"\n"
"        type=\"type_name\"\n"
"        node=\"@attribute-name\"\n"
"        length=\"N\"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:605
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional): the name of the column holding the "
"collection index values."
msgstr ""
"<literal>schema</literal> （オプション）：テーブルスキーマの名前。ルート要素"
"で宣言されているスキーマより優先されます。"

#. Tag: para
#: collection_mapping.xml:610
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): a SQL formula used to evaluate the "
"key of the map."
msgstr ""

#. Tag: para
#: collection_mapping.xml:615
#, fuzzy, no-c-format
msgid "<literal>type</literal> (required): the type of the map keys."
msgstr "<literal>class</literal> （必須）: 関連クラスの名前。"

#. Tag: title
#: collection_mapping.xml:623
#, fuzzy, no-c-format
msgid "map-key-many-to-many"
msgstr "many-to-many"

#. Tag: programlisting
#: collection_mapping.xml:634
#, no-c-format
msgid ""
"&lt;map-key-many-to-many\n"
"        column=\"column_name\"\n"
"        formula=\"any SQL expression\"\n"
"        class=\"ClassName\"\n"
"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:638
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional): the name of the foreign key column for "
"the collection index values."
msgstr ""
"<literal>schema</literal> （オプション）：テーブルスキーマの名前。ルート要素"
"で宣言されているスキーマより優先されます。"

#. Tag: para
#: collection_mapping.xml:643
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): a SQ formula used to evaluate the "
"foreign key of the map key."
msgstr ""

#. Tag: para
#: collection_mapping.xml:648
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (required): the entity class used as the map key."
msgstr "<literal>class</literal> （必須）: 関連クラスの名前。"

#. Tag: title
#: collection_mapping.xml:658
#, fuzzy, no-c-format
msgid "Collections of basic types and embeddable objects"
msgstr "値のコレクションと多対多関連"

#. Tag: para
#: collection_mapping.xml:660
#, no-c-format
msgid ""
"In some situations you don't need to associate two entities but simply "
"create a collection of basic types or embeddable objects. Use the "
"<classname>@ElementCollection</classname> for this case."
msgstr ""

#. Tag: title
#: collection_mapping.xml:665
#, no-c-format
msgid ""
"Collection of basic types mapped via <classname>@ElementCollection</"
"classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:668
#, no-c-format
msgid ""
"@Entity\n"
"public class User {\n"
"   [...]\n"
"   public String getLastname() { ...}\n"
"\n"
"   @ElementCollection\n"
"   @CollectionTable(name=\"Nicknames\", joinColumns=@JoinColumn(name="
"\"user_id\"))\n"
"   @Column(name=\"nickname\")\n"
"   public Set&lt;String&gt; getNicknames() { ... } \n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:671
#, no-c-format
msgid ""
"The collection table holding the collection data is set using the "
"<classname>@CollectionTable</classname> annotation. If omitted the "
"collection table name defaults to the concatenation of the name of the "
"containing entity and the name of the collection attribute, separated by an "
"underscore. In our example, it would be <literal>User_nicknames</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:678
#, no-c-format
msgid ""
"The column holding the basic type is set using the <classname>@Column</"
"classname> annotation. If omitted, the column name defaults to the property "
"name: in our example, it would be <literal>nicknames</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:683
#, no-c-format
msgid ""
"But you are not limited to basic types, the collection type can be any "
"embeddable object. To override the columns of the embeddable object in the "
"collection table, use the <classname>@AttributeOverride</classname> "
"annotation."
msgstr ""

#. Tag: title
#: collection_mapping.xml:689
#, no-c-format
msgid "@ElementCollection for embeddable objects"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:691
#, no-c-format
msgid ""
"@Entity\n"
"public class User {\n"
"   [...]\n"
"   public String getLastname() { ...}\n"
"\n"
"   @ElementCollection\n"
"   @CollectionTable(name=\"Addresses\", joinColumns=@JoinColumn(name="
"\"user_id\"))\n"
"   @AttributeOverrides({\n"
"      @AttributeOverride(name=\"street1\", column=@Column(name=\"fld_street"
"\"))\n"
"   })\n"
"   public Set&lt;Address&gt; getAddresses() { ... } \n"
"}\n"
"\n"
"@Embeddable\n"
"public class Address {\n"
"   public String getStreet1() {...}\n"
"   [...]\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:694
#, no-c-format
msgid "Such an embeddable object cannot contains a collection itself."
msgstr ""

#. Tag: para
#: collection_mapping.xml:698
#, no-c-format
msgid ""
"in <classname>@AttributeOverride</classname>, you must use the "
"<literal>value.</literal> prefix to override properties of the embeddable "
"object used in the map value and the <literal>key.</literal> prefix to "
"override properties of the embeddable object used in the map key."
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:704
#, no-c-format
msgid ""
"@Entity\n"
"public class User {\n"
"   @ElementCollection\n"
"   @AttributeOverrides({\n"
"      @AttributeOverride(name=\"key.street1\", column=@Column(name="
"\"fld_street\")),\n"
"      @AttributeOverride(name=\"value.stars\", column=@Column(name=\"fld_note"
"\"))\n"
"   })\n"
"   public Map&lt;Address,Rating&gt; getFavHomes() { ... }"
msgstr ""

#. Tag: para
#: collection_mapping.xml:708
#, no-c-format
msgid ""
"We recommend you to migrate from <classname>@org.hibernate.annotations."
"CollectionOfElements</classname> to the new <classname>@ElementCollection</"
"classname> annotation."
msgstr ""

#. Tag: para
#: collection_mapping.xml:714
#, fuzzy, no-c-format
msgid ""
"Using the mapping file approach a collection of values is mapped using the "
"<literal>&lt;element&gt;</literal> tag. For example:"
msgstr ""
"値のコレクションのために、 <literal>&lt;element&gt;</literal> タグを使用しま"
"す。"

#. Tag: title
#: collection_mapping.xml:718
#, no-c-format
msgid "&lt;element&gt; tag for collection values using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:730
#, no-c-format
msgid ""
"&lt;element\n"
"        column=\"column_name\"\n"
"        formula=\"any SQL expression\"\n"
"        type=\"typename\"\n"
"        length=\"L\"\n"
"        precision=\"P\"\n"
"        scale=\"S\"\n"
"        not-null=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        node=\"element-name\"\n"
"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:734
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional): the name of the column holding the "
"collection element values."
msgstr ""
"<literal>schema</literal> （オプション）：テーブルスキーマの名前。ルート要素"
"で宣言されているスキーマより優先されます。"

#. Tag: para
#: collection_mapping.xml:739
#, fuzzy, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL formula used to evaluate the "
"element."
msgstr ""
"<literal>schema</literal> （オプション）：テーブルスキーマの名前。ルート要素"
"で宣言されているスキーマより優先されます。"

#. Tag: para
#: collection_mapping.xml:744
#, fuzzy, no-c-format
msgid "<literal>type</literal> (required): the type of the collection element."
msgstr "<literal>class</literal> （必須）: 関連クラスの名前。"

#. Tag: title
#: collection_mapping.xml:754
#, no-c-format
msgid "Advanced collection mappings"
msgstr "高度なコレクションマッピング"

#. Tag: title
#: collection_mapping.xml:757
#, no-c-format
msgid "Sorted collections"
msgstr "ソートされたコレクション"

#. Tag: para
#: collection_mapping.xml:759
#, no-c-format
msgid ""
"Hibernate supports collections implementing <literal>java.util.SortedMap</"
"literal> and <literal>java.util.SortedSet</literal>. With annotations you "
"declare a sort comparator using <literal>@Sort</literal>. You chose between "
"the comparator types unsorted, natural or custom. If you want to use your "
"own comparator implementation, you'll also have to specify the "
"implementation class using the <literal>comparator</literal> attribute. Note "
"that you need to use either a <classname>SortedSet</classname> or a "
"<classname>SortedMap</classname> interface."
msgstr ""

#. Tag: title
#: collection_mapping.xml:770
#, fuzzy, no-c-format
msgid "Sorted collection with @Sort"
msgstr "ソートされたコレクション"

#. Tag: programlisting
#: collection_mapping.xml:772
#, no-c-format
msgid ""
"@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)\n"
"@JoinColumn(name=\"CUST_ID\")\n"
"@Sort(type = SortType.COMPARATOR, comparator = TicketComparator.class)\n"
"public SortedSet&lt;Ticket&gt; getTickets() {\n"
"    return tickets;\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:775
#, no-c-format
msgid ""
"Using Hibernate mapping files you specify a comparator in the mapping file "
"with <literal>&lt;sort&gt;</literal>:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:779
#, fuzzy, no-c-format
msgid "Sorted collection using xml mapping"
msgstr "ソートされたコレクション"

#. Tag: programlisting
#: collection_mapping.xml:781
#, fuzzy, no-c-format
msgid ""
"&lt;set name=\"aliases\"\n"
"            table=\"person_aliases\" \n"
"            sort=\"natural\"&gt;\n"
"    &lt;key column=\"person\"/&gt;\n"
"    &lt;element column=\"name\" type=\"string\"/&gt;\n"
"&lt;/set&gt;\n"
"\n"
"&lt;map name=\"holidays\" sort=\"my.custom.HolidayComparator\"&gt;\n"
"    &lt;key column=\"year_id\"/&gt;\n"
"    &lt;map-key column=\"hol_name\" type=\"string\"/&gt;\n"
"    &lt;element column=\"hol_date\" type=\"date\"/&gt;\n"
"&lt;/map&gt;"
msgstr ""
"&lt;set name=\"aliases\" \n"
"            table=\"person_aliases\" \n"
"            sort=\"natural\"&gt;\n"
"    &lt;key column=\"person\"/&gt;\n"
"    &lt;element column=\"name\" type=\"string\"/&gt;\n"
"&lt;/set&gt;\n"
"\n"
"&lt;map name=\"holidays\" sort=\"my.custom.HolidayComparator\"&gt;\n"
"    &lt;key column=\"year_id\"/&gt;\n"
"    &lt;map-key column=\"hol_name\" type=\"string\"/&gt;\n"
"    &lt;element column=\"hol_date\" type=\"date\"/&gt;\n"
"&lt;/map&gt;"

#. Tag: para
#: collection_mapping.xml:784
#, no-c-format
msgid ""
"Allowed values of the <literal>sort</literal> attribute are "
"<literal>unsorted</literal>, <literal>natural</literal> and the name of a "
"class implementing <literal>java.util.Comparator</literal>."
msgstr ""
"<literal>sort</literal> 属性に設定できる値は <literal>unsorted</literal> と "
"<literal>natural</literal> および、 <literal>java.util.Comparator</literal> "
"を実装したクラスの名前です。"

#. Tag: para
#: collection_mapping.xml:789
#, no-c-format
msgid ""
"Sorted collections actually behave like <literal>java.util.TreeSet</literal> "
"or <literal>java.util.TreeMap</literal>."
msgstr ""
"ソートされたコレクションは実質的には <literal>java.util.TreeSet</literal> や "
"<literal>java.util.TreeMap</literal> のように振舞います。"

#. Tag: para
#: collection_mapping.xml:794
#, fuzzy, no-c-format
msgid ""
"If you want the database itself to order the collection elements, use the "
"<literal>order-by</literal> attribute of <literal>set</literal>, "
"<literal>bag</literal> or <literal>map</literal> mappings. This solution is "
"implemented using <literal>LinkedHashSet</literal> or "
"<literal>LinkedHashMap</literal> and performs the ordering in the SQL query "
"and not in the memory."
msgstr ""
"もしデータベース自身にコレクションの要素を並べさせたいなら、 <literal>set</"
"literal> や <literal>bag</literal>、<literal>map</literal> の <literal>order-"
"by</literal> 属性を使います。この解決法は JDK1.4 、もしくはそれ以上のバージョ"
"ンで利用可能です （<literal>LinkedHashSet</literal> または "
"<literal>LinkedHashMap</literal>を使って実装されています）。整列はメモリ上で"
"はなく、 SQL クエリ内で実行されます。"

#. Tag: title
#: collection_mapping.xml:802
#, no-c-format
msgid "Sorting in database using order-by"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:804
#, fuzzy, no-c-format
msgid ""
"&lt;set name=\"aliases\" table=\"person_aliases\" order-by=\"lower(name) asc"
"\"&gt;\n"
"    &lt;key column=\"person\"/&gt;\n"
"    &lt;element column=\"name\" type=\"string\"/&gt;\n"
"&lt;/set&gt;\n"
"\n"
"&lt;map name=\"holidays\" order-by=\"hol_date, hol_name\"&gt;\n"
"    &lt;key column=\"year_id\"/&gt;\n"
"    &lt;map-key column=\"hol_name\" type=\"string\"/&gt;\n"
"    &lt;element column=\"hol_date type=\"date\"/&gt;\n"
"&lt;/map&gt;"
msgstr ""
"&lt;set name=\"aliases\" table=\"person_aliases\" order-by=\"lower(name) asc"
"\"&gt;\n"
"    &lt;key column=\"person\"/&gt;\n"
"    &lt;element column=\"name\" type=\"string\"/&gt;\n"
"&lt;/set&gt;\n"
"\n"
"&lt;map name=\"holidays\" order-by=\"hol_date, hol_name\"&gt;\n"
"    &lt;key column=\"year_id\"/&gt;\n"
"    &lt;map-key column=\"hol_name\" type=\"string\"/&gt;\n"
"    &lt;element column=\"hol_date type=\"date\"/&gt;\n"
"&lt;/map&gt;"

#. Tag: title
#: collection_mapping.xml:808
#, no-c-format
msgid "Note"
msgstr "注記"

#. Tag: para
#: collection_mapping.xml:810
#, fuzzy, no-c-format
msgid ""
"The value of the <literal>order-by</literal> attribute is an SQL ordering, "
"not an HQL ordering."
msgstr ""
"<literal>order-by</literal> 属性の値が SQL 命令であって、 HQL 命令ではないこ"
"とに注意してください。"

#. Tag: para
#: collection_mapping.xml:814
#, no-c-format
msgid ""
"Associations can even be sorted by arbitrary criteria at runtime using a "
"collection <literal>filter()</literal>:"
msgstr ""
"関連は、コレクションの <literal>filter()</literal> を使うことで、実行時に任意"
"の criteria によってソートすることも可能です。"

#. Tag: title
#: collection_mapping.xml:818
#, no-c-format
msgid "Sorting via a query filter"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:820
#, fuzzy, no-c-format
msgid ""
"sortedUsers = s.createFilter( group.getUsers(), \"order by this.name\" ).list"
"();"
msgstr ""
"sortedUsers = s.createFilter( group.getUsers(), \"order by this.name\" ).list"
"();"

#. Tag: title
#: collection_mapping.xml:825
#, no-c-format
msgid "Bidirectional associations"
msgstr "双方向関連"

#. Tag: para
#: collection_mapping.xml:827
#, no-c-format
msgid ""
"A <emphasis>bidirectional association</emphasis> allows navigation from both "
"\"ends\" of the association. Two kinds of bidirectional association are "
"supported:"
msgstr ""
"<emphasis>双方向関連</emphasis> は関連のどちら「側」からでもナビゲーションで"
"きます。2種類の双方向関連がサポートされています："

#. Tag: term
#: collection_mapping.xml:831
#, no-c-format
msgid "one-to-many"
msgstr "one-to-many"

#. Tag: para
#: collection_mapping.xml:834
#, no-c-format
msgid "set or bag valued at one end and single-valued at the other"
msgstr "片側が set か bag 、もう片方が単一値です。"

#. Tag: term
#: collection_mapping.xml:840
#, no-c-format
msgid "many-to-many"
msgstr "many-to-many"

#. Tag: para
#: collection_mapping.xml:843
#, no-c-format
msgid "set or bag valued at both ends"
msgstr "両側が set か bag です。"

#. Tag: para
#: collection_mapping.xml:848
#, no-c-format
msgid ""
"Often there exists a many to one association which is the owner side of a "
"bidirectional relationship. The corresponding one to many association is in "
"this case annotated by <literal>@OneToMany(mappedBy=...)</literal>"
msgstr ""

#. Tag: title
#: collection_mapping.xml:854
#, no-c-format
msgid "Bidirectional one to many with many to one side as association owner"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:857
#, no-c-format
msgid ""
"@Entity\n"
"public class Troop {\n"
"    @OneToMany(mappedBy=\"troop\")\n"
"    public Set&lt;Soldier&gt; getSoldiers() {\n"
"    ...\n"
"}\n"
"\n"
"@Entity\n"
"public class Soldier {\n"
"    @ManyToOne\n"
"    @JoinColumn(name=\"troop_fk\")\n"
"    public Troop getTroop() {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:860
#, no-c-format
msgid ""
"<classname>Troop</classname> has a bidirectional one to many relationship "
"with <literal>Soldier</literal> through the <literal>troop</literal> "
"property. You don't have to (must not) define any physical mapping in the "
"<literal>mappedBy</literal> side."
msgstr ""

#. Tag: para
#: collection_mapping.xml:865
#, no-c-format
msgid ""
"To map a bidirectional one to many, with the one-to-many side as the owning "
"side, you have to remove the <literal>mappedBy</literal> element and set the "
"many to one <literal>@JoinColumn</literal> as insertable and updatable to "
"false. This solution is not optimized and will produce additional UPDATE "
"statements."
msgstr ""

#. Tag: title
#: collection_mapping.xml:872
#, fuzzy, no-c-format
msgid "Bidirectional associtaion with one to many side as owner"
msgstr "インデックス付きコレクションと双方向関連"

#. Tag: programlisting
#: collection_mapping.xml:875
#, no-c-format
msgid ""
"@Entity\n"
"public class Troop {\n"
"    @OneToMany\n"
"    @JoinColumn(name=\"troop_fk\") //we need to duplicate the physical "
"information\n"
"    public Set&lt;Soldier&gt; getSoldiers() {\n"
"    ...\n"
"}\n"
"\n"
"@Entity\n"
"public class Soldier {\n"
"    @ManyToOne\n"
"    @JoinColumn(name=\"troop_fk\", insertable=false, updatable=false)\n"
"    public Troop getTroop() {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:878
#, fuzzy, no-c-format
msgid ""
"How does the mappping of a bidirectional mapping look like in Hibernate "
"mapping xml? There you define a bidirectional one-to-many association by "
"mapping a one-to-many association to the same table column(s) as a many-to-"
"one association and declaring the many-valued end <literal>inverse=\"true\"</"
"literal>."
msgstr ""
"双方向の一対多関連を定義するには、一対多関連を多対一関連と同じテーブルのカラ"
"ムにマッピングし、多側に <literal>inverse=\"true\"</literal> と宣言します。"

#. Tag: title
#: collection_mapping.xml:885
#, no-c-format
msgid "Bidirectional one to many via Hibernate mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:887
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Parent\"&gt;\n"
"    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
"    ....\n"
"    &lt;set name=\"children\" inverse=\"true\"&gt;\n"
"        &lt;key column=\"parent_id\"/&gt;\n"
"        &lt;one-to-many class=\"Child\"/&gt;\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Child\"&gt;\n"
"    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
"    ....\n"
"    &lt;many-to-one name=\"parent\" \n"
"        class=\"Parent\" \n"
"        column=\"parent_id\"\n"
"        not-null=\"true\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Parent\"&gt;\n"
"    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
"    ....\n"
"    &lt;set name=\"children\" inverse=\"true\"&gt;\n"
"        &lt;key column=\"parent_id\"/&gt;\n"
"        &lt;one-to-many class=\"Child\"/&gt;\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Child\"&gt;\n"
"    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
"    ....\n"
"    &lt;many-to-one name=\"parent\" \n"
"        class=\"Parent\" \n"
"        column=\"parent_id\"\n"
"        not-null=\"true\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: collection_mapping.xml:890
#, no-c-format
msgid ""
"Mapping one end of an association with <literal>inverse=\"true\"</literal> "
"does not affect the operation of cascades as these are orthogonal concepts."
msgstr ""
"関連の片側に <literal>inverse=\"true\"</literal> を設定しても、カスケード操作"
"に影響を与えません。これらは直交した概念です。"

#. Tag: para
#: collection_mapping.xml:894
#, no-c-format
msgid ""
"A many-to-many association is defined logically using the "
"<literal>@ManyToMany</literal> annotation. You also have to describe the "
"association table and the join conditions using the <literal>@JoinTable</"
"literal> annotation. If the association is bidirectional, one side has to be "
"the owner and one side has to be the inverse end (ie. it will be ignored "
"when updating the relationship values in the association table):"
msgstr ""

#. Tag: title
#: collection_mapping.xml:903
#, no-c-format
msgid "Many to many association via @ManyToMany"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:905
#, no-c-format
msgid ""
"@Entity\n"
"public class Employer implements Serializable {\n"
"    @ManyToMany(\n"
"        targetEntity=org.hibernate.test.metadata.manytomany.Employee.class,\n"
"        cascade={CascadeType.PERSIST, CascadeType.MERGE}\n"
"    )\n"
"    @JoinTable(\n"
"        name=\"EMPLOYER_EMPLOYEE\",\n"
"        joinColumns=@JoinColumn(name=\"EMPER_ID\"),\n"
"        inverseJoinColumns=@JoinColumn(name=\"EMPEE_ID\")\n"
"    )\n"
"    public Collection getEmployees() {\n"
"        return employees;\n"
"    }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:907
#, no-c-format
msgid ""
"@Entity\n"
"public class Employee implements Serializable {\n"
"    @ManyToMany(\n"
"        cascade = {CascadeType.PERSIST, CascadeType.MERGE},\n"
"        mappedBy = \"employees\",\n"
"        targetEntity = Employer.class\n"
"    )\n"
"    public Collection getEmployers() {\n"
"        return employers;\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:910
#, no-c-format
msgid ""
"In this example <classname>@JoinTable</classname> defines a <literal>name</"
"literal>, an array of join columns, and an array of inverse join columns. "
"The latter ones are the columns of the association table which refer to the "
"<classname>Employee</classname> primary key (the \"other side\"). As seen "
"previously, the other side don't have to (must not) describe the physical "
"mapping: a simple <literal>mappedBy</literal> argument containing the owner "
"side property name bind the two."
msgstr ""

#. Tag: para
#: collection_mapping.xml:919
#, no-c-format
msgid ""
"As any other annotations, most values are guessed in a many to many "
"relationship. Without describing any physical mapping in a unidirectional "
"many to many the following rules applied. The table name is the "
"concatenation of the owner table name, <keycap>_</keycap> and the other side "
"table name. The foreign key name(s) referencing the owner table is the "
"concatenation of the owner table name, <keycap>_</keycap> and the owner "
"primary key column(s). The foreign key name(s) referencing the other side is "
"the concatenation of the owner property name, <keycap>_</keycap>, and the "
"other side primary key column(s). These are the same rules used for a "
"unidirectional one to many relationship."
msgstr ""

#. Tag: title
#: collection_mapping.xml:932
#, no-c-format
msgid "Default values for <classname>@ManyToMany</classname> (uni-directional)"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:935
#, no-c-format
msgid ""
"@Entity\n"
"public class Store {\n"
"    @ManyToMany(cascade = CascadeType.PERSIST)\n"
"    public Set&lt;City&gt; getImplantedIn() {\n"
"        ...\n"
"    }\n"
"}\n"
"\n"
"@Entity\n"
"public class City {\n"
"    ... //no bidirectional relationship\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:938
#, no-c-format
msgid ""
"A <literal>Store_City</literal> is used as the join table. The "
"<literal>Store_id</literal> column is a foreign key to the <literal>Store</"
"literal> table. The <literal>implantedIn_id</literal> column is a foreign "
"key to the <literal>City</literal> table."
msgstr ""

#. Tag: para
#: collection_mapping.xml:943
#, no-c-format
msgid ""
"Without describing any physical mapping in a bidirectional many to many the "
"following rules applied. The table name is the concatenation of the owner "
"table name, <keycap>_</keycap> and the other side table name. The foreign "
"key name(s) referencing the owner table is the concatenation of the other "
"side property name, <keycap>_</keycap>, and the owner primary key column(s). "
"The foreign key name(s) referencing the other side is the concatenation of "
"the owner property name, <keycap>_</keycap>, and the other side primary key "
"column(s). These are the same rules used for a unidirectional one to many "
"relationship."
msgstr ""

#. Tag: title
#: collection_mapping.xml:955
#, no-c-format
msgid "Default values for <classname>@ManyToMany</classname> (bi-directional)"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:958
#, no-c-format
msgid ""
"@Entity\n"
"public class Store {\n"
"    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n"
"    public Set&lt;Customer&gt; getCustomers() {\n"
"        ...\n"
"    }\n"
"}\n"
"\n"
"@Entity\n"
"public class Customer {\n"
"    @ManyToMany(mappedBy=\"customers\")\n"
"    public Set&lt;Store&gt; getStores() {\n"
"        ...\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:961
#, no-c-format
msgid ""
"A <literal>Store_Customer</literal> is used as the join table. The "
"<literal>stores_id</literal> column is a foreign key to the <literal>Store</"
"literal> table. The <literal>customers_id</literal> column is a foreign key "
"to the <literal>Customer</literal> table."
msgstr ""

#. Tag: para
#: collection_mapping.xml:966
#, fuzzy, no-c-format
msgid ""
"Using Hibernate mapping files you can map a bidirectional many-to-many "
"association by mapping two many-to-many associations to the same database "
"table and declaring one end as <emphasis>inverse</emphasis>."
msgstr ""
"2つの多対多関連で同じデータベーステーブルをマッピングし、片方を "
"<emphasis>inverse</emphasis> として宣言することで、双方向の多対多関連を指定す"
"ることが出来ます （どちらを inverse に選んだとしても、そちら側にはインデック"
"ス付きのコレクションは使えません）。"

#. Tag: para
#: collection_mapping.xml:970
#, no-c-format
msgid "You cannot select an indexed collection."
msgstr ""

#. Tag: para
#: collection_mapping.xml:973
#, fuzzy, no-c-format
msgid ""
"shows a bidirectional many-to-many association that illustrates how each "
"category can have many items and each item can be in many categories:"
msgstr ""
"次に双方向の多対多関連の例を示します。各カテゴリは多数のアイテムを持つことが"
"でき、各アイテムは多くのカテゴリに属することが出来ます。"

#. Tag: title
#: collection_mapping.xml:979
#, no-c-format
msgid "Many to many association using Hibernate mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:981
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Category\"&gt;\n"
"    &lt;id name=\"id\" column=\"CATEGORY_ID\"/&gt;\n"
"    ...\n"
"    &lt;bag name=\"items\" table=\"CATEGORY_ITEM\"&gt;\n"
"        &lt;key column=\"CATEGORY_ID\"/&gt;\n"
"        &lt;many-to-many class=\"Item\" column=\"ITEM_ID\"/&gt;\n"
"    &lt;/bag&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Item\"&gt;\n"
"    &lt;id name=\"id\" column=\"ITEM_ID\"/&gt;\n"
"    ...\n"
"\n"
"    &lt;!-- inverse end --&gt;\n"
"    &lt;bag name=\"categories\" table=\"CATEGORY_ITEM\" inverse=\"true"
"\"&gt;\n"
"        &lt;key column=\"ITEM_ID\"/&gt;\n"
"        &lt;many-to-many class=\"Category\" column=\"CATEGORY_ID\"/&gt;\n"
"    &lt;/bag&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Category\"&gt;\n"
"    &lt;id name=\"id\" column=\"CATEGORY_ID\"/&gt;\n"
"    ...\n"
"    &lt;bag name=\"items\" table=\"CATEGORY_ITEM\"&gt;\n"
"        &lt;key column=\"CATEGORY_ID\"/&gt;\n"
"        &lt;many-to-many class=\"Item\" column=\"ITEM_ID\"/&gt;\n"
"    &lt;/bag&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Item\"&gt;\n"
"    &lt;id name=\"id\" column=\"CATEGORY_ID\"/&gt;\n"
"    ...\n"
"\n"
"    &lt;!-- inverse end --&gt;\n"
"    &lt;bag name=\"categories\" table=\"CATEGORY_ITEM\" inverse=\"true"
"\"&gt;\n"
"        &lt;key column=\"ITEM_ID\"/&gt;\n"
"        &lt;many-to-many class=\"Category\" column=\"CATEGORY_ID\"/&gt;\n"
"    &lt;/bag&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: collection_mapping.xml:984
#, no-c-format
msgid ""
"Changes made only to the inverse end of the association are <emphasis>not</"
"emphasis> persisted. This means that Hibernate has two representations in "
"memory for every bidirectional association: one link from A to B and another "
"link from B to A. This is easier to understand if you think about the Java "
"object model and how a many-to-many relationship in Javais created:"
msgstr ""
"関連の inverse 側にのみ行われた変更は永続化 <emphasis>されません</emphasis>。"
"これは、 Hibernate は全ての双方向関連について、メモリ上に２つの表現を持ってい"
"るという意味です。つまり一つは A から B へのリンクで、もう一つは B から A へ"
"のリンクということです。 Java のオブジェクトモデルについて考え、 Java で双方"
"向関係をどうやって作るかを考えれば、これは理解しやすいです。下記に、 Java で"
"の双方向関連を示します。"

#. Tag: title
#: collection_mapping.xml:992
#, fuzzy, no-c-format
msgid "Effect of inverse vs. non-inverse side of many to many associations"
msgstr "値のコレクションと多対多関連"

#. Tag: programlisting
#: collection_mapping.xml:995
#, fuzzy, no-c-format
msgid ""
"category.getItems().add(item);           // The category now \"knows\" about "
"the relationship\n"
"item.getCategories().add(category);      // The item now \"knows\" about the "
"relationship\n"
"\n"
"session.persist(item);                   // The relationship won't be "
"saved!\n"
"session.persist(category);               // The relationship will be saved"
msgstr ""
"category.getItems().add(item);          // The category now \"knows\" about "
"the relationship\n"
"item.getCategories().add(category);     // The item now \"knows\" about the "
"relationship\n"
"\n"
"session.persist(item);                   // The relationship won't be "
"saved!\n"
"session.persist(category);               // The relationship will be saved"

#. Tag: para
#: collection_mapping.xml:998
#, no-c-format
msgid ""
"The non-inverse side is used to save the in-memory representation to the "
"database."
msgstr ""
"関連の inverse ではない側は、メモリ上の表現をデータベースに保存するのに使われ"
"ます。"

#. Tag: title
#: collection_mapping.xml:1003
#, no-c-format
msgid "Bidirectional associations with indexed collections"
msgstr "インデックス付きコレクションと双方向関連"

#. Tag: para
#: collection_mapping.xml:1005
#, fuzzy, no-c-format
msgid ""
"There are some additional considerations for bidirectional mappings with "
"indexed collections (where one end is represented as a <literal>&lt;list&gt;"
"</literal> or <literal>&lt;map&gt;</literal>) when using Hibernate mapping "
"files. If there is a property of the child class that maps to the index "
"column you can use <literal>inverse=\"true\"</literal> on the collection "
"mapping:"
msgstr ""
"片側が <literal>&lt;list&gt;</literal> や <literal>&lt;map&gt;</literal> であ"
"る双方向関連は、特によく考える必要があります。インデックスカラムにマップされ"
"る子クラスのプロパティがある場合は、問題ないです。コレクションのマッピングで "
"<literal>inverse=\"true\"</literal> を使い続けられます。"

#. Tag: title
#: collection_mapping.xml:1013
#, fuzzy, no-c-format
msgid "Bidirectional association with indexed collection"
msgstr "インデックス付きコレクションと双方向関連"

#. Tag: programlisting
#: collection_mapping.xml:1015
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Parent\"&gt;\n"
"    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
"    ....\n"
"    &lt;map name=\"children\" inverse=\"true\"&gt;\n"
"        &lt;key column=\"parent_id\"/&gt;\n"
"        &lt;map-key column=\"name\" \n"
"            type=\"string\"/&gt;\n"
"        &lt;one-to-many class=\"Child\"/&gt;\n"
"    &lt;/map&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Child\"&gt;\n"
"    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
"    ....\n"
"    &lt;property name=\"name\" \n"
"        not-null=\"true\"/&gt;\n"
"    &lt;many-to-one name=\"parent\" \n"
"        class=\"Parent\" \n"
"        column=\"parent_id\"\n"
"        not-null=\"true\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Parent\"&gt;\n"
"    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
"    ....\n"
"    &lt;map name=\"children\" inverse=\"true\"&gt;\n"
"        &lt;key column=\"parent_id\"/&gt;\n"
"        &lt;map-key column=\"name\" \n"
"            type=\"string\"/&gt;\n"
"        &lt;one-to-many class=\"Child\"/&gt;\n"
"    &lt;/map&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Child\"&gt;\n"
"    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
"    ....\n"
"    &lt;property name=\"name\" \n"
"        not-null=\"true\"/&gt;\n"
"    &lt;many-to-one name=\"parent\" \n"
"        class=\"Parent\" \n"
"        column=\"parent_id\"\n"
"        not-null=\"true\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: collection_mapping.xml:1018
#, no-c-format
msgid ""
"If there is no such property on the child class, the association cannot be "
"considered truly bidirectional. That is, there is information available at "
"one end of the association that is not available at the other end. In this "
"case, you cannot map the collection <literal>inverse=\"true\"</literal>. "
"Instead, you could use the following mapping:"
msgstr ""
"しかし、子クラスにそのようなプロパティがない場合は、関連を真に双方向であると"
"考えることができません （関連の片側に利用できる情報がありますが、もう一方には"
"ありません）。この場合は、コレクションに <literal>inverse=\"true\"</literal> "
"をマッピングできません。代わりに、次のようなマッピングが使えます："

#. Tag: title
#: collection_mapping.xml:1026
#, fuzzy, no-c-format
msgid "Bidirectional association with indexed collection, but no index column"
msgstr "インデックス付きコレクションと双方向関連"

#. Tag: programlisting
#: collection_mapping.xml:1029
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Parent\"&gt;\n"
"    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
"    ....\n"
"    &lt;map name=\"children\"&gt;\n"
"        &lt;key column=\"parent_id\"\n"
"            not-null=\"true\"/&gt;\n"
"        &lt;map-key column=\"name\" \n"
"            type=\"string\"/&gt;\n"
"        &lt;one-to-many class=\"Child\"/&gt;\n"
"    &lt;/map&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Child\"&gt;\n"
"    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
"    ....\n"
"    &lt;many-to-one name=\"parent\" \n"
"        class=\"Parent\" \n"
"        column=\"parent_id\"\n"
"        insert=\"false\"\n"
"        update=\"false\"\n"
"        not-null=\"true\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Parent\"&gt;\n"
"    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
"    ....\n"
"    &lt;map name=\"children\"&gt;\n"
"        &lt;key column=\"parent_id\"\n"
"            not-null=\"true\"/&gt;\n"
"        &lt;map-key column=\"name\" \n"
"            type=\"string\"/&gt;\n"
"        &lt;one-to-many class=\"Child\"/&gt;\n"
"    &lt;/map&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Child\"&gt;\n"
"    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
"    ....\n"
"    &lt;many-to-one name=\"parent\" \n"
"        class=\"Parent\" \n"
"        column=\"parent_id\"\n"
"        insert=\"false\"\n"
"        update=\"false\"\n"
"        not-null=\"true\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: collection_mapping.xml:1032
#, fuzzy, no-c-format
msgid ""
"Note that in this mapping, the collection-valued end of the association is "
"responsible for updates to the foreign key."
msgstr ""
"注意： このマッピングでは、関連のコレクション値の側は、外部キーをアップデート"
"する責任があります。 <!-- TODO: これは本当にいくつかの不必要なアップデートス"
"テートメントをもたらすのでしょうか? -->"

#. Tag: title
#: collection_mapping.xml:1037
#, no-c-format
msgid "Ternary associations"
msgstr "3項関連"

#. Tag: para
#: collection_mapping.xml:1039
#, no-c-format
msgid ""
"There are three possible approaches to mapping a ternary association. One "
"approach is to use a <literal>Map</literal> with an association as its index:"
msgstr ""
"3項関連のマッピングには3つのアプローチがあります。1つ目は関連をインデックスと"
"して <literal>Map</literal> を使用するアプローチです："

#. Tag: title
#: collection_mapping.xml:1044
#, fuzzy, no-c-format
msgid "Ternary association mapping"
msgstr "3項関連"

#. Tag: programlisting
#: collection_mapping.xml:1046
#, no-c-format
msgid ""
"@Entity\n"
"public class Company {\n"
"   @Id \n"
"   int id;\n"
"   ...\n"
"   @OneToMany // unidirectional\n"
"   @MapKeyJoinColumn(name=\"employee_id\")\n"
"   Map&lt;Employee, Contract&gt; contracts;\n"
"}\n"
"\n"
"// or\n"
"\n"
"&lt;map name=\"contracts\"&gt;\n"
"    &lt;key column=\"employer_id\" not-null=\"true\"/&gt;\n"
"    &lt;map-key-many-to-many column=\"employee_id\" class=\"Employee\"/&gt;\n"
"    &lt;one-to-many class=\"Contract\"/&gt;\n"
"&lt;/map&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1049
#, fuzzy, no-c-format
msgid ""
"A second approach is to remodel the association as an entity class. This is "
"the most common approach. A final alternative is to use composite elements, "
"which will be discussed later."
msgstr ""
"2つ目は単純に関連をエンティティクラスとしてモデルを作り直すアプローチで、頻繁"
"に使われます。"

#. Tag: literal
#: collection_mapping.xml:1055
#, fuzzy, no-c-format
msgid "Using an &lt;idbag&gt;"
msgstr "&lt;idbag&gt;の使用"

#. Tag: para
#: collection_mapping.xml:1057
#, fuzzy, no-c-format
msgid ""
"The majority of the many-to-many associations and collections of values "
"shown previously all map to tables with composite keys, even though it has "
"been suggested that entities should have synthetic identifiers (surrogate "
"keys). A pure association table does not seem to benefit much from a "
"surrogate key, although a collection of composite values <emphasis>might</"
"emphasis>. For this reason Hibernate provides a feature that allows you to "
"map many-to-many associations and collections of values to a table with a "
"surrogate key."
msgstr ""
"複合キーは悪いもので、エンティティは人工の識別子(代理キー)を持つべきであると"
"いう考え方からは、多対多関連と値のコレクションを複合キーを用いたテーブルへ"
"マッピングするのは少し奇妙に感じるかもしれません。確かにこの考え方には議論の"
"余地があります。純粋な関連テーブルは代理キーを使っても利益を得られないように"
"思えるからです （合成値のコレクションは利益がある <emphasis>かも</emphasis> "
"しれませんが）。とはいえ、 Hibernate は代理キーを持つテーブルへ多対多関連と値"
"のコレクションをマッピングする機能も備えています。"

#. Tag: para
#: collection_mapping.xml:1066
#, no-c-format
msgid ""
"The <literal>&lt;idbag&gt;</literal> element lets you map a <literal>List</"
"literal> (or <literal>Collection</literal>) with bag semantics. For example:"
msgstr ""
"bag のセマンティックスを持った <literal>List</literal>（または "
"<literal>Collection</literal>）を <literal>&lt;idbag&gt;</literal> 要素にマッ"
"ピングできます。"

#. Tag: programlisting
#: collection_mapping.xml:1070
#, fuzzy, no-c-format
msgid ""
"&lt;idbag name=\"lovers\" table=\"LOVERS\"&gt;\n"
"    &lt;collection-id column=\"ID\" type=\"long\"&gt;\n"
"        &lt;generator class=\"sequence\"/&gt;\n"
"    &lt;/collection-id&gt;\n"
"    &lt;key column=\"PERSON1\"/&gt;\n"
"    &lt;many-to-many column=\"PERSON2\" class=\"Person\" fetch=\"join\"/"
"&gt;\n"
"&lt;/idbag&gt;"
msgstr ""
"&lt;idbag name=\"lovers\" table=\"LOVERS\"&gt;\n"
"    &lt;collection-id column=\"ID\" type=\"long\"&gt;\n"
"        &lt;generator class=\"sequence\"/&gt;\n"
"    &lt;/collection-id&gt;\n"
"    &lt;key column=\"PERSON1\"/&gt;\n"
"    &lt;many-to-many column=\"PERSON2\" class=\"Person\" fetch=\"join\"/"
"&gt;\n"
"&lt;/idbag&gt;"

#. Tag: para
#: collection_mapping.xml:1072
#, no-c-format
msgid ""
"An <literal>&lt;idbag&gt;</literal> has a synthetic id generator, just like "
"an entity class. A different surrogate key is assigned to each collection "
"row. Hibernate does not, however, provide any mechanism for discovering the "
"surrogate key value of a particular row."
msgstr ""
"ご存知のように <literal>&lt;idbag&gt;</literal> はエンティティクラスのように"
"人工的な id ジェネレータを持っています。異なる代理キーをそれぞれのコレクショ"
"ンの列に割り当てます。しかし、 Hibernate はある行の代理キーの値を見つけ出す機"
"構を持っていません。"

#. Tag: para
#: collection_mapping.xml:1077
#, no-c-format
msgid ""
"The update performance of an <literal>&lt;idbag&gt;</literal> supersedes a "
"regular <literal>&lt;bag&gt;</literal>. Hibernate can locate individual rows "
"efficiently and update or delete them individually, similar to a list, map "
"or set."
msgstr ""
"<literal>&lt;idbag&gt;</literal> を更新するパフォーマンスは通常の "
"<literal>&lt;bag&gt;</literal> よりも良いことに注目してください。 Hibernate "
"は個々の行を効果的に見つけることができ、 list や map 、 set のように個別にそ"
"の行を更新、削除できます。"

#. Tag: para
#: collection_mapping.xml:1082
#, no-c-format
msgid ""
"In the current implementation, the <literal>native</literal> identifier "
"generation strategy is not supported for <literal>&lt;idbag&gt;</literal> "
"collection identifiers."
msgstr ""
"現在の実装では、 <literal>native</literal> という id 生成戦略を <literal>&lt;"
"idbag&gt;</literal> コレクションの識別子に対して使えません。"

#. Tag: title
#: collection_mapping.xml:1103
#, no-c-format
msgid "Collection examples"
msgstr "コレクションの例"

#. Tag: para
#: collection_mapping.xml:1105
#, fuzzy, no-c-format
msgid "This section covers collection examples."
msgstr "コレクションの例"

#. Tag: para
#: collection_mapping.xml:1107
#, fuzzy, no-c-format
msgid ""
"The following class has a collection of <literal>Child</literal> instances:"
msgstr ""
"以下のコードを使えば、新しい <literal>Child</literal> を追加することができま"
"す。"

#. Tag: title
#: collection_mapping.xml:1111
#, no-c-format
msgid ""
"Example classes <classname>Parent</classname> and <classname>Child</"
"classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1114
#, no-c-format
msgid ""
"public class Parent {\n"
"    private long id;\n"
"    private Set&lt;Child&gt; children;\n"
"\n"
"    // getter/setter\n"
"    ...\n"
"}\n"
"\n"
"\n"
"public class Child {\n"
"   private long id;\n"
"   private String name\n"
"\n"
"   \n"
"   // getter/setter\n"
"   ...\n"
"}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1117
#, fuzzy, no-c-format
msgid ""
"If each child has, at most, one parent, the most natural mapping is a one-to-"
"many association:"
msgstr ""
"このクラスは <literal>Child</literal> インスタンスのコレクションを持っていま"
"す。もし各々の child が最大でも一つの parent を持っているならば、最も自然な"
"マッピングは一対多関連です。"

#. Tag: title
#: collection_mapping.xml:1121
#, no-c-format
msgid ""
"One to many unidirectional <classname>Parent-Child</classname> relationship "
"using annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1124
#, no-c-format
msgid ""
"public class Parent {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private long id;\n"
"\n"
"    @OneToMany\n"
"    private Set&lt;Child&gt; children;\n"
"\n"
"    // getter/setter\n"
"    ...\n"
"}\n"
"\n"
"\n"
"public class Child {\n"
"   @Id\n"
"   @GeneratedValue\n"
"   private long id;\n"
"   private String name;\n"
"\n"
"   \n"
"   // getter/setter\n"
"   ...\n"
"}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1128
#, no-c-format
msgid ""
"One to many unidirectional <classname>Parent-Child</classname> relationship "
"using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1131
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\"&gt;\n"
"            &lt;key column=\"parent_id\"/&gt;\n"
"            &lt;one-to-many class=\"Child\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\"&gt;\n"
"            &lt;key column=\"parent_id\"/&gt;\n"
"            &lt;one-to-many class=\"Child\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"

#. Tag: para
#: collection_mapping.xml:1134
#, no-c-format
msgid "This maps to the following table definitions:"
msgstr "これは以下のテーブル定義にマッピングします。"

#. Tag: title
#: collection_mapping.xml:1137
#, no-c-format
msgid ""
"Table definitions for unidirectional <classname>Parent</classname>-"
"<classname>Child</classname> relationship"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1141
#, fuzzy, no-c-format
msgid ""
"create table parent ( id bigint not null primary key )\n"
"create table child ( id bigint not null primary key, name varchar(255), "
"parent_id bigint )\n"
"alter table child add constraint childfk0 (parent_id) references parent"
msgstr ""
"create table parent ( id bigint not null primary key )\n"
"create table child ( id bigint not null primary key, name varchar(255), "
"parent_id bigint )\n"
"alter table child add constraint childfk0 (parent_id) references parent"

#. Tag: para
#: collection_mapping.xml:1144
#, no-c-format
msgid ""
"If the parent is <emphasis>required</emphasis>, use a bidirectional one-to-"
"many association:"
msgstr ""
"もし parent が <emphasis>要求</emphasis> されるなら、双方向の一対多関連を使用"
"してください："

#. Tag: title
#: collection_mapping.xml:1148
#, no-c-format
msgid ""
"One to many bidirectional <classname>Parent-Child</classname> relationship "
"using annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1151
#, no-c-format
msgid ""
"public class Parent {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private long id;\n"
"\n"
"    @OneToMany(mappedBy=\"parent\")\n"
"    private Set&lt;Child&gt; children;\n"
"\n"
"    // getter/setter\n"
"    ...\n"
"}\n"
"\n"
"\n"
"public class Child {\n"
"   @Id\n"
"   @GeneratedValue\n"
"   private long id;\n"
"\n"
"   private String name;\n"
" \n"
"   @ManyToOne\n"
"   private Parent parent;\n"
"\n"
"   \n"
"   // getter/setter\n"
"   ...\n"
"}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1155
#, no-c-format
msgid ""
"One to many bidirectional <classname>Parent-Child</classname> relationship "
"using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1158
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\" inverse=\"true\"&gt;\n"
"            &lt;key column=\"parent_id\"/&gt;\n"
"            &lt;one-to-many class=\"Child\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"        &lt;many-to-one name=\"parent\" class=\"Parent\" column=\"parent_id"
"\" not-null=\"true\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\" inverse=\"true\"&gt;\n"
"            &lt;key column=\"parent_id\"/&gt;\n"
"            &lt;one-to-many class=\"Child\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"        &lt;many-to-one name=\"parent\" class=\"Parent\" column=\"parent_id"
"\" not-null=\"true\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"

#. Tag: para
#: collection_mapping.xml:1161
#, no-c-format
msgid "Notice the <literal>NOT NULL</literal> constraint:"
msgstr "<literal>NOT NULL</literal> 制約に注意してください。"

#. Tag: title
#: collection_mapping.xml:1164
#, no-c-format
msgid ""
"Table definitions for bidirectional <classname>Parent</classname>-"
"<classname>Child</classname> relationship"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1168
#, fuzzy, no-c-format
msgid ""
"create table parent ( id bigint not null primary key )\n"
"create table child ( id bigint not null\n"
"                     primary key,\n"
"                     name varchar(255),\n"
"                     parent_id bigint not null )\n"
"alter table child add constraint childfk0 (parent_id) references parent"
msgstr ""
"create table parent ( id bigint not null primary key )\n"
"create table child ( id bigint not null\n"
"                     primary key,\n"
"                     name varchar(255),\n"
"                     parent_id bigint not null )\n"
"alter table child add constraint childfk0 (parent_id) references parent"

#. Tag: para
#: collection_mapping.xml:1171
#, fuzzy, no-c-format
msgid ""
"Alternatively, if this association must be unidirectional you can enforce "
"the <literal>NOT NULL</literal> constraint."
msgstr ""
"あるいは、もしこの関連は単方向であるべきと強く主張するのであれば、 "
"<literal>&lt;key&gt;</literal> マッピングに <literal>NOT NULL</literal> 制約"
"を宣言できます："

#. Tag: title
#: collection_mapping.xml:1175
#, no-c-format
msgid ""
"Enforcing NOT NULL constraint in unidirectional relation using annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1178
#, no-c-format
msgid ""
"public class Parent {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private long id;\n"
"\n"
"    @OneToMany(optional=false)\n"
"    private Set&lt;Child&gt; children;\n"
"\n"
"    // getter/setter\n"
"    ...\n"
"}\n"
"\n"
"\n"
"public class Child {\n"
"   @Id\n"
"   @GeneratedValue\n"
"   private long id;\n"
"   private String name;\n"
"\n"
"   \n"
"   // getter/setter\n"
"   ...\n"
"}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1182
#, no-c-format
msgid ""
"Enforcing NOT NULL constraint in unidirectional relation using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1185
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\"&gt;\n"
"            &lt;key column=\"parent_id\" not-null=\"true\"/&gt;\n"
"            &lt;one-to-many class=\"Child\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\"&gt;\n"
"            &lt;key column=\"parent_id\" not-null=\"true\"/&gt;\n"
"            &lt;one-to-many class=\"Child\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"

#. Tag: para
#: collection_mapping.xml:1188
#, fuzzy, no-c-format
msgid ""
"On the other hand, if a child has multiple parents, a many-to-many "
"association is appropriate."
msgstr ""
"一方で、もし child が複数の parent を持てるならば、多対多関連が妥当です:"

#. Tag: title
#: collection_mapping.xml:1192
#, no-c-format
msgid ""
"Many to many <classname>Parent-Child</classname> relationship using "
"annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1195
#, no-c-format
msgid ""
"public class Parent {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private long id;\n"
"\n"
"    @ManyToMany\n"
"    private Set&lt;Child&gt; children;\n"
"\n"
"    // getter/setter\n"
"    ...\n"
"}\n"
"\n"
"\n"
"public class Child {\n"
"   @Id\n"
"   @GeneratedValue\n"
"   private long id;\n"
"\n"
"   private String name;\n"
"\n"
"   \n"
"   // getter/setter\n"
"   ...\n"
"}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1199
#, no-c-format
msgid ""
"Many to many <classname>Parent-Child</classname> relationship using mapping "
"files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1202
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\" table=\"childset\"&gt;\n"
"            &lt;key column=\"parent_id\"/&gt;\n"
"            &lt;many-to-many class=\"Child\" column=\"child_id\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class name=\"Parent\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;set name=\"children\" table=\"childset\"&gt;\n"
"            &lt;key column=\"parent_id\"/&gt;\n"
"            &lt;many-to-many class=\"Child\" column=\"child_id\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"    &lt;class name=\"Child\"&gt;\n"
"        &lt;id name=\"id\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"        &lt;property name=\"name\"/&gt;\n"
"    &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"

#. Tag: para
#: collection_mapping.xml:1205
#, no-c-format
msgid "Table definitions:"
msgstr "テーブル定義は以下のようになります:"

#. Tag: title
#: collection_mapping.xml:1208
#, no-c-format
msgid "Table definitions for many to many releationship"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1210
#, fuzzy, no-c-format
msgid ""
"create table parent ( id bigint not null primary key )\n"
"create table child ( id bigint not null primary key, name varchar(255) )\n"
"create table childset ( parent_id bigint not null,\n"
"                        child_id bigint not null,\n"
"                        primary key ( parent_id, child_id ) )\n"
"alter table childset add constraint childsetfk0 (parent_id) references "
"parent\n"
"alter table childset add constraint childsetfk1 (child_id) references child"
msgstr ""
"create table parent ( id bigint not null primary key )\n"
"create table child ( id bigint not null primary key, name varchar(255) )\n"
"create table childset ( parent_id bigint not null,\n"
"                        child_id bigint not null,\n"
"                        primary key ( parent_id, child_id ) )\n"
"alter table childset add constraint childsetfk0 (parent_id) references "
"parent\n"
"alter table childset add constraint childsetfk1 (child_id) references child"

#. Tag: para
#: collection_mapping.xml:1213
#, fuzzy, no-c-format
msgid ""
"For more examples and a complete explanation of a parent/child relationship "
"mapping, see <xref linkend=\"example-parentchild\"/> for more information. "
"Even more complex association mappings are covered in the next chapter."
msgstr ""
"parent/child 関係のマッピングについてのより多くの例や完全な手順が必要であれ"
"ば、 <xref linkend=\"example-parentchild\"/> をご覧ください。"

#~ msgid ""
#~ "Hibernate requires that persistent collection-valued fields be declared "
#~ "as an interface type. For example:"
#~ msgstr ""
#~ "コレクション型のフィールドを永続化するには、そのコレクション型がインター"
#~ "フェース型である必要があります。例えば、"

#~ msgid "Collection mappings"
#~ msgstr "コレクションのマッピング"

#~ msgid ""
#~ "There are quite a range of mappings that can be generated for collections "
#~ "that cover many common relational models. We suggest you experiment with "
#~ "the schema generation tool so that you understand how various mapping "
#~ "declarations translate to database tables."
#~ msgstr ""
#~ "多くの一般的なリレーショナルモデルをカバーしたために、コレクションのために"
#~ "利用できるマッピングにはかなりの幅があります。様々なマッピング宣言がどのよ"
#~ "うにデータベーステーブルに変換されるかを知るために、スキーマ生成ツールを"
#~ "使ってみると良いでしょう。"

#~ msgid "Collection elements"
#~ msgstr "コレクションの要素"

#~ msgid ""
#~ "The contained type is referred to as the <emphasis>collection element "
#~ "type</emphasis>. Collection elements are mapped by <literal>&lt;"
#~ "element&gt;</literal> or <literal>&lt;composite-element&gt;</literal>, or "
#~ "in the case of entity references, with <literal>&lt;one-to-many&gt;</"
#~ "literal> or <literal>&lt;many-to-many&gt;</literal>. The first two map "
#~ "elements with value semantics, the next two are used to map entity "
#~ "associations."
#~ msgstr ""
#~ "格納される型は <emphasis>コレクション要素型</emphasis> と呼ばれます。コレ"
#~ "クション要素は、 <literal>&lt;element&gt;</literal> または <literal>&lt;"
#~ "composite-element&gt;</literal> によりマッピングされ、エンティティへの参照"
#~ "の場合には <literal>&lt;one-to-many&gt;</literal> または <literal>&lt;"
#~ "many-to-many&gt;</literal> によりマッピングされます。最初の二つは値として"
#~ "要素をマッピングし、次の二つはエンティティの関連をマッピングするのに使われ"
#~ "ます。"

#~ msgid ""
#~ "All collection mappings, except those with set and bag semantics, need an "
#~ "<emphasis>index column</emphasis> in the collection table. An index "
#~ "column is a column that maps to an array index, or <literal>List</"
#~ "literal> index, or <literal>Map</literal> key. The index of a "
#~ "<literal>Map</literal> may be of any basic type, mapped with <literal>&lt;"
#~ "map-key&gt;</literal>. It can be an entity reference mapped with "
#~ "<literal>&lt;map-key-many-to-many&gt;</literal>, or it can be a composite "
#~ "type mapped with <literal>&lt;composite-map-key&gt;</literal>. The index "
#~ "of an array or list is always of type <literal>integer</literal> and is "
#~ "mapped using the <literal>&lt;list-index&gt;</literal> element. The "
#~ "mapped column contains sequential integers that are numbered from zero by "
#~ "default."
#~ msgstr ""
#~ "set と bag を除く全てのコレクションマッピングには、コレクションテーブルの"
#~ "中に <emphasis>インデックス用のカラム</emphasis> が必要です。そのカラム"
#~ "に、配列や <literal>List</literal> のインデックス、もしくは <literal>Map</"
#~ "literal> のキーをマッピングします。 <literal>Map</literal> のインデックス"
#~ "は、 <literal>&lt;map-key&gt;</literal> によりマッピングされた基本型か、 "
#~ "<literal>&lt;map-key-many-to-many&gt;</literal> によりマッピングされたエン"
#~ "ティティの関連か、あるいは <literal>&lt;composite-map-key&gt;</literal> に"
#~ "よりマッピングされたコンポジット型になります。配列かリストのインデックス"
#~ "は、常に <literal>integer</literal> 型で、 <literal>&lt;list-index&gt;</"
#~ "literal> 要素によりマッピングします。マッピングされたカラムにはシーケン"
#~ "シャルな整数を格納します （デフォルトでは0から番号が付けられます）。"

#~ msgid ""
#~ "Any collection of values or many-to-many associations requires a "
#~ "dedicated <emphasis>collection table</emphasis> with a foreign key column "
#~ "or columns, <emphasis>collection element column</emphasis> or columns, "
#~ "and possibly an index column or columns."
#~ msgstr ""
#~ "値のコレクションや多対多関連は、専用の <emphasis>コレクションテーブル</"
#~ "emphasis> が必要です。このテーブルは、外部キーカラムと、 <emphasis>コレク"
#~ "ション要素のカラム</emphasis> と、場合によってはインデックスカラムを持ちま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "<literal>column</literal> (optional): the name of the element foreign key "
#~ "column."
#~ msgstr "<literal>class</literal> （必須）: 関連クラスの名前。"

#, fuzzy
#~ msgid ""
#~ "<literal>not-found</literal> (optional - defaults to <literal>exception</"
#~ "literal>): specifies how foreign keys that reference missing rows will be "
#~ "handled: <literal>ignore</literal> will treat a missing row as a null "
#~ "association."
#~ msgstr ""
#~ "<literal>not-found</literal> （オプション - デフォルトは "
#~ "<literal>exception</literal>）: 参照先の行がないキャッシュされた識別子をど"
#~ "のように扱うかを指定します: <literal>ignore</literal> を指定すると、行がな"
#~ "いことを関連がないものとして扱います。"

#~ msgid ""
#~ "A bag containing integers with an iteration order determined by the "
#~ "<literal>order-by</literal> attribute:"
#~ msgstr ""
#~ "整数値を含む bag （bagは <literal>order-by</literal> 属性によって反復順序"
#~ "が定義されています）:"

#~ msgid "An array of entities, in this case, a many-to-many association:"
#~ msgstr "エンティティの配列 - この場合、多対多の関連です。"

#~ msgid "A map from string indices to dates:"
#~ msgstr "文字列と日付の map"

#~ msgid "A list of components (this is discussed in the next chapter):"
#~ msgstr "コンポーネントの list （次の章で詳しく説明します）"

#~ msgid "One-to-many associations"
#~ msgstr "一対多関連"

#~ msgid ""
#~ "A <emphasis>one-to-many association</emphasis> links the tables of two "
#~ "classes via a foreign key with no intervening collection table. This "
#~ "mapping loses certain semantics of normal Java collections:"
#~ msgstr ""
#~ "<emphasis>一対多関連</emphasis> は、コレクションテーブルを介さず、外部キー"
#~ "により2つのクラスのテーブルを関連付けます。このマッピングは標準的な Java "
#~ "のコレクションのセマンティクスをいくつか失います:"

#~ msgid ""
#~ "The following example shows a map of <literal>Part</literal> entities by "
#~ "name, where <literal>partName</literal> is a persistent property of "
#~ "<literal>Part</literal>. Notice the use of a formula-based index:"
#~ msgstr ""
#~ "次の例は、名称（<literal>Part</literal> の永続的なプロパティである "
#~ "<literal>partName</literal>） による <literal>Part</literal> エンティティ"
#~ "の map を表しています。 formula によるインデックスを使っていることに注意し"
#~ "てください。"

#~ msgid ""
#~ "Hibernate supports collections implementing <literal>java.util.SortedMap</"
#~ "literal> and <literal>java.util.SortedSet</literal>. You must specify a "
#~ "comparator in the mapping file:"
#~ msgstr ""
#~ "Hibernate は <literal>java.util.SortedMap</literal> と <literal>java.util."
#~ "SortedSet</literal> を実装したコレクションをサポートしています。開発者は"
#~ "マッピング定義ファイルにコンパレータを指定しなければなりません: "

#~ msgid ""
#~ "A final alternative is to use composite elements, which will be discussed "
#~ "later."
#~ msgstr ""
#~ "最後は composite 要素を使うアプローチです。これに関する議論は後ほど行いま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "Even more complex association mappings are covered in the next chapter."
#~ msgstr ""
#~ "また、さらに特殊な関連マッピングも可能です。次の章で詳しく述べます。"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<set name=\"names\" table=\"person_names\">\n"
#~ "    <key column=\"person_id\"/>\n"
#~ "    <element column=\"person_name\" type=\"string\"/>\n"
#~ "</set>]]>"
#~ msgstr ""
#~ "&lt;set name=\"names\" table=\"person_names\"&gt;\n"
#~ "    &lt;key column=\"person_id\"/&gt;\n"
#~ "    &lt;element column=\"person_name\" type=\"string\"/&gt;\n"
#~ "&lt;/set&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<bag name=\"sizes\" \n"
#~ "        table=\"item_sizes\" \n"
#~ "        order-by=\"size asc\">\n"
#~ "    <key column=\"item_id\"/>\n"
#~ "    <element column=\"size\" type=\"integer\"/>\n"
#~ "</bag>]]>"
#~ msgstr ""
#~ "&lt;bag name=\"sizes\" \n"
#~ "        table=\"item_sizes\" \n"
#~ "        order-by=\"size asc\"&gt;\n"
#~ "    &lt;key column=\"item_id\"/&gt;\n"
#~ "    &lt;element column=\"size\" type=\"integer\"/&gt;\n"
#~ "&lt;/bag&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<array name=\"addresses\" \n"
#~ "        table=\"PersonAddress\" \n"
#~ "        cascade=\"persist\">\n"
#~ "    <key column=\"personId\"/>\n"
#~ "    <list-index column=\"sortOrder\"/>\n"
#~ "    <many-to-many column=\"addressId\" class=\"Address\"/>\n"
#~ "</array>]]>"
#~ msgstr ""
#~ "&lt;array name=\"addresses\" \n"
#~ "        table=\"PersonAddress\" \n"
#~ "        cascade=\"persist\"&gt;\n"
#~ "    &lt;key column=\"personId\"/&gt;\n"
#~ "    &lt;list-index column=\"sortOrder\"/&gt;\n"
#~ "    &lt;many-to-many column=\"addressId\" class=\"Address\"/&gt;\n"
#~ "&lt;/array&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<map name=\"holidays\" \n"
#~ "        table=\"holidays\" \n"
#~ "        schema=\"dbo\" \n"
#~ "        order-by=\"hol_name asc\">\n"
#~ "    <key column=\"id\"/>\n"
#~ "    <map-key column=\"hol_name\" type=\"string\"/>\n"
#~ "    <element column=\"hol_date\" type=\"date\"/>\n"
#~ "</map>]]>"
#~ msgstr ""
#~ "&lt;map name=\"holidays\" \n"
#~ "        table=\"holidays\" \n"
#~ "        schema=\"dbo\" \n"
#~ "        order-by=\"hol_name asc\"&gt;\n"
#~ "    &lt;key column=\"id\"/&gt;\n"
#~ "    &lt;map-key column=\"hol_name\" type=\"string\"/&gt;\n"
#~ "    &lt;element column=\"hol_date\" type=\"date\"/&gt;\n"
#~ "&lt;/map&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<list name=\"carComponents\" \n"
#~ "        table=\"CarComponents\">\n"
#~ "    <key column=\"carId\"/>\n"
#~ "    <list-index column=\"sortOrder\"/>\n"
#~ "    <composite-element class=\"CarComponent\">\n"
#~ "        <property name=\"price\"/>\n"
#~ "        <property name=\"type\"/>\n"
#~ "        <property name=\"serialNumber\" column=\"serialNum\"/>\n"
#~ "    </composite-element>\n"
#~ "</list>]]>"
#~ msgstr ""
#~ "&lt;list name=\"carComponents\" \n"
#~ "        table=\"CarComponents\"&gt;\n"
#~ "    &lt;key column=\"carId\"/&gt;\n"
#~ "    &lt;list-index column=\"sortOrder\"/&gt;\n"
#~ "    &lt;composite-element class=\"CarComponent\"&gt;\n"
#~ "        &lt;property name=\"price\"/&gt;\n"
#~ "        &lt;property name=\"type\"/&gt;\n"
#~ "        &lt;property name=\"serialNumber\" column=\"serialNum\"/&gt;\n"
#~ "    &lt;/composite-element&gt;\n"
#~ "&lt;/list&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<map name=\"parts\"\n"
#~ "        cascade=\"all\">\n"
#~ "    <key column=\"productId\" not-null=\"true\"/>\n"
#~ "    <map-key formula=\"partName\"/>\n"
#~ "    <one-to-many class=\"Part\"/>\n"
#~ "</map>]]>"
#~ msgstr ""
#~ "&lt;map name=\"parts\"\n"
#~ "        cascade=\"all\"&gt;\n"
#~ "    &lt;key column=\"productId\" not-null=\"true\"/&gt;\n"
#~ "    &lt;map-key formula=\"partName\"/&gt;\n"
#~ "    &lt;one-to-many class=\"Part\"/&gt;\n"
#~ "&lt;/map&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<map name=\"contracts\">\n"
#~ "    <key column=\"employer_id\" not-null=\"true\"/>\n"
#~ "    <map-key-many-to-many column=\"employee_id\" class=\"Employee\"/>\n"
#~ "    <one-to-many class=\"Contract\"/>\n"
#~ "</map>]]>"
#~ msgstr ""
#~ "&lt;map name=\"contracts\"&gt;\n"
#~ "    &lt;key column=\"employer_id\" not-null=\"true\"/&gt;\n"
#~ "    &lt;map-key-many-to-many column=\"employee_id\" class=\"Employee\"/"
#~ "&gt;\n"
#~ "    &lt;one-to-many class=\"Contract\"/&gt;\n"
#~ "&lt;/map&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<map name=\"connections\">\n"
#~ "    <key column=\"incoming_node_id\"/>\n"
#~ "    <map-key-many-to-many column=\"outgoing_node_id\" class=\"Node\"/>\n"
#~ "    <many-to-many column=\"connection_id\" class=\"Connection\"/>\n"
#~ "</map>]]>"
#~ msgstr ""
#~ "&lt;map name=\"connections\"&gt;\n"
#~ "    &lt;key column=\"incoming_node_id\"/&gt;\n"
#~ "    &lt;map-key-many-to-many column=\"outgoing_node_id\" class=\"Node\"/"
#~ "&gt;\n"
#~ "    &lt;many-to-many column=\"connection_id\" class=\"Connection\"/&gt;\n"
#~ "&lt;/map&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[package eg;\n"
#~ "import java.util.Set;\n"
#~ "\n"
#~ "public class Parent {\n"
#~ "    private long id;\n"
#~ "    private Set children;\n"
#~ "\n"
#~ "    public long getId() { return id; }\n"
#~ "    private void setId(long id) { this.id=id; }\n"
#~ "\n"
#~ "    private Set getChildren() { return children; }\n"
#~ "    private void setChildren(Set children) { this.children=children; }\n"
#~ "\n"
#~ "    ....\n"
#~ "    ....\n"
#~ "}]]>"
#~ msgstr ""
#~ "package eg;\n"
#~ "import java.util.Set;\n"
#~ "\n"
#~ "public class Parent {\n"
#~ "    private long id;\n"
#~ "    private Set children;\n"
#~ "\n"
#~ "    public long getId() { return id; }\n"
#~ "    private void setId(long id) { this.id=id; }\n"
#~ "\n"
#~ "    private Set getChildren() { return children; }\n"
#~ "    private void setChildren(Set children) { this.children=children; }\n"
#~ "\n"
#~ "    ....\n"
#~ "    ....\n"
#~ "}"
