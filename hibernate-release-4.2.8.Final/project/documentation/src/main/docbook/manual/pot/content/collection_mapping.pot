# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-20 21:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-xml2pot; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: collection_mapping.xml:31
#, no-c-format
msgid "Collection mapping"
msgstr ""

#. Tag: title
#: collection_mapping.xml:34
#, no-c-format
msgid "Persistent collections"
msgstr ""

#. Tag: para
#: collection_mapping.xml:36
#, no-c-format
msgid "Naturally Hibernate also allows to persist collections. These persistent collections can contain almost any other Hibernate type, including: basic types, custom types, components and references to other entities. The distinction between value and reference semantics is in this context very important. An object in a collection might be handled with \"value\" semantics (its life cycle fully depends on the collection owner), or it might be a reference to another entity with its own life cycle. In the latter case, only the \"link\" between the two objects is considered to be a state held by the collection."
msgstr ""

#. Tag: para
#: collection_mapping.xml:46
#, no-c-format
msgid "As a requirement persistent collection-valued fields must be declared as an interface type (see <xref linkend=\"example.collection.mapping.annotations\"/>). The actual interface might be <literal>java.util.Set</literal>, <literal>java.util.Collection</literal>, <literal>java.util.List</literal>, <literal>java.util.Map</literal>, <literal>java.util.SortedSet</literal>, <literal>java.util.SortedMap</literal> or anything you like (\"anything you like\" means you will have to write an implementation of <literal>org.hibernate.usertype.UserCollectionType</literal>)."
msgstr ""

#. Tag: para
#: collection_mapping.xml:57
#, no-c-format
msgid "Notice how in <xref linkend=\"example.collection.mapping.annotations\"/> the instance variable <literal>parts</literal> was initialized with an instance of <literal>HashSet</literal>. This is the best way to initialize collection valued properties of newly instantiated (non-persistent) instances. When you make the instance persistent, by calling <literal>persist()</literal>, Hibernate will actually replace the <literal>HashSet</literal> with an instance of Hibernate's own implementation of <literal>Set</literal>. Be aware of the following error:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:68
#, no-c-format
msgid "Hibernate uses its own collection implementations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:70
#, no-c-format
msgid ""
      "Cat cat = new DomesticCat();\n"
      "Cat kitten = new DomesticCat();\n"
      "....\n"
      "Set kittens = new HashSet();\n"
      "kittens.add(kitten);\n"
      "cat.setKittens(kittens);\n"
      "session.persist(cat);\n"
      "\n"
      "kittens = cat.getKittens(); // Okay, kittens collection is a Set\n"
      "(HashSet) cat.getKittens(); // Error!"
msgstr ""

#. Tag: para
#: collection_mapping.xml:73
#, no-c-format
msgid "The persistent collections injected by Hibernate behave like <literal>HashMap</literal>, <literal>HashSet</literal>, <literal>TreeMap</literal>, <literal>TreeSet</literal> or <literal>ArrayList</literal>, depending on the interface type."
msgstr ""

#. Tag: para
#: collection_mapping.xml:78
#, no-c-format
msgid "Collections instances have the usual behavior of value types. They are automatically persisted when referenced by a persistent object and are automatically deleted when unreferenced. If a collection is passed from one persistent object to another, its elements might be moved from one table to another. Two entities cannot share a reference to the same collection instance. Due to the underlying relational model, collection-valued properties do not support null value semantics. Hibernate does not distinguish between a null collection reference and an empty collection."
msgstr ""

#. Tag: para
#: collection_mapping.xml:89
#, no-c-format
msgid "Use persistent collections the same way you use ordinary Java collections. However, ensure you understand the semantics of bidirectional associations (see <xref linkend=\"collections-bidirectional\"/>)."
msgstr ""

#. Tag: title
#: collection_mapping.xml:97
#, no-c-format
msgid "How to map collections"
msgstr ""

#. Tag: para
#: collection_mapping.xml:99
#, no-c-format
msgid "Using annotations you can map <classname>Collection</classname>s, <classname>List</classname>s, <classname>Map</classname>s and <classname>Set</classname>s of associated entities using @OneToMany and @ManyToMany. For collections of a basic or embeddable type use @ElementCollection. In the simplest case a collection mapping looks like this:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:107
#, no-c-format
msgid "Collection mapping using @OneToMany and @JoinColumn"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:109
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Product {\n"
      "\n"
      "    private String serialNumber;\n"
      "    private Set&lt;Part&gt; parts = new HashSet&lt;Part&gt;();\n"
      "\n"
      "    @Id\n"
      "    public String getSerialNumber() { return serialNumber; }\n"
      "    void setSerialNumber(String sn) { serialNumber = sn; }\n"
      "   \n"
      "    @OneToMany\n"
      "    @JoinColumn(name=\"PART_ID\")\n"
      "    public Set&lt;Part&gt; getParts() { return parts; }\n"
      "    void setParts(Set parts) { this.parts = parts; }\n"
      "}\n"
      "\n"
      "\n"
      "@Entity\n"
      "public class Part {\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:112
#, no-c-format
msgid "Product describes a unidirectional relationship with Part using the join column PART_ID. In this unidirectional one to many scenario you can also use a join table as seen in <xref linkend=\"example-one-to-many-with-join-table\"/>."
msgstr ""

#. Tag: title
#: collection_mapping.xml:118
#, no-c-format
msgid "Collection mapping using @OneToMany and @JoinTable"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:121
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Product {\n"
      "\n"
      "    private String serialNumber;\n"
      "    private Set&lt;Part&gt; parts = new HashSet&lt;Part&gt;();\n"
      "\n"
      "    @Id\n"
      "    public String getSerialNumber() { return serialNumber; }\n"
      "    void setSerialNumber(String sn) { serialNumber = sn; }\n"
      "   \n"
      "    @OneToMany\n"
      "    @JoinTable(\n"
      "            name=\"PRODUCT_PARTS\",\n"
      "            joinColumns = @JoinColumn( name=\"PRODUCT_ID\"),\n"
      "            inverseJoinColumns = @JoinColumn( name=\"PART_ID\")\n"
      "    )\n"
      "    public Set&lt;Part&gt; getParts() { return parts; }\n"
      "    void setParts(Set parts) { this.parts = parts; }\n"
      "}\n"
      "\n"
      "\n"
      "@Entity\n"
      "public class Part {\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:124
#, no-c-format
msgid "Without describing any physical mapping (no <classname>@JoinColumn</classname> or <classname>@JoinTable</classname>), a unidirectional one to many with join table is used. The table name is the concatenation of the owner table name, _, and the other side table name. The foreign key name(s) referencing the owner table is the concatenation of the owner table, _, and the owner primary key column(s) name. The foreign key name(s) referencing the other side is the concatenation of the owner property name, _, and the other side primary key column(s) name. A unique constraint is added to the foreign key referencing the other side table to reflect the one to many."
msgstr ""

#. Tag: para
#: collection_mapping.xml:135
#, no-c-format
msgid "Lets have a look now how collections are mapped using Hibernate mapping files. In this case the first step is to chose the right mapping element. It depends on the type of interface. For example, a <literal>&lt;set&gt;</literal> element is used for mapping properties of type <literal>Set</literal>."
msgstr ""

#. Tag: title
#: collection_mapping.xml:142
#, no-c-format
msgid "Mapping a Set using &lt;set&gt;"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:144
#, no-c-format
msgid ""
      "&lt;class name=\"Product\"&gt;\n"
      "    &lt;id name=\"serialNumber\" column=\"productSerialNumber\"/&gt;\n"
      "    &lt;set name=\"parts\"&gt;\n"
      "        &lt;key column=\"productSerialNumber\" not-null=\"true\"/&gt;\n"
      "        &lt;one-to-many class=\"Part\"/&gt;\n"
      "    &lt;/set&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:147
#, no-c-format
msgid "In <xref linkend=\"example.collections.set\"/> a <emphasis>one-to-many association</emphasis> links the <literal>Product</literal> and <literal>Part</literal> entities. This association requires the existence of a foreign key column and possibly an index column to the <literal>Part</literal> table. This mapping loses certain semantics of normal Java collections:"
msgstr ""

#. Tag: para
#: collection_mapping.xml:156
#, no-c-format
msgid "An instance of the contained entity class cannot belong to more than one instance of the collection."
msgstr ""

#. Tag: para
#: collection_mapping.xml:161
#, no-c-format
msgid "An instance of the contained entity class cannot appear at more than one value of the collection index."
msgstr ""

#. Tag: para
#: collection_mapping.xml:166
#, no-c-format
msgid "Looking closer at the used <literal>&lt;one-to-many&gt;</literal> tag we see that it has the following options."
msgstr ""

#. Tag: title
#: collection_mapping.xml:170
#, no-c-format
msgid "options of &lt;one-to-many&gt; element"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:181
#, no-c-format
msgid ""
      "&lt;one-to-many\n"
      "        class=\"ClassName\"\n"
      "        not-found=\"ignore|exception\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"\n"
      "        embed-xml=\"true|false\"\n"
      "    /&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:185
#, no-c-format
msgid "<literal>class</literal> (required): the name of the associated class."
msgstr ""

#. Tag: para
#: collection_mapping.xml:190
#, no-c-format
msgid "<literal>not-found</literal> (optional - defaults to <literal>exception</literal>): specifies how cached identifiers that reference missing rows will be handled. <literal>ignore</literal> will treat a missing row as a null association."
msgstr ""

#. Tag: para
#: collection_mapping.xml:198
#, no-c-format
msgid "<literal>entity-name</literal> (optional): the entity name of the associated class, as an alternative to <literal>class</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:206
#, no-c-format
msgid "The <literal>&lt;one-to-many&gt;</literal> element does not need to declare any columns. Nor is it necessary to specify the <literal>table</literal> name anywhere."
msgstr ""

#. Tag: para
#: collection_mapping.xml:211
#, no-c-format
msgid "If the foreign key column of a <literal>&lt;one-to-many&gt;</literal> association is declared <literal>NOT NULL</literal>, you must declare the <literal>&lt;key&gt;</literal> mapping <literal>not-null=\"true\"</literal> or <emphasis>use a bidirectional association</emphasis> with the collection mapping marked <literal>inverse=\"true\"</literal>. See <xref linkend=\"collections-bidirectional\"/>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:221
#, no-c-format
msgid "Apart from the <literal>&lt;set&gt; </literal>tag as shown in <xref linkend=\"example.collections.set\"/>, there is also <literal>&lt;list&gt;</literal>, <literal>&lt;map&gt;</literal>, <literal>&lt;bag&gt;</literal>, <literal>&lt;array&gt;</literal> and <literal>&lt;primitive-array&gt;</literal> mapping elements. The <literal>&lt;map&gt;</literal> element is representative:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:229
#, no-c-format
msgid "Elements of the &lt;map&gt; mapping"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:262
#, no-c-format
msgid ""
      "&lt;map\n"
      "    name=\"propertyName\"\n"
      "    table=\"table_name\"\n"
      "    schema=\"schema_name\"\n"
      "    lazy=\"true|extra|false\"\n"
      "    inverse=\"true|false\"\n"
      "    cascade=\"all|none|save-update|delete|all-delete-orphan|delete-orphan\"\n"
      "    sort=\"unsorted|natural|comparatorClass\"\n"
      "    order-by=\"column_name asc|desc\"\n"
      "    where=\"arbitrary sql where condition\"\n"
      "    fetch=\"join|select|subselect\"\n"
      "    batch-size=\"N\"\n"
      "    access=\"field|property|ClassName\"\n"
      "    optimistic-lock=\"true|false\"\n"
      "    mutable=\"true|false\"\n"
      "    node=\"element-name|.\"\n"
      "    embed-xml=\"true|false\"\n"
      "&gt;\n"
      "\n"
      "    &lt;key .... /&gt;\n"
      "    &lt;map-key .... /&gt;\n"
      "    &lt;element .... /&gt;\n"
      "&lt;/map&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:266
#, no-c-format
msgid "<literal>name</literal>: the collection property name"
msgstr ""

#. Tag: para
#: collection_mapping.xml:270
#, no-c-format
msgid "<literal>table</literal> (optional - defaults to property name): the name of the collection table. It is not used for one-to-many associations."
msgstr ""

#. Tag: para
#: collection_mapping.xml:276
#, no-c-format
msgid "<literal>schema</literal> (optional): the name of a table schema to override the schema declared on the root element"
msgstr ""

#. Tag: para
#: collection_mapping.xml:281
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>true</literal>): disables lazy fetching and specifies that the association is always eagerly fetched. It can also be used to enable \"extra-lazy\" fetching where most operations do not initialize the collection. This is suitable for large collections."
msgstr ""

#. Tag: para
#: collection_mapping.xml:290
#, no-c-format
msgid "<literal>inverse</literal> (optional - defaults to <literal>false</literal>): marks this collection as the \"inverse\" end of a bidirectional association."
msgstr ""

#. Tag: para
#: collection_mapping.xml:296
#, no-c-format
msgid "<literal>cascade</literal> (optional - defaults to <literal>none</literal>): enables operations to cascade to child entities."
msgstr ""

#. Tag: para
#: collection_mapping.xml:302
#, no-c-format
msgid "<literal>sort</literal> (optional): specifies a sorted collection with <literal>natural</literal> sort order or a given comparator class."
msgstr ""

#. Tag: para
#: collection_mapping.xml:308
#, no-c-format
msgid "<literal>order-by</literal> (optional): specifies a table column or columns that define the iteration order of the <literal>Map</literal>, <literal>Set</literal> or bag, together with an optional <literal>asc</literal> or <literal>desc</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:316
#, no-c-format
msgid "<literal>where</literal> (optional): specifies an arbitrary SQL <literal>WHERE</literal> condition that is used when retrieving or removing the collection. This is useful if the collection needs to contain only a subset of the available data."
msgstr ""

#. Tag: para
#: collection_mapping.xml:324
#, no-c-format
msgid "<literal>fetch</literal> (optional, defaults to <literal>select</literal>): chooses between outer-join fetching, fetching by sequential select, and fetching by sequential subselect."
msgstr ""

#. Tag: para
#: collection_mapping.xml:331
#, no-c-format
msgid "<literal>batch-size</literal> (optional, defaults to <literal>1</literal>): specifies a \"batch size\" for lazily fetching instances of this collection."
msgstr ""

#. Tag: para
#: collection_mapping.xml:337
#, no-c-format
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate uses for accessing the collection property value."
msgstr ""

#. Tag: para
#: collection_mapping.xml:343
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that changes to the state of the collection results in increments of the owning entity's version. For one-to-many associations you may want to disable this setting."
msgstr ""

#. Tag: para
#: collection_mapping.xml:351
#, no-c-format
msgid "<literal>mutable</literal> (optional - defaults to <literal>true</literal>): a value of <literal>false</literal> specifies that the elements of the collection never change. This allows for minor performance optimization in some cases."
msgstr ""

#. Tag: para
#: collection_mapping.xml:360
#, no-c-format
msgid "After exploring the basic mapping of collections in the preceding paragraphs we will now focus details like physical mapping considerations, indexed collections and collections of value types."
msgstr ""

#. Tag: title
#: collection_mapping.xml:365
#, no-c-format
msgid "Collection foreign keys"
msgstr ""

#. Tag: para
#: collection_mapping.xml:367
#, no-c-format
msgid "On the database level collection instances are distinguished by the foreign key of the entity that owns the collection. This foreign key is referred to as the <emphasis>collection key column</emphasis>, or columns, of the collection table. The collection key column is mapped by the <literal>@JoinColumn</literal> annotation respectively the <literal>&lt;key&gt;</literal> XML element."
msgstr ""

#. Tag: para
#: collection_mapping.xml:374
#, no-c-format
msgid "There can be a nullability constraint on the foreign key column. For most collections, this is implied. For unidirectional one-to-many associations, the foreign key column is nullable by default, so you may need to specify"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:379
#, no-c-format
msgid "@JoinColumn(nullable=false)"
msgstr ""

#. Tag: para
#: collection_mapping.xml:381
#, no-c-format
msgid "<para>or</para>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:383
#, no-c-format
msgid "&lt;key column=\"productSerialNumber\" not-null=\"true\"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:385
#, no-c-format
msgid "The foreign key constraint can use <literal>ON DELETE CASCADE</literal>. In XML this can be expressed via:"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:388
#, no-c-format
msgid "&lt;key column=\"productSerialNumber\" on-delete=\"cascade\"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:390
#, no-c-format
msgid "In annotations the Hibernate specific annotation @OnDelete has to be used."
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:393
#, no-c-format
msgid "@OnDelete(action=OnDeleteAction.CASCADE)"
msgstr ""

#. Tag: para
#: collection_mapping.xml:395
#, no-c-format
msgid "See <xref lang=\"\" linkend=\"section.key\"/> for more information about the <literal>&lt;key&gt;</literal> element."
msgstr ""

#. Tag: title
#: collection_mapping.xml:400
#, no-c-format
msgid "Indexed collections"
msgstr ""

#. Tag: para
#: collection_mapping.xml:402
#, no-c-format
msgid "In the following paragraphs we have a closer at the indexed collections <classname>List</classname> and <classname>Map</classname> how the their index can be mapped in Hibernate."
msgstr ""

#. Tag: title
#: collection_mapping.xml:407
#, no-c-format
msgid "Lists"
msgstr ""

#. Tag: para
#: collection_mapping.xml:409
#, no-c-format
msgid "Lists can be mapped in two different ways:"
msgstr ""

#. Tag: para
#: collection_mapping.xml:413
#, no-c-format
msgid "as ordered lists, where the order is not materialized in the database"
msgstr ""

#. Tag: para
#: collection_mapping.xml:418
#, no-c-format
msgid "as indexed lists, where the order is materialized in the database"
msgstr ""

#. Tag: para
#: collection_mapping.xml:423
#, no-c-format
msgid "To order lists in memory, add <literal>@javax.persistence.OrderBy</literal> to your property. This annotation takes as parameter a list of comma separated properties (of the target entity) and orders the collection accordingly (eg <code>firstname asc, age desc</code>), if the string is empty, the collection will be ordered by the primary key of the target entity."
msgstr ""

#. Tag: title
#: collection_mapping.xml:432
#, no-c-format
msgid "Ordered lists using <classname>@OrderBy</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:434
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Customer {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   @OneToMany(mappedBy=\"customer\")\n"
      "   @OrderBy(\"number\")\n"
      "   public List&lt;Order&gt; getOrders() { return orders; }\n"
      "   public void setOrders(List&lt;Order&gt; orders) { this.orders = orders; }\n"
      "   private List&lt;Order&gt; orders;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Order {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   public String getNumber() { return number; }\n"
      "   public void setNumber(String number) { this.number = number; }\n"
      "   private String number;\n"
      "\n"
      "   @ManyToOne\n"
      "   public Customer getCustomer() { return customer; }\n"
      "   public void setCustomer(Customer customer) { this.customer = customer; }\n"
      "   private Customer number;\n"
      "}\n"
      "\n"
      "-- Table schema\n"
      "|-------------| |----------|\n"
      "| Order       | | Customer |\n"
      "|-------------| |----------|\n"
      "| id          | | id       |\n"
      "| number      | |----------| \n"
      "| customer_id |\n"
      "|-------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:437
#, no-c-format
msgid "To store the index value in a dedicated column, use the <classname>@javax.persistence.OrderColumn</classname> annotation on your property. This annotations describes the column name and attributes of the column keeping the index value. This column is hosted on the table containing the association foreign key. If the column name is not specified, the default is the name of the referencing property, followed by underscore, followed by <literal>ORDER</literal> (in the following example, it would be <literal>orders_ORDER</literal>)."
msgstr ""

#. Tag: title
#: collection_mapping.xml:448
#, no-c-format
msgid "Explicit index column using <classname>@OrderColumn</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:451
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Customer {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   @OneToMany(mappedBy=\"customer\")\n"
      "   @OrderColumn(name=\"orders_index\")\n"
      "   public List&lt;Order&gt; getOrders() { return orders; }\n"
      "   public void setOrders(List&lt;Order&gt; orders) { this.orders = orders; }\n"
      "   private List&lt;Order&gt; orders;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Order {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   public String getNumber() { return number; }\n"
      "   public void setNumber(String number) { this.number = number; }\n"
      "   private String number;\n"
      "\n"
      "   @ManyToOne\n"
      "   public Customer getCustomer() { return customer; }\n"
      "   public void setCustomer(Customer customer) { this.customer = customer; }\n"
      "   private Customer number;\n"
      "}\n"
      "\n"
      "-- Table schema\n"
      "|--------------| |----------|\n"
      "| Order        | | Customer |\n"
      "|--------------| |----------|\n"
      "| id           | | id       |\n"
      "| number       | |----------| \n"
      "| customer_id  |\n"
      "| orders_order |\n"
      "|--------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:455
#, no-c-format
msgid "We recommend you to convert <classname>the legacy @org.hibernate.annotations.IndexColumn</classname> usages to <classname>@OrderColumn</classname> unless you are making use of the base property. The <literal>base</literal> property lets you define the index value of the first element (aka as base index). The usual value is <literal>0</literal> or <literal>1</literal>. The default is 0 like in Java."
msgstr ""

#. Tag: para
#: collection_mapping.xml:464
#, no-c-format
msgid "Looking again at the Hibernate mapping file equivalent, the index of an array or list is always of type <literal>integer</literal> and is mapped using the <literal>&lt;list-index&gt;</literal> element. The mapped column contains sequential integers that are numbered from zero by default."
msgstr ""

#. Tag: title
#: collection_mapping.xml:471
#, no-c-format
msgid "index-list element for indexed collections in xml mapping"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:481
#, no-c-format
msgid ""
      "&lt;list-index\n"
      "        column=\"column_name\"\n"
      "        base=\"0|1|...\"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:485
#, no-c-format
msgid "<literal>column_name</literal> (required): the name of the column holding the collection index values."
msgstr ""

#. Tag: para
#: collection_mapping.xml:490
#, no-c-format
msgid "<literal>base</literal> (optional - defaults to <literal>0</literal>): the value of the index column that corresponds to the first element of the list or array."
msgstr ""

#. Tag: para
#: collection_mapping.xml:498
#, no-c-format
msgid "If your table does not have an index column, and you still wish to use <literal>List</literal> as the property type, you can map the property as a Hibernate <emphasis>&lt;bag&gt;</emphasis>. A bag does not retain its order when it is retrieved from the database, but it can be optionally sorted or ordered."
msgstr ""

#. Tag: title
#: collection_mapping.xml:506
#, no-c-format
msgid "Maps"
msgstr ""

#. Tag: para
#: collection_mapping.xml:508
#, no-c-format
msgid "The question with <classname>Map</classname>s is where the key value is stored. There are everal options. Maps can borrow their keys from one of the associated entity properties or have dedicated columns to store an explicit key."
msgstr ""

#. Tag: para
#: collection_mapping.xml:513
#, no-c-format
msgid "To use one of the target entity property as a key of the map, use <literal>@MapKey(name=\"myProperty\")</literal>, where <literal>myProperty</literal> is a property name in the target entity. When using <literal>@MapKey</literal> without the name attribuate, the target entity primary key is used. The map key uses the same column as the property pointed out. There is no additional column defined to hold the map key, because the map key represent a target property. Be aware that once loaded, the key is no longer kept in sync with the property. In other words, if you change the property value, the key will not change automatically in your Java model."
msgstr ""

#. Tag: title
#: collection_mapping.xml:525
#, no-c-format
msgid "Use of target entity property as map key via <classname>@MapKey</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:528
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Customer {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   @OneToMany(mappedBy=\"customer\")\n"
      "   @MapKey(name=\"number\")\n"
      "   public Map&lt;String,Order&gt; getOrders() { return orders; }\n"
      "   public void setOrders(Map&lt;String,Order&gt; order) { this.orders = orders; }\n"
      "   private Map&lt;String,Order&gt; orders;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Order {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   public String getNumber() { return number; }\n"
      "   public void setNumber(String number) { this.number = number; }\n"
      "   private String number;\n"
      "\n"
      "   @ManyToOne\n"
      "   public Customer getCustomer() { return customer; }\n"
      "   public void setCustomer(Customer customer) { this.customer = customer; }\n"
      "   private Customer number;\n"
      "}\n"
      "\n"
      "-- Table schema\n"
      "|-------------| |----------|\n"
      "| Order       | | Customer |\n"
      "|-------------| |----------|\n"
      "| id          | | id       |\n"
      "| number      | |----------| \n"
      "| customer_id |\n"
      "|-------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:531
#, no-c-format
msgid "Alternatively the map key is mapped to a dedicated column or columns. In order to customize the mapping use one of the following annotations:"
msgstr ""

#. Tag: para
#: collection_mapping.xml:537
#, no-c-format
msgid "@<classname>MapKeyColumn</classname> if the map key is a basic type. If you don't specify the column name, the name of the property followed by underscore followed by <literal>KEY</literal> is used (for example <literal>orders_KEY</literal>)."
msgstr ""

#. Tag: para
#: collection_mapping.xml:544
#, no-c-format
msgid "<classname>@MapKeyEnumerated</classname> / <classname>@MapKeyTemporal</classname> if the map key type is respectively an enum or a <classname>Date</classname>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:550
#, no-c-format
msgid "<classname>@MapKeyJoinColumn</classname>/<classname>@MapKeyJoinColumns</classname> if the map key type is another entity."
msgstr ""

#. Tag: para
#: collection_mapping.xml:555
#, no-c-format
msgid "<classname>@AttributeOverride</classname>/<classname>@AttributeOverrides</classname> when the map key is a embeddable object. Use <literal>key.</literal> as a prefix for your embeddable object property names."
msgstr ""

#. Tag: para
#: collection_mapping.xml:562
#, no-c-format
msgid "You can also use <classname>@MapKeyClass</classname> to define the type of the key if you don't use generics."
msgstr ""

#. Tag: title
#: collection_mapping.xml:566
#, no-c-format
msgid "Map key as basic type using <classname>@MapKeyColumn</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:569
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Customer {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   @OneToMany @JoinTable(name=\"Cust_Order\")\n"
      "   @MapKeyColumn(name=\"orders_number\")\n"
      "   public Map&lt;String,Order&gt; getOrders() { return orders; }\n"
      "   public void setOrders(Map&lt;String,Order&gt; orders) { this.orders = orders; }\n"
      "   private Map&lt;String,Order&gt; orders;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Order {\n"
      "   @Id @GeneratedValue public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   public String getNumber() { return number; }\n"
      "   public void setNumber(String number) { this.number = number; }\n"
      "   private String number;\n"
      "\n"
      "   @ManyToOne\n"
      "   public Customer getCustomer() { return customer; }\n"
      "   public void setCustomer(Customer customer) { this.customer = customer; }\n"
      "   private Customer number;\n"
      "}\n"
      "\n"
      "-- Table schema\n"
      "|-------------| |----------| |---------------|\n"
      "| Order       | | Customer | | Cust_Order    |\n"
      "|-------------| |----------| |---------------|\n"
      "| id          | | id       | | customer_id   |\n"
      "| number      | |----------| | order_id      |\n"
      "| customer_id |              | orders_number |\n"
      "|-------------|              |---------------|"
msgstr ""

#. Tag: para
#: collection_mapping.xml:573
#, no-c-format
msgid "We recommend you to migrate from <classname>@org.hibernate.annotations.MapKey</classname> / <classname>@org.hibernate.annotation.MapKeyManyToMany</classname> to the new standard approach described above"
msgstr ""

#. Tag: para
#: collection_mapping.xml:579
#, no-c-format
msgid "Using Hibernate mapping files there exists equivalent concepts to the descibed annotations. You have to use <literal>&lt;map-key&gt;</literal>, <literal>&lt;map-key-many-to-many&gt;</literal> and <literal>&lt;composite-map-key&gt;</literal>. <literal>&lt;map-key&gt;</literal> is used for any basic type, <literal>&lt;map-key-many-to-many&gt;</literal> for an entity reference and <literal>&lt;composite-map-key&gt;</literal> for a composite type."
msgstr ""

#. Tag: title
#: collection_mapping.xml:590
#, no-c-format
msgid "map-key xml mapping element"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:601
#, no-c-format
msgid ""
      "&lt;map-key\n"
      "        column=\"column_name\"\n"
      "        formula=\"any SQL expression\"\n"
      "        type=\"type_name\"\n"
      "        node=\"@attribute-name\"\n"
      "        length=\"N\"/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:605
#, no-c-format
msgid "<literal>column</literal> (optional): the name of the column holding the collection index values."
msgstr ""

#. Tag: para
#: collection_mapping.xml:610
#, no-c-format
msgid "<literal>formula</literal> (optional): a SQL formula used to evaluate the key of the map."
msgstr ""

#. Tag: para
#: collection_mapping.xml:615
#, no-c-format
msgid "<literal>type</literal> (required): the type of the map keys."
msgstr ""

#. Tag: title
#: collection_mapping.xml:623
#, no-c-format
msgid "map-key-many-to-many"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:634
#, no-c-format
msgid ""
      "&lt;map-key-many-to-many\n"
      "        column=\"column_name\"\n"
      "        formula=\"any SQL expression\"\n"
      "        class=\"ClassName\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:638
#, no-c-format
msgid "<literal>column</literal> (optional): the name of the foreign key column for the collection index values."
msgstr ""

#. Tag: para
#: collection_mapping.xml:643
#, no-c-format
msgid "<literal>formula</literal> (optional): a SQ formula used to evaluate the foreign key of the map key."
msgstr ""

#. Tag: para
#: collection_mapping.xml:648
#, no-c-format
msgid "<literal>class</literal> (required): the entity class used as the map key."
msgstr ""

#. Tag: title
#: collection_mapping.xml:658
#, no-c-format
msgid "Collections of basic types and embeddable objects"
msgstr ""

#. Tag: para
#: collection_mapping.xml:660
#, no-c-format
msgid "In some situations you don't need to associate two entities but simply create a collection of basic types or embeddable objects. Use the <classname>@ElementCollection</classname> for this case."
msgstr ""

#. Tag: title
#: collection_mapping.xml:665
#, no-c-format
msgid "Collection of basic types mapped via <classname>@ElementCollection</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:668
#, no-c-format
msgid ""
      "@Entity\n"
      "public class User {\n"
      "   [...]\n"
      "   public String getLastname() { ...}\n"
      "\n"
      "   @ElementCollection\n"
      "   @CollectionTable(name=\"Nicknames\", joinColumns=@JoinColumn(name=\"user_id\"))\n"
      "   @Column(name=\"nickname\")\n"
      "   public Set&lt;String&gt; getNicknames() { ... } \n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:671
#, no-c-format
msgid "The collection table holding the collection data is set using the <classname>@CollectionTable</classname> annotation. If omitted the collection table name defaults to the concatenation of the name of the containing entity and the name of the collection attribute, separated by an underscore. In our example, it would be <literal>User_nicknames</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:678
#, no-c-format
msgid "The column holding the basic type is set using the <classname>@Column</classname> annotation. If omitted, the column name defaults to the property name: in our example, it would be <literal>nicknames</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:683
#, no-c-format
msgid "But you are not limited to basic types, the collection type can be any embeddable object. To override the columns of the embeddable object in the collection table, use the <classname>@AttributeOverride</classname> annotation."
msgstr ""

#. Tag: title
#: collection_mapping.xml:689
#, no-c-format
msgid "@ElementCollection for embeddable objects"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:691
#, no-c-format
msgid ""
      "@Entity\n"
      "public class User {\n"
      "   [...]\n"
      "   public String getLastname() { ...}\n"
      "\n"
      "   @ElementCollection\n"
      "   @CollectionTable(name=\"Addresses\", joinColumns=@JoinColumn(name=\"user_id\"))\n"
      "   @AttributeOverrides({\n"
      "      @AttributeOverride(name=\"street1\", column=@Column(name=\"fld_street\"))\n"
      "   })\n"
      "   public Set&lt;Address&gt; getAddresses() { ... } \n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "public class Address {\n"
      "   public String getStreet1() {...}\n"
      "   [...]\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:694
#, no-c-format
msgid "Such an embeddable object cannot contains a collection itself."
msgstr ""

#. Tag: para
#: collection_mapping.xml:698
#, no-c-format
msgid "in <classname>@AttributeOverride</classname>, you must use the <literal>value.</literal> prefix to override properties of the embeddable object used in the map value and the <literal>key.</literal> prefix to override properties of the embeddable object used in the map key."
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:704
#, no-c-format
msgid ""
      "@Entity\n"
      "public class User {\n"
      "   @ElementCollection\n"
      "   @AttributeOverrides({\n"
      "      @AttributeOverride(name=\"key.street1\", column=@Column(name=\"fld_street\")),\n"
      "      @AttributeOverride(name=\"value.stars\", column=@Column(name=\"fld_note\"))\n"
      "   })\n"
      "   public Map&lt;Address,Rating&gt; getFavHomes() { ... }"
msgstr ""

#. Tag: para
#: collection_mapping.xml:708
#, no-c-format
msgid "We recommend you to migrate from <classname>@org.hibernate.annotations.CollectionOfElements</classname> to the new <classname>@ElementCollection</classname> annotation."
msgstr ""

#. Tag: para
#: collection_mapping.xml:714
#, no-c-format
msgid "Using the mapping file approach a collection of values is mapped using the <literal>&lt;element&gt;</literal> tag. For example:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:718
#, no-c-format
msgid "&lt;element&gt; tag for collection values using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:730
#, no-c-format
msgid ""
      "&lt;element\n"
      "        column=\"column_name\"\n"
      "        formula=\"any SQL expression\"\n"
      "        type=\"typename\"\n"
      "        length=\"L\"\n"
      "        precision=\"P\"\n"
      "        scale=\"S\"\n"
      "        not-null=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        node=\"element-name\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:734
#, no-c-format
msgid "<literal>column</literal> (optional): the name of the column holding the collection element values."
msgstr ""

#. Tag: para
#: collection_mapping.xml:739
#, no-c-format
msgid "<literal>formula</literal> (optional): an SQL formula used to evaluate the element."
msgstr ""

#. Tag: para
#: collection_mapping.xml:744
#, no-c-format
msgid "<literal>type</literal> (required): the type of the collection element."
msgstr ""

#. Tag: title
#: collection_mapping.xml:754
#, no-c-format
msgid "Advanced collection mappings"
msgstr ""

#. Tag: title
#: collection_mapping.xml:757
#, no-c-format
msgid "Sorted collections"
msgstr ""

#. Tag: para
#: collection_mapping.xml:759
#, no-c-format
msgid "Hibernate supports collections implementing <literal>java.util.SortedMap</literal> and <literal>java.util.SortedSet</literal>. With annotations you declare a sort comparator using <literal>@Sort</literal>. You chose between the comparator types unsorted, natural or custom. If you want to use your own comparator implementation, you'll also have to specify the implementation class using the <literal>comparator</literal> attribute. Note that you need to use either a <classname>SortedSet</classname> or a <classname>SortedMap</classname> interface."
msgstr ""

#. Tag: title
#: collection_mapping.xml:770
#, no-c-format
msgid "Sorted collection with @Sort"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:772
#, no-c-format
msgid ""
      "@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)\n"
      "@JoinColumn(name=\"CUST_ID\")\n"
      "@Sort(type = SortType.COMPARATOR, comparator = TicketComparator.class)\n"
      "public SortedSet&lt;Ticket&gt; getTickets() {\n"
      "    return tickets;\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:775
#, no-c-format
msgid "Using Hibernate mapping files you specify a comparator in the mapping file with <literal>&lt;sort&gt;</literal>:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:779
#, no-c-format
msgid "Sorted collection using xml mapping"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:781
#, no-c-format
msgid ""
      "&lt;set name=\"aliases\"\n"
      "            table=\"person_aliases\" \n"
      "            sort=\"natural\"&gt;\n"
      "    &lt;key column=\"person\"/&gt;\n"
      "    &lt;element column=\"name\" type=\"string\"/&gt;\n"
      "&lt;/set&gt;\n"
      "\n"
      "&lt;map name=\"holidays\" sort=\"my.custom.HolidayComparator\"&gt;\n"
      "    &lt;key column=\"year_id\"/&gt;\n"
      "    &lt;map-key column=\"hol_name\" type=\"string\"/&gt;\n"
      "    &lt;element column=\"hol_date\" type=\"date\"/&gt;\n"
      "&lt;/map&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:784
#, no-c-format
msgid "Allowed values of the <literal>sort</literal> attribute are <literal>unsorted</literal>, <literal>natural</literal> and the name of a class implementing <literal>java.util.Comparator</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:789
#, no-c-format
msgid "Sorted collections actually behave like <literal>java.util.TreeSet</literal> or <literal>java.util.TreeMap</literal>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:794
#, no-c-format
msgid "If you want the database itself to order the collection elements, use the <literal>order-by</literal> attribute of <literal>set</literal>, <literal>bag</literal> or <literal>map</literal> mappings. This solution is implemented using <literal>LinkedHashSet</literal> or <literal>LinkedHashMap</literal> and performs the ordering in the SQL query and not in the memory."
msgstr ""

#. Tag: title
#: collection_mapping.xml:802
#, no-c-format
msgid "Sorting in database using order-by"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:804
#, no-c-format
msgid ""
      "&lt;set name=\"aliases\" table=\"person_aliases\" order-by=\"lower(name) asc\"&gt;\n"
      "    &lt;key column=\"person\"/&gt;\n"
      "    &lt;element column=\"name\" type=\"string\"/&gt;\n"
      "&lt;/set&gt;\n"
      "\n"
      "&lt;map name=\"holidays\" order-by=\"hol_date, hol_name\"&gt;\n"
      "    &lt;key column=\"year_id\"/&gt;\n"
      "    &lt;map-key column=\"hol_name\" type=\"string\"/&gt;\n"
      "    &lt;element column=\"hol_date type=\"date\"/&gt;\n"
      "&lt;/map&gt;"
msgstr ""

#. Tag: title
#: collection_mapping.xml:808
#, no-c-format
msgid "Note"
msgstr ""

#. Tag: para
#: collection_mapping.xml:810
#, no-c-format
msgid "The value of the <literal>order-by</literal> attribute is an SQL ordering, not an HQL ordering."
msgstr ""

#. Tag: para
#: collection_mapping.xml:814
#, no-c-format
msgid "Associations can even be sorted by arbitrary criteria at runtime using a collection <literal>filter()</literal>:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:818
#, no-c-format
msgid "Sorting via a query filter"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:820
#, no-c-format
msgid "sortedUsers = s.createFilter( group.getUsers(), \"order by this.name\" ).list();"
msgstr ""

#. Tag: title
#: collection_mapping.xml:825
#, no-c-format
msgid "Bidirectional associations"
msgstr ""

#. Tag: para
#: collection_mapping.xml:827
#, no-c-format
msgid "A <emphasis>bidirectional association</emphasis> allows navigation from both \"ends\" of the association. Two kinds of bidirectional association are supported:"
msgstr ""

#. Tag: term
#: collection_mapping.xml:831
#, no-c-format
msgid "one-to-many"
msgstr ""

#. Tag: para
#: collection_mapping.xml:834
#, no-c-format
msgid "set or bag valued at one end and single-valued at the other"
msgstr ""

#. Tag: term
#: collection_mapping.xml:840
#, no-c-format
msgid "many-to-many"
msgstr ""

#. Tag: para
#: collection_mapping.xml:843
#, no-c-format
msgid "set or bag valued at both ends"
msgstr ""

#. Tag: para
#: collection_mapping.xml:848
#, no-c-format
msgid "Often there exists a many to one association which is the owner side of a bidirectional relationship. The corresponding one to many association is in this case annotated by <literal>@OneToMany(mappedBy=...)</literal>"
msgstr ""

#. Tag: title
#: collection_mapping.xml:854
#, no-c-format
msgid "Bidirectional one to many with many to one side as association owner"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:857
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Troop {\n"
      "    @OneToMany(mappedBy=\"troop\")\n"
      "    public Set&lt;Soldier&gt; getSoldiers() {\n"
      "    ...\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Soldier {\n"
      "    @ManyToOne\n"
      "    @JoinColumn(name=\"troop_fk\")\n"
      "    public Troop getTroop() {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:860
#, no-c-format
msgid "<classname>Troop</classname> has a bidirectional one to many relationship with <literal>Soldier</literal> through the <literal>troop</literal> property. You don't have to (must not) define any physical mapping in the <literal>mappedBy</literal> side."
msgstr ""

#. Tag: para
#: collection_mapping.xml:865
#, no-c-format
msgid "To map a bidirectional one to many, with the one-to-many side as the owning side, you have to remove the <literal>mappedBy</literal> element and set the many to one <literal>@JoinColumn</literal> as insertable and updatable to false. This solution is not optimized and will produce additional UPDATE statements."
msgstr ""

#. Tag: title
#: collection_mapping.xml:872
#, no-c-format
msgid "Bidirectional associtaion with one to many side as owner"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:875
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Troop {\n"
      "    @OneToMany\n"
      "    @JoinColumn(name=\"troop_fk\") //we need to duplicate the physical information\n"
      "    public Set&lt;Soldier&gt; getSoldiers() {\n"
      "    ...\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Soldier {\n"
      "    @ManyToOne\n"
      "    @JoinColumn(name=\"troop_fk\", insertable=false, updatable=false)\n"
      "    public Troop getTroop() {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:878
#, no-c-format
msgid "How does the mappping of a bidirectional mapping look like in Hibernate mapping xml? There you define a bidirectional one-to-many association by mapping a one-to-many association to the same table column(s) as a many-to-one association and declaring the many-valued end <literal>inverse=\"true\"</literal>."
msgstr ""

#. Tag: title
#: collection_mapping.xml:885
#, no-c-format
msgid "Bidirectional one to many via Hibernate mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:887
#, no-c-format
msgid ""
      "&lt;class name=\"Parent\"&gt;\n"
      "    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
      "    ....\n"
      "    &lt;set name=\"children\" inverse=\"true\"&gt;\n"
      "        &lt;key column=\"parent_id\"/&gt;\n"
      "        &lt;one-to-many class=\"Child\"/&gt;\n"
      "    &lt;/set&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"Child\"&gt;\n"
      "    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
      "    ....\n"
      "    &lt;many-to-one name=\"parent\" \n"
      "        class=\"Parent\" \n"
      "        column=\"parent_id\"\n"
      "        not-null=\"true\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:890
#, no-c-format
msgid "Mapping one end of an association with <literal>inverse=\"true\"</literal> does not affect the operation of cascades as these are orthogonal concepts."
msgstr ""

#. Tag: para
#: collection_mapping.xml:894
#, no-c-format
msgid "A many-to-many association is defined logically using the <literal>@ManyToMany</literal> annotation. You also have to describe the association table and the join conditions using the <literal>@JoinTable</literal> annotation. If the association is bidirectional, one side has to be the owner and one side has to be the inverse end (ie. it will be ignored when updating the relationship values in the association table):"
msgstr ""

#. Tag: title
#: collection_mapping.xml:903
#, no-c-format
msgid "Many to many association via @ManyToMany"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:905
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Employer implements Serializable {\n"
      "    @ManyToMany(\n"
      "        targetEntity=org.hibernate.test.metadata.manytomany.Employee.class,\n"
      "        cascade={CascadeType.PERSIST, CascadeType.MERGE}\n"
      "    )\n"
      "    @JoinTable(\n"
      "        name=\"EMPLOYER_EMPLOYEE\",\n"
      "        joinColumns=@JoinColumn(name=\"EMPER_ID\"),\n"
      "        inverseJoinColumns=@JoinColumn(name=\"EMPEE_ID\")\n"
      "    )\n"
      "    public Collection getEmployees() {\n"
      "        return employees;\n"
      "    }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:907
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Employee implements Serializable {\n"
      "    @ManyToMany(\n"
      "        cascade = {CascadeType.PERSIST, CascadeType.MERGE},\n"
      "        mappedBy = \"employees\",\n"
      "        targetEntity = Employer.class\n"
      "    )\n"
      "    public Collection getEmployers() {\n"
      "        return employers;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:910
#, no-c-format
msgid "In this example <classname>@JoinTable</classname> defines a <literal>name</literal>, an array of join columns, and an array of inverse join columns. The latter ones are the columns of the association table which refer to the <classname>Employee</classname> primary key (the \"other side\"). As seen previously, the other side don't have to (must not) describe the physical mapping: a simple <literal>mappedBy</literal> argument containing the owner side property name bind the two."
msgstr ""

#. Tag: para
#: collection_mapping.xml:919
#, no-c-format
msgid "As any other annotations, most values are guessed in a many to many relationship. Without describing any physical mapping in a unidirectional many to many the following rules applied. The table name is the concatenation of the owner table name, <keycap>_</keycap> and the other side table name. The foreign key name(s) referencing the owner table is the concatenation of the owner table name, <keycap>_</keycap> and the owner primary key column(s). The foreign key name(s) referencing the other side is the concatenation of the owner property name, <keycap>_</keycap>, and the other side primary key column(s). These are the same rules used for a unidirectional one to many relationship."
msgstr ""

#. Tag: title
#: collection_mapping.xml:932
#, no-c-format
msgid "Default values for <classname>@ManyToMany</classname> (uni-directional)"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:935
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Store {\n"
      "    @ManyToMany(cascade = CascadeType.PERSIST)\n"
      "    public Set&lt;City&gt; getImplantedIn() {\n"
      "        ...\n"
      "    }\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class City {\n"
      "    ... //no bidirectional relationship\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:938
#, no-c-format
msgid "A <literal>Store_City</literal> is used as the join table. The <literal>Store_id</literal> column is a foreign key to the <literal>Store</literal> table. The <literal>implantedIn_id</literal> column is a foreign key to the <literal>City</literal> table."
msgstr ""

#. Tag: para
#: collection_mapping.xml:943
#, no-c-format
msgid "Without describing any physical mapping in a bidirectional many to many the following rules applied. The table name is the concatenation of the owner table name, <keycap>_</keycap> and the other side table name. The foreign key name(s) referencing the owner table is the concatenation of the other side property name, <keycap>_</keycap>, and the owner primary key column(s). The foreign key name(s) referencing the other side is the concatenation of the owner property name, <keycap>_</keycap>, and the other side primary key column(s). These are the same rules used for a unidirectional one to many relationship."
msgstr ""

#. Tag: title
#: collection_mapping.xml:955
#, no-c-format
msgid "Default values for <classname>@ManyToMany</classname> (bi-directional)"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:958
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Store {\n"
      "    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n"
      "    public Set&lt;Customer&gt; getCustomers() {\n"
      "        ...\n"
      "    }\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Customer {\n"
      "    @ManyToMany(mappedBy=\"customers\")\n"
      "    public Set&lt;Store&gt; getStores() {\n"
      "        ...\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:961
#, no-c-format
msgid "A <literal>Store_Customer</literal> is used as the join table. The <literal>stores_id</literal> column is a foreign key to the <literal>Store</literal> table. The <literal>customers_id</literal> column is a foreign key to the <literal>Customer</literal> table."
msgstr ""

#. Tag: para
#: collection_mapping.xml:966
#, no-c-format
msgid "Using Hibernate mapping files you can map a bidirectional many-to-many association by mapping two many-to-many associations to the same database table and declaring one end as <emphasis>inverse</emphasis>."
msgstr ""

#. Tag: para
#: collection_mapping.xml:970
#, no-c-format
msgid "You cannot select an indexed collection."
msgstr ""

#. Tag: para
#: collection_mapping.xml:973
#, no-c-format
msgid "shows a bidirectional many-to-many association that illustrates how each category can have many items and each item can be in many categories:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:979
#, no-c-format
msgid "Many to many association using Hibernate mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:981
#, no-c-format
msgid ""
      "&lt;class name=\"Category\"&gt;\n"
      "    &lt;id name=\"id\" column=\"CATEGORY_ID\"/&gt;\n"
      "    ...\n"
      "    &lt;bag name=\"items\" table=\"CATEGORY_ITEM\"&gt;\n"
      "        &lt;key column=\"CATEGORY_ID\"/&gt;\n"
      "        &lt;many-to-many class=\"Item\" column=\"ITEM_ID\"/&gt;\n"
      "    &lt;/bag&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"Item\"&gt;\n"
      "    &lt;id name=\"id\" column=\"ITEM_ID\"/&gt;\n"
      "    ...\n"
      "\n"
      "    &lt;!-- inverse end --&gt;\n"
      "    &lt;bag name=\"categories\" table=\"CATEGORY_ITEM\" inverse=\"true\"&gt;\n"
      "        &lt;key column=\"ITEM_ID\"/&gt;\n"
      "        &lt;many-to-many class=\"Category\" column=\"CATEGORY_ID\"/&gt;\n"
      "    &lt;/bag&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:984
#, no-c-format
msgid "Changes made only to the inverse end of the association are <emphasis>not</emphasis> persisted. This means that Hibernate has two representations in memory for every bidirectional association: one link from A to B and another link from B to A. This is easier to understand if you think about the Java object model and how a many-to-many relationship in Javais created:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:992
#, no-c-format
msgid "Effect of inverse vs. non-inverse side of many to many associations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:995
#, no-c-format
msgid ""
      "category.getItems().add(item);           // The category now \"knows\" about the relationship\n"
      "item.getCategories().add(category);      // The item now \"knows\" about the relationship\n"
      "\n"
      "session.persist(item);                   // The relationship won't be saved!\n"
      "session.persist(category);               // The relationship will be saved"
msgstr ""

#. Tag: para
#: collection_mapping.xml:998
#, no-c-format
msgid "The non-inverse side is used to save the in-memory representation to the database."
msgstr ""

#. Tag: title
#: collection_mapping.xml:1003
#, no-c-format
msgid "Bidirectional associations with indexed collections"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1005
#, no-c-format
msgid "There are some additional considerations for bidirectional mappings with indexed collections (where one end is represented as a <literal>&lt;list&gt;</literal> or <literal>&lt;map&gt;</literal>) when using Hibernate mapping files. If there is a property of the child class that maps to the index column you can use <literal>inverse=\"true\"</literal> on the collection mapping:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1013
#, no-c-format
msgid "Bidirectional association with indexed collection"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1015
#, no-c-format
msgid ""
      "&lt;class name=\"Parent\"&gt;\n"
      "    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
      "    ....\n"
      "    &lt;map name=\"children\" inverse=\"true\"&gt;\n"
      "        &lt;key column=\"parent_id\"/&gt;\n"
      "        &lt;map-key column=\"name\" \n"
      "            type=\"string\"/&gt;\n"
      "        &lt;one-to-many class=\"Child\"/&gt;\n"
      "    &lt;/map&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"Child\"&gt;\n"
      "    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
      "    ....\n"
      "    &lt;property name=\"name\" \n"
      "        not-null=\"true\"/&gt;\n"
      "    &lt;many-to-one name=\"parent\" \n"
      "        class=\"Parent\" \n"
      "        column=\"parent_id\"\n"
      "        not-null=\"true\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1018
#, no-c-format
msgid "If there is no such property on the child class, the association cannot be considered truly bidirectional. That is, there is information available at one end of the association that is not available at the other end. In this case, you cannot map the collection <literal>inverse=\"true\"</literal>. Instead, you could use the following mapping:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1026
#, no-c-format
msgid "Bidirectional association with indexed collection, but no index column"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1029
#, no-c-format
msgid ""
      "&lt;class name=\"Parent\"&gt;\n"
      "    &lt;id name=\"id\" column=\"parent_id\"/&gt;\n"
      "    ....\n"
      "    &lt;map name=\"children\"&gt;\n"
      "        &lt;key column=\"parent_id\"\n"
      "            not-null=\"true\"/&gt;\n"
      "        &lt;map-key column=\"name\" \n"
      "            type=\"string\"/&gt;\n"
      "        &lt;one-to-many class=\"Child\"/&gt;\n"
      "    &lt;/map&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"Child\"&gt;\n"
      "    &lt;id name=\"id\" column=\"child_id\"/&gt;\n"
      "    ....\n"
      "    &lt;many-to-one name=\"parent\" \n"
      "        class=\"Parent\" \n"
      "        column=\"parent_id\"\n"
      "        insert=\"false\"\n"
      "        update=\"false\"\n"
      "        not-null=\"true\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1032
#, no-c-format
msgid "Note that in this mapping, the collection-valued end of the association is responsible for updates to the foreign key."
msgstr ""

#. Tag: title
#: collection_mapping.xml:1037
#, no-c-format
msgid "Ternary associations"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1039
#, no-c-format
msgid "There are three possible approaches to mapping a ternary association. One approach is to use a <literal>Map</literal> with an association as its index:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1044
#, no-c-format
msgid "Ternary association mapping"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1046
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Company {\n"
      "   @Id \n"
      "   int id;\n"
      "   ...\n"
      "   @OneToMany // unidirectional\n"
      "   @MapKeyJoinColumn(name=\"employee_id\")\n"
      "   Map&lt;Employee, Contract&gt; contracts;\n"
      "}\n"
      "\n"
      "// or\n"
      "\n"
      "&lt;map name=\"contracts\"&gt;\n"
      "    &lt;key column=\"employer_id\" not-null=\"true\"/&gt;\n"
      "    &lt;map-key-many-to-many column=\"employee_id\" class=\"Employee\"/&gt;\n"
      "    &lt;one-to-many class=\"Contract\"/&gt;\n"
      "&lt;/map&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1049
#, no-c-format
msgid "A second approach is to remodel the association as an entity class. This is the most common approach. A final alternative is to use composite elements, which will be discussed later."
msgstr ""

#. Tag: literal
#: collection_mapping.xml:1055
#, no-c-format
msgid "Using an &lt;idbag&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1057
#, no-c-format
msgid "The majority of the many-to-many associations and collections of values shown previously all map to tables with composite keys, even though it has been suggested that entities should have synthetic identifiers (surrogate keys). A pure association table does not seem to benefit much from a surrogate key, although a collection of composite values <emphasis>might</emphasis>. For this reason Hibernate provides a feature that allows you to map many-to-many associations and collections of values to a table with a surrogate key."
msgstr ""

#. Tag: para
#: collection_mapping.xml:1066
#, no-c-format
msgid "The <literal>&lt;idbag&gt;</literal> element lets you map a <literal>List</literal> (or <literal>Collection</literal>) with bag semantics. For example:"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1070
#, no-c-format
msgid ""
      "&lt;idbag name=\"lovers\" table=\"LOVERS\"&gt;\n"
      "    &lt;collection-id column=\"ID\" type=\"long\"&gt;\n"
      "        &lt;generator class=\"sequence\"/&gt;\n"
      "    &lt;/collection-id&gt;\n"
      "    &lt;key column=\"PERSON1\"/&gt;\n"
      "    &lt;many-to-many column=\"PERSON2\" class=\"Person\" fetch=\"join\"/&gt;\n"
      "&lt;/idbag&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1072
#, no-c-format
msgid "An <literal>&lt;idbag&gt;</literal> has a synthetic id generator, just like an entity class. A different surrogate key is assigned to each collection row. Hibernate does not, however, provide any mechanism for discovering the surrogate key value of a particular row."
msgstr ""

#. Tag: para
#: collection_mapping.xml:1077
#, no-c-format
msgid "The update performance of an <literal>&lt;idbag&gt;</literal> supersedes a regular <literal>&lt;bag&gt;</literal>. Hibernate can locate individual rows efficiently and update or delete them individually, similar to a list, map or set."
msgstr ""

#. Tag: para
#: collection_mapping.xml:1082
#, no-c-format
msgid "In the current implementation, the <literal>native</literal> identifier generation strategy is not supported for <literal>&lt;idbag&gt;</literal> collection identifiers."
msgstr ""

#. Tag: title
#: collection_mapping.xml:1103
#, no-c-format
msgid "Collection examples"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1105
#, no-c-format
msgid "This section covers collection examples."
msgstr ""

#. Tag: para
#: collection_mapping.xml:1107
#, no-c-format
msgid "The following class has a collection of <literal>Child</literal> instances:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1111
#, no-c-format
msgid "Example classes <classname>Parent</classname> and <classname>Child</classname>"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1114
#, no-c-format
msgid ""
      "public class Parent {\n"
      "    private long id;\n"
      "    private Set&lt;Child&gt; children;\n"
      "\n"
      "    // getter/setter\n"
      "    ...\n"
      "}\n"
      "\n"
      "\n"
      "public class Child {\n"
      "   private long id;\n"
      "   private String name\n"
      "\n"
      "   \n"
      "   // getter/setter\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1117
#, no-c-format
msgid "If each child has, at most, one parent, the most natural mapping is a one-to-many association:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1121
#, no-c-format
msgid "One to many unidirectional <classname>Parent-Child</classname> relationship using annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1124
#, no-c-format
msgid ""
      "public class Parent {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private long id;\n"
      "\n"
      "    @OneToMany\n"
      "    private Set&lt;Child&gt; children;\n"
      "\n"
      "    // getter/setter\n"
      "    ...\n"
      "}\n"
      "\n"
      "\n"
      "public class Child {\n"
      "   @Id\n"
      "   @GeneratedValue\n"
      "   private long id;\n"
      "   private String name;\n"
      "\n"
      "   \n"
      "   // getter/setter\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1128
#, no-c-format
msgid "One to many unidirectional <classname>Parent-Child</classname> relationship using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1131
#, no-c-format
msgid ""
      "&lt;hibernate-mapping&gt;\n"
      "\n"
      "    &lt;class name=\"Parent\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;set name=\"children\"&gt;\n"
      "            &lt;key column=\"parent_id\"/&gt;\n"
      "            &lt;one-to-many class=\"Child\"/&gt;\n"
      "        &lt;/set&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "    &lt;class name=\"Child\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;property name=\"name\"/&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1134
#, no-c-format
msgid "This maps to the following table definitions:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1137
#, no-c-format
msgid "Table definitions for unidirectional <classname>Parent</classname>-<classname>Child</classname> relationship"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1141
#, no-c-format
msgid ""
      "create table parent ( id bigint not null primary key )\n"
      "create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )\n"
      "alter table child add constraint childfk0 (parent_id) references parent"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1144
#, no-c-format
msgid "If the parent is <emphasis>required</emphasis>, use a bidirectional one-to-many association:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1148
#, no-c-format
msgid "One to many bidirectional <classname>Parent-Child</classname> relationship using annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1151
#, no-c-format
msgid ""
      "public class Parent {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private long id;\n"
      "\n"
      "    @OneToMany(mappedBy=\"parent\")\n"
      "    private Set&lt;Child&gt; children;\n"
      "\n"
      "    // getter/setter\n"
      "    ...\n"
      "}\n"
      "\n"
      "\n"
      "public class Child {\n"
      "   @Id\n"
      "   @GeneratedValue\n"
      "   private long id;\n"
      "\n"
      "   private String name;\n"
      " \n"
      "   @ManyToOne\n"
      "   private Parent parent;\n"
      "\n"
      "   \n"
      "   // getter/setter\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1155
#, no-c-format
msgid "One to many bidirectional <classname>Parent-Child</classname> relationship using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1158
#, no-c-format
msgid ""
      "&lt;hibernate-mapping&gt;\n"
      "\n"
      "    &lt;class name=\"Parent\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;set name=\"children\" inverse=\"true\"&gt;\n"
      "            &lt;key column=\"parent_id\"/&gt;\n"
      "            &lt;one-to-many class=\"Child\"/&gt;\n"
      "        &lt;/set&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "    &lt;class name=\"Child\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;property name=\"name\"/&gt;\n"
      "        &lt;many-to-one name=\"parent\" class=\"Parent\" column=\"parent_id\" not-null=\"true\"/&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1161
#, no-c-format
msgid "Notice the <literal>NOT NULL</literal> constraint:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1164
#, no-c-format
msgid "Table definitions for bidirectional <classname>Parent</classname>-<classname>Child</classname> relationship"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1168
#, no-c-format
msgid ""
      "create table parent ( id bigint not null primary key )\n"
      "create table child ( id bigint not null\n"
      "                     primary key,\n"
      "                     name varchar(255),\n"
      "                     parent_id bigint not null )\n"
      "alter table child add constraint childfk0 (parent_id) references parent"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1171
#, no-c-format
msgid "Alternatively, if this association must be unidirectional you can enforce the <literal>NOT NULL</literal> constraint."
msgstr ""

#. Tag: title
#: collection_mapping.xml:1175
#, no-c-format
msgid "Enforcing NOT NULL constraint in unidirectional relation using annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1178
#, no-c-format
msgid ""
      "public class Parent {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private long id;\n"
      "\n"
      "    @OneToMany(optional=false)\n"
      "    private Set&lt;Child&gt; children;\n"
      "\n"
      "    // getter/setter\n"
      "    ...\n"
      "}\n"
      "\n"
      "\n"
      "public class Child {\n"
      "   @Id\n"
      "   @GeneratedValue\n"
      "   private long id;\n"
      "   private String name;\n"
      "\n"
      "   \n"
      "   // getter/setter\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1182
#, no-c-format
msgid "Enforcing NOT NULL constraint in unidirectional relation using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1185
#, no-c-format
msgid ""
      "&lt;hibernate-mapping&gt;\n"
      "\n"
      "    &lt;class name=\"Parent\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;set name=\"children\"&gt;\n"
      "            &lt;key column=\"parent_id\" not-null=\"true\"/&gt;\n"
      "            &lt;one-to-many class=\"Child\"/&gt;\n"
      "        &lt;/set&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "    &lt;class name=\"Child\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;property name=\"name\"/&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1188
#, no-c-format
msgid "On the other hand, if a child has multiple parents, a many-to-many association is appropriate."
msgstr ""

#. Tag: title
#: collection_mapping.xml:1192
#, no-c-format
msgid "Many to many <classname>Parent-Child</classname> relationship using annotations"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1195
#, no-c-format
msgid ""
      "public class Parent {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private long id;\n"
      "\n"
      "    @ManyToMany\n"
      "    private Set&lt;Child&gt; children;\n"
      "\n"
      "    // getter/setter\n"
      "    ...\n"
      "}\n"
      "\n"
      "\n"
      "public class Child {\n"
      "   @Id\n"
      "   @GeneratedValue\n"
      "   private long id;\n"
      "\n"
      "   private String name;\n"
      "\n"
      "   \n"
      "   // getter/setter\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1199
#, no-c-format
msgid "Many to many <classname>Parent-Child</classname> relationship using mapping files"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1202
#, no-c-format
msgid ""
      "&lt;hibernate-mapping&gt;\n"
      "\n"
      "    &lt;class name=\"Parent\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;set name=\"children\" table=\"childset\"&gt;\n"
      "            &lt;key column=\"parent_id\"/&gt;\n"
      "            &lt;many-to-many class=\"Child\" column=\"child_id\"/&gt;\n"
      "        &lt;/set&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "    &lt;class name=\"Child\"&gt;\n"
      "        &lt;id name=\"id\"&gt;\n"
      "            &lt;generator class=\"sequence\"/&gt;\n"
      "        &lt;/id&gt;\n"
      "        &lt;property name=\"name\"/&gt;\n"
      "    &lt;/class&gt;\n"
      "\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1205
#, no-c-format
msgid "Table definitions:"
msgstr ""

#. Tag: title
#: collection_mapping.xml:1208
#, no-c-format
msgid "Table definitions for many to many releationship"
msgstr ""

#. Tag: programlisting
#: collection_mapping.xml:1210
#, no-c-format
msgid ""
      "create table parent ( id bigint not null primary key )\n"
      "create table child ( id bigint not null primary key, name varchar(255) )\n"
      "create table childset ( parent_id bigint not null,\n"
      "                        child_id bigint not null,\n"
      "                        primary key ( parent_id, child_id ) )\n"
      "alter table childset add constraint childsetfk0 (parent_id) references parent\n"
      "alter table childset add constraint childsetfk1 (child_id) references child"
msgstr ""

#. Tag: para
#: collection_mapping.xml:1213
#, no-c-format
msgid "For more examples and a complete explanation of a parent/child relationship mapping, see <xref linkend=\"example-parentchild\"/> for more information. Even more complex association mappings are covered in the next chapter."
msgstr ""

