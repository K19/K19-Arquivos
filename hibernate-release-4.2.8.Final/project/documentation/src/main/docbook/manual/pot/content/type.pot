# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-01-21 21:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-xml2pot; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: type.xml:27
#, no-c-format
msgid "Types"
msgstr ""

#. Tag: para
#: type.xml:29
#, no-c-format
msgid "As an Object/Relational Mapping solution, Hibernate deals with both the Java and JDBC representations of application data. An online catalog application, for example, most likely has <classname>Product</classname> object with a number of attributes such as a <literal>sku</literal>, <literal>name</literal>, etc. For these individual attributes, Hibernate must be able to read the values out of the database and write them back. This 'marshalling' is the function of a <emphasis>Hibernate type</emphasis>, which is an implementation of the <interfacename>org.hibernate.type.Type</interfacename> interface. In addition, a <emphasis>Hibernate type</emphasis> describes various aspects of behavior of the Java type such as \"how is equality checked?\" or \"how are values cloned?\"."
msgstr ""

#. Tag: para
#: type.xml:41
#, no-c-format
msgid "A Hibernate type is neither a Java type nor a SQL datatype; it provides a information about both."
msgstr ""

#. Tag: para
#: type.xml:44
#, no-c-format
msgid "When you encounter the term <emphasis>type</emphasis> in regards to Hibernate be aware that usage might refer to the Java type, the SQL/JDBC type or the Hibernate type."
msgstr ""

#. Tag: para
#: type.xml:50
#, no-c-format
msgid "Hibernate categorizes types into two high-level groups: value types (see <xref linkend=\"types-value\"/>) and entity types (see <xref linkend=\"types-entity\"/>)."
msgstr ""

#. Tag: title
#: type.xml:56
#, no-c-format
msgid "Value types"
msgstr ""

#. Tag: para
#: type.xml:58
#, no-c-format
msgid "The main distinguishing characteristic of a value type is the fact that they do not define their own lifecycle. We say that they are \"owned\" by something else (specifically an entity, as we will see later) which defines their lifecycle. Value types are further classified into 3 sub-categories: basic types (see <xref linkend=\"types-value-basic\"/>), composite types (see <xref linkend=\"types-value-composite\"/>) amd collection types (see <xref linkend=\"types-value-collection\"/>)."
msgstr ""

#. Tag: title
#: type.xml:67
#, no-c-format
msgid "Basic value types"
msgstr ""

#. Tag: para
#: type.xml:68
#, no-c-format
msgid "The norm for basic value types is that they map a single database value (column) to a single, non-aggregated Java type. Hibernate provides a number of built-in basic types, which we will present in the following sections by the Java type. Mainly these follow the natural mappings recommended in the JDBC specification. We will later cover how to override these mapping and how to provide and use alternative type mappings."
msgstr ""

#. Tag: title
#: type.xml:76
#, no-c-format
msgid "java.lang.String"
msgstr ""

#. Tag: classname
#: type.xml:79
#, no-c-format
msgid "org.hibernate.type.StringType"
msgstr ""

#. Tag: para
#: type.xml:81
#, no-c-format
msgid "Maps a string to the JDBC VARCHAR type. This is the standard mapping for a string if no Hibernate type is specified."
msgstr ""

#. Tag: para
#: type.xml:85
#, no-c-format
msgid "Registered under <literal>string</literal> and <literal>java.lang.String</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:92
#, no-c-format
msgid "org.hibernate.type.MaterializedClob"
msgstr ""

#. Tag: para
#: type.xml:94
#, no-c-format
msgid "Maps a string to a JDBC CLOB type"
msgstr ""

#. Tag: para
#: type.xml:97
#, no-c-format
msgid "Registered under <literal>materialized_clob</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:104
#, no-c-format
msgid "org.hibernate.type.TextType"
msgstr ""

#. Tag: para
#: type.xml:106
#, no-c-format
msgid "Maps a string to a JDBC LONGVARCHAR type"
msgstr ""

#. Tag: para
#: type.xml:109
#, no-c-format
msgid "Registered under <literal>text</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:118
#, no-c-format
msgid "<classname>java.lang.Character</classname> (or char primitive)"
msgstr ""

#. Tag: classname
#: type.xml:121
#, no-c-format
msgid "org.hibernate.type.CharacterType"
msgstr ""

#. Tag: para
#: type.xml:123
#, no-c-format
msgid "Maps a char or <classname>java.lang.Character</classname> to a JDBC CHAR"
msgstr ""

#. Tag: para
#: type.xml:126
#, no-c-format
msgid "Registered under <literal>char</literal> and <literal>java.lang.Character</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:135
#, no-c-format
msgid "<classname>java.lang.Boolean</classname> (or boolean primitive)"
msgstr ""

#. Tag: classname
#: type.xml:138
#, no-c-format
msgid "org.hibernate.type.BooleanType"
msgstr ""

#. Tag: para
#: type.xml:140
#, no-c-format
msgid "Maps a boolean to a JDBC BIT type"
msgstr ""

#. Tag: para
#: type.xml:143
#, no-c-format
msgid "Registered under <literal>boolean</literal> and <literal>java.lang.Boolean</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:150
#, no-c-format
msgid "org.hibernate.type.NumericBooleanType"
msgstr ""

#. Tag: para
#: type.xml:152
#, no-c-format
msgid "Maps a boolean to a JDBC INTEGER type as 0 = false, 1 = true"
msgstr ""

#. Tag: para
#: type.xml:155
#, no-c-format
msgid "Registered under <literal>numeric_boolean</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:162
#, no-c-format
msgid "org.hibernate.type.YesNoType"
msgstr ""

#. Tag: para
#: type.xml:164
#, no-c-format
msgid "Maps a boolean to a JDBC CHAR type as ('N' | 'n') = false, ( 'Y' | 'y' ) = true"
msgstr ""

#. Tag: para
#: type.xml:167
#, no-c-format
msgid "Registered under <literal>yes_no</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:174
#, no-c-format
msgid "org.hibernate.type.TrueFalseType"
msgstr ""

#. Tag: para
#: type.xml:176
#, no-c-format
msgid "Maps a boolean to a JDBC CHAR type as ('F' | 'f') = false, ( 'T' | 't' ) = true"
msgstr ""

#. Tag: para
#: type.xml:179
#, no-c-format
msgid "Registered under <literal>true_false</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:188
#, no-c-format
msgid "<classname>java.lang.Byte</classname> (or byte primitive)"
msgstr ""

#. Tag: classname
#: type.xml:191
#, no-c-format
msgid "org.hibernate.type.ByteType"
msgstr ""

#. Tag: para
#: type.xml:193
#, no-c-format
msgid "Maps a byte or <classname>java.lang.Byte</classname> to a JDBC TINYINT"
msgstr ""

#. Tag: para
#: type.xml:196
#, no-c-format
msgid "Registered under <literal>byte</literal> and <literal>java.lang.Byte</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:205
#, no-c-format
msgid "<classname>java.lang.Short</classname> (or short primitive)"
msgstr ""

#. Tag: classname
#: type.xml:208
#, no-c-format
msgid "org.hibernate.type.ShortType"
msgstr ""

#. Tag: para
#: type.xml:210
#, no-c-format
msgid "Maps a short or <classname>java.lang.Short</classname> to a JDBC SMALLINT"
msgstr ""

#. Tag: para
#: type.xml:213
#, no-c-format
msgid "Registered under <literal>short</literal> and <literal>java.lang.Short</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:222
#, no-c-format
msgid "<classname>java.lang.Integer</classname> (or int primitive)"
msgstr ""

#. Tag: classname
#: type.xml:225
#, no-c-format
msgid "org.hibernate.type.IntegerTypes"
msgstr ""

#. Tag: para
#: type.xml:227
#, no-c-format
msgid "Maps an int or <classname>java.lang.Integer</classname> to a JDBC INTEGER"
msgstr ""

#. Tag: para
#: type.xml:230
#, no-c-format
msgid "Registered under <literal>int</literal> and <literal>java.lang.Integer</literal>in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:239
#, no-c-format
msgid "<classname>java.lang.Long</classname> (or long primitive)"
msgstr ""

#. Tag: classname
#: type.xml:242
#, no-c-format
msgid "org.hibernate.type.LongType"
msgstr ""

#. Tag: para
#: type.xml:244
#, no-c-format
msgid "Maps a long or <classname>java.lang.Long</classname> to a JDBC BIGINT"
msgstr ""

#. Tag: para
#: type.xml:247
#, no-c-format
msgid "Registered under <literal>long</literal> and <literal>java.lang.Long</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:256
#, no-c-format
msgid "<classname>java.lang.Float</classname> (or float primitive)"
msgstr ""

#. Tag: classname
#: type.xml:259
#, no-c-format
msgid "org.hibernate.type.FloatType"
msgstr ""

#. Tag: para
#: type.xml:261
#, no-c-format
msgid "Maps a float or <classname>java.lang.Float</classname> to a JDBC FLOAT"
msgstr ""

#. Tag: para
#: type.xml:264
#, no-c-format
msgid "Registered under <literal>float</literal> and <literal>java.lang.Float</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:273
#, no-c-format
msgid "<classname>java.lang.Double</classname> (or double primitive)"
msgstr ""

#. Tag: classname
#: type.xml:276
#, no-c-format
msgid "org.hibernate.type.DoubleType"
msgstr ""

#. Tag: para
#: type.xml:278
#, no-c-format
msgid "Maps a double or <classname>java.lang.Double</classname> to a JDBC DOUBLE"
msgstr ""

#. Tag: para
#: type.xml:281
#, no-c-format
msgid "Registered under <literal>double</literal> and <literal>java.lang.Double</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:290
#, no-c-format
msgid "java.math.BigInteger"
msgstr ""

#. Tag: classname
#: type.xml:293
#, no-c-format
msgid "org.hibernate.type.BigIntegerType"
msgstr ""

#. Tag: para
#: type.xml:295
#, no-c-format
msgid "Maps a <classname>java.math.BigInteger</classname> to a JDBC NUMERIC"
msgstr ""

#. Tag: para
#: type.xml:298
#, no-c-format
msgid "Registered under <literal>big_integer</literal> and <literal>java.math.BigInteger</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:307
#, no-c-format
msgid "java.math.BigDecimal"
msgstr ""

#. Tag: classname
#: type.xml:310
#, no-c-format
msgid "org.hibernate.type.BigDecimalType"
msgstr ""

#. Tag: para
#: type.xml:312
#, no-c-format
msgid "Maps a <classname>java.math.BigDecimal</classname> to a JDBC NUMERIC"
msgstr ""

#. Tag: para
#: type.xml:315
#, no-c-format
msgid "Registered under <literal>big_decimal</literal> and <literal>java.math.BigDecimal</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:324
#, no-c-format
msgid "<classname>java.util.Date</classname> or <classname>java.sql.Timestamp</classname>"
msgstr ""

#. Tag: classname
#: type.xml:327
#, no-c-format
msgid "org.hibernate.type.TimestampType"
msgstr ""

#. Tag: para
#: type.xml:329
#, no-c-format
msgid "Maps a <classname>java.sql.Timestamp</classname> to a JDBC TIMESTAMP"
msgstr ""

#. Tag: para
#: type.xml:332
#, no-c-format
msgid "Registered under <literal>timestamp</literal>, <literal>java.sql.Timestamp</literal> and <literal>java.util.Date</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:341
#, no-c-format
msgid "java.sql.Time"
msgstr ""

#. Tag: classname
#: type.xml:344
#, no-c-format
msgid "org.hibernate.type.TimeType"
msgstr ""

#. Tag: para
#: type.xml:346
#, no-c-format
msgid "Maps a <classname>java.sql.Time</classname> to a JDBC TIME"
msgstr ""

#. Tag: para
#: type.xml:349
#, no-c-format
msgid "Registered under <literal>time</literal> and <literal>java.sql.Time</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:358
#, no-c-format
msgid "java.sql.Date"
msgstr ""

#. Tag: classname
#: type.xml:361
#, no-c-format
msgid "org.hibernate.type.DateType"
msgstr ""

#. Tag: para
#: type.xml:363
#, no-c-format
msgid "Maps a <classname>java.sql.Date</classname> to a JDBC DATE"
msgstr ""

#. Tag: para
#: type.xml:366
#, no-c-format
msgid "Registered under <literal>date</literal> and <literal>java.sql.Date</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:375
#, no-c-format
msgid "java.util.Calendar"
msgstr ""

#. Tag: classname
#: type.xml:378
#, no-c-format
msgid "org.hibernate.type.CalendarType"
msgstr ""

#. Tag: para
#: type.xml:380
#, no-c-format
msgid "Maps a <classname>java.util.Calendar</classname> to a JDBC TIMESTAMP"
msgstr ""

#. Tag: para
#: type.xml:383
#, no-c-format
msgid "Registered under <literal>calendar</literal>, <literal>java.util.Calendar</literal> and <literal>java.util.GregorianCalendar</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:391
#, no-c-format
msgid "org.hibernate.type.CalendarDateType"
msgstr ""

#. Tag: para
#: type.xml:393
#, no-c-format
msgid "Maps a <classname>java.util.Calendar</classname> to a JDBC DATE"
msgstr ""

#. Tag: para
#: type.xml:396
#, no-c-format
msgid "Registered under <literal>calendar_date</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:405
#, no-c-format
msgid "java.util.Currency"
msgstr ""

#. Tag: classname
#: type.xml:408
#, no-c-format
msgid "org.hibernate.type.CurrencyType"
msgstr ""

#. Tag: para
#: type.xml:410
#, no-c-format
msgid "Maps a <classname>java.util.Currency</classname> to a JDBC VARCHAR (using the Currency code)"
msgstr ""

#. Tag: para
#: type.xml:413
#, no-c-format
msgid "Registered under <literal>currency</literal> and <literal>java.util.Currency</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:422
#, no-c-format
msgid "java.util.Locale"
msgstr ""

#. Tag: classname
#: type.xml:425
#, no-c-format
msgid "org.hibernate.type.LocaleType"
msgstr ""

#. Tag: para
#: type.xml:427
#, no-c-format
msgid "Maps a <classname>java.util.Locale</classname> to a JDBC VARCHAR (using the Locale code)"
msgstr ""

#. Tag: para
#: type.xml:430
#, no-c-format
msgid "Registered under <literal>locale</literal> and <literal>java.util.Locale</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:439
#, no-c-format
msgid "java.util.TimeZone"
msgstr ""

#. Tag: classname
#: type.xml:442
#, no-c-format
msgid "org.hibernate.type.TimeZoneType"
msgstr ""

#. Tag: para
#: type.xml:444
#, no-c-format
msgid "Maps a <classname>java.util.TimeZone</classname> to a JDBC VARCHAR (using the TimeZone ID)"
msgstr ""

#. Tag: para
#: type.xml:447
#, no-c-format
msgid "Registered under <literal>timezone</literal> and <literal>java.util.TimeZone</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:456
#, no-c-format
msgid "java.net.URL"
msgstr ""

#. Tag: classname
#: type.xml:459
#, no-c-format
msgid "org.hibernate.type.UrlType"
msgstr ""

#. Tag: para
#: type.xml:461
#, no-c-format
msgid "Maps a <classname>java.net.URL</classname> to a JDBC VARCHAR (using the external form)"
msgstr ""

#. Tag: para
#: type.xml:464
#, no-c-format
msgid "Registered under <literal>url</literal> and <literal>java.net.URL</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:473
#, no-c-format
msgid "java.lang.Class"
msgstr ""

#. Tag: classname
#: type.xml:476
#, no-c-format
msgid "org.hibernate.type.ClassType"
msgstr ""

#. Tag: para
#: type.xml:478
#, no-c-format
msgid "Maps a <classname>java.lang.Class</classname> to a JDBC VARCHAR (using the Class name)"
msgstr ""

#. Tag: para
#: type.xml:481
#, no-c-format
msgid "Registered under <literal>class</literal> and <literal>java.lang.Class</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:490
#, no-c-format
msgid "java.sql.Blob"
msgstr ""

#. Tag: classname
#: type.xml:493
#, no-c-format
msgid "org.hibernate.type.BlobType"
msgstr ""

#. Tag: para
#: type.xml:495
#, no-c-format
msgid "Maps a <classname>java.sql.Blob</classname> to a JDBC BLOB"
msgstr ""

#. Tag: para
#: type.xml:498
#, no-c-format
msgid "Registered under <literal>blob</literal> and <literal>java.sql.Blob</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:507
#, no-c-format
msgid "java.sql.Clob"
msgstr ""

#. Tag: classname
#: type.xml:510
#, no-c-format
msgid "org.hibernate.type.ClobType"
msgstr ""

#. Tag: para
#: type.xml:512
#, no-c-format
msgid "Maps a <classname>java.sql.Clob</classname> to a JDBC CLOB"
msgstr ""

#. Tag: para
#: type.xml:515
#, no-c-format
msgid "Registered under <literal>clob</literal> and <literal>java.sql.Clob</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:524
#, no-c-format
msgid "byte[]"
msgstr ""

#. Tag: classname
#: type.xml:527 type.xml:568
#, no-c-format
msgid "org.hibernate.type.BinaryType"
msgstr ""

#. Tag: para
#: type.xml:529
#, no-c-format
msgid "Maps a primitive byte[] to a JDBC VARBINARY"
msgstr ""

#. Tag: para
#: type.xml:532
#, no-c-format
msgid "Registered under <literal>binary</literal> and <literal>byte[]</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:539
#, no-c-format
msgid "org.hibernate.type.MaterializedBlobType"
msgstr ""

#. Tag: para
#: type.xml:541
#, no-c-format
msgid "Maps a primitive byte[] to a JDBC BLOB"
msgstr ""

#. Tag: para
#: type.xml:544
#, no-c-format
msgid "Registered under <literal>materialized_blob</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:551
#, no-c-format
msgid "org.hibernate.type.ImageType"
msgstr ""

#. Tag: para
#: type.xml:553
#, no-c-format
msgid "Maps a primitive byte[] to a JDBC LONGVARBINARY"
msgstr ""

#. Tag: para
#: type.xml:556
#, no-c-format
msgid "Registered under <literal>image</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:565
#, no-c-format
msgid "Byte[]"
msgstr ""

#. Tag: para
#: type.xml:570
#, no-c-format
msgid "Maps a java.lang.Byte[] to a JDBC VARBINARY"
msgstr ""

#. Tag: para
#: type.xml:573
#, no-c-format
msgid "Registered under <literal>wrapper-binary</literal>, <literal>Byte[]</literal> and <literal>java.lang.Byte[]</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:582
#, no-c-format
msgid "char[]"
msgstr ""

#. Tag: classname
#: type.xml:585
#, no-c-format
msgid "org.hibernate.type.CharArrayType"
msgstr ""

#. Tag: para
#: type.xml:587
#, no-c-format
msgid "Maps a char[] to a JDBC VARCHAR"
msgstr ""

#. Tag: para
#: type.xml:590
#, no-c-format
msgid "Registered under <literal>characters</literal> and <literal>char[]</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: title
#: type.xml:599
#, no-c-format
msgid "Character[]"
msgstr ""

#. Tag: classname
#: type.xml:602
#, no-c-format
msgid "org.hibernate.type.CharacterArrayType"
msgstr ""

#. Tag: para
#: type.xml:604
#, no-c-format
msgid "Maps a java.lang.Character[] to a JDBC VARCHAR"
msgstr ""

#. Tag: para
#: type.xml:607
#, no-c-format
msgid "Registered under <literal>wrapper-characters</literal>, <literal>Character[]</literal> and <literal>java.lang.Character[]</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:616
#, no-c-format
msgid "java.util.UUID"
msgstr ""

#. Tag: classname
#: type.xml:619
#, no-c-format
msgid "org.hibernate.type.UUIDBinaryType"
msgstr ""

#. Tag: para
#: type.xml:621
#, no-c-format
msgid "Maps a java.util.UUID to a JDBC BINARY"
msgstr ""

#. Tag: para
#: type.xml:624
#, no-c-format
msgid "Registered under <literal>uuid-binary</literal> and <literal>java.util.UUID</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:631
#, no-c-format
msgid "org.hibernate.type.UUIDCharType"
msgstr ""

#. Tag: para
#: type.xml:633
#, no-c-format
msgid "Maps a java.util.UUID to a JDBC CHAR (though VARCHAR is fine too for existing schemas)"
msgstr ""

#. Tag: para
#: type.xml:636
#, no-c-format
msgid "Registered under <literal>uuid-char</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: classname
#: type.xml:643
#, no-c-format
msgid "org.hibernate.type.PostgresUUIDType"
msgstr ""

#. Tag: para
#: type.xml:645
#, no-c-format
msgid "Maps a java.util.UUID to the PostgreSQL UUID data type (through <literal>Types#OTHER</literal> which is how the PostgreSQL JDBC driver defines it)."
msgstr ""

#. Tag: para
#: type.xml:649
#, no-c-format
msgid "Registered under <literal>pg-uuid</literal> in the type registry (see <xref linkend=\"types-registry\"/>)."
msgstr ""

#. Tag: interfacename
#: type.xml:658
#, no-c-format
msgid "java.io.Serializable"
msgstr ""

#. Tag: classname
#: type.xml:661
#, no-c-format
msgid "org.hibernate.type.SerializableType"
msgstr ""

#. Tag: para
#: type.xml:663
#, no-c-format
msgid "Maps implementors of java.lang.Serializable to a JDBC VARBINARY"
msgstr ""

#. Tag: para
#: type.xml:666
#, no-c-format
msgid "Unlike the other value types, there are multiple instances of this type. It gets registered once under <interfacename>java.io.Serializable</interfacename>. Additionally it gets registered under the specific <interfacename>java.io.Serializable</interfacename> implementation class names."
msgstr ""

#. Tag: title
#: type.xml:679
#, no-c-format
msgid "Composite types"
msgstr ""

#. Tag: para
#: type.xml:681
#, no-c-format
msgid "The Java Persistence API calls these embedded types, while Hibernate traditionally called them components. Just be aware that both terms are used and mean the same thing in the scope of discussing Hibernate."
msgstr ""

#. Tag: para
#: type.xml:687
#, no-c-format
msgid "Components represent aggregations of values into a single Java type. For example, you might have an Address class that aggregates street, city, state, etc information or a Name class that aggregates the parts of a person's Name. In many ways a component looks exactly like an entity. They are both (generally speaking) classes written specifically for the application. They both might have references to other application-specific classes, as well as to collections and simple JDK types. As discussed before, the only distinguishing factory is the fact that a component does not own its own lifecycle nor does it define an identifier."
msgstr ""

#. Tag: title
#: type.xml:699
#, no-c-format
msgid "Collection types"
msgstr ""

#. Tag: para
#: type.xml:701
#, no-c-format
msgid "It is critical understand that we mean the collection itself, not its contents. The contents of the collection can in turn be basic, component or entity types (though not collections), but the collection itself is owned."
msgstr ""

#. Tag: para
#: type.xml:707
#, no-c-format
msgid "Collections are covered in <xref linkend=\"collections\"/>."
msgstr ""

#. Tag: title
#: type.xml:715
#, no-c-format
msgid "Entity types"
msgstr ""

#. Tag: para
#: type.xml:716
#, no-c-format
msgid "The definition of entities is covered in detail in <xref linkend=\"persistent-classes\"/>. For the purpose of this discussion, it is enough to say that entities are (generally application-specific) classes which correlate to rows in a table. Specifically they correlate to the row by means of a unique identifier. Because of this unique identifier, entities exist independently and define their own lifecycle. As an example, when we delete a <classname>Membership</classname>, both the <classname>User</classname> and <classname>Group</classname> entities remain."
msgstr ""

#. Tag: para
#: type.xml:724
#, no-c-format
msgid "This notion of entity independence can be modified by the application developer using the concept of cascades. Cascades allow certain operations to continue (or \"cascade\") across an association from one entity to another. Cascades are covered in detail in <xref linkend=\"associations\"/>."
msgstr ""

#. Tag: title
#: type.xml:734
#, no-c-format
msgid "Significance of type categories"
msgstr ""

#. Tag: para
#: type.xml:735
#, no-c-format
msgid "Why do we spend so much time categorizing the various types of types? What is the significance of the distinction?"
msgstr ""

#. Tag: para
#: type.xml:739
#, no-c-format
msgid "The main categorization was between entity types and value types. To review we said that entities, by nature of their unique identifier, exist independently of other objects whereas values do not. An application cannot \"delete\" a Product sku; instead, the sku is removed when the Product itself is deleted (obviously you can <emphasis>update</emphasis> the sku of that Product to null to make it \"go away\", but even there the access is done through the Product)."
msgstr ""

#. Tag: para
#: type.xml:746
#, no-c-format
msgid "Nor can you define an association <emphasis>to</emphasis> that Product sku. You <emphasis>can</emphasis> define an association to Product <emphasis>based on</emphasis> its sku, assuming sku is unique, but that is totally different."
msgstr ""

#. Tag: para
#: type.xml:751
#, no-c-format
msgid "TBC..."
msgstr ""

#. Tag: title
#: type.xml:757
#, no-c-format
msgid "Custom types"
msgstr ""

#. Tag: para
#: type.xml:758
#, no-c-format
msgid "Hibernate makes it relatively easy for developers to create their own <emphasis>value</emphasis> types. For example, you might want to persist properties of type <classname>java.lang.BigInteger</classname> to <literal>VARCHAR</literal> columns. Custom types are not limited to mapping values to a single table column. So, for example, you might want to concatenate together <literal>FIRST_NAME</literal>, <literal>INITIAL</literal> and <literal>SURNAME</literal> columns into a <classname>java.lang.String</classname>."
msgstr ""

#. Tag: para
#: type.xml:766
#, no-c-format
msgid "There are 3 approaches to developing a custom Hibernate type. As a means of illustrating the different approaches, lets consider a use case where we need to compose a <classname>java.math.BigDecimal</classname> and <classname>java.util.Currency</classname> together into a custom <classname>Money</classname> class."
msgstr ""

#. Tag: title
#: type.xml:773
#, no-c-format
msgid "Custom types using <interfacename>org.hibernate.type.Type</interfacename>"
msgstr ""

#. Tag: para
#: type.xml:774
#, no-c-format
msgid "The first approach is to directly implement the <interfacename>org.hibernate.type.Type</interfacename> interface (or one of its derivatives). Probably, you will be more interested in the more specific <interfacename>org.hibernate.type.BasicType</interfacename> contract which would allow registration of the type (see <xref linkend=\"types-registry\"/>). The benefit of this registration is that whenever the metadata for a particular property does not specify the Hibernate type to use, Hibernate will consult the registry for the exposed property type. In our example, the property type would be <classname>Money</classname>, which is the key we would use to register our type in the registry:"
msgstr ""

#. Tag: title
#: type.xml:785
#, no-c-format
msgid "Defining and registering the custom Type"
msgstr ""

#. Tag: programlisting
#: type.xml:786
#, no-c-format
msgid ""
      "<![CDATA[public class MoneyType implements BasicType {\n"
      "    public String[] getRegistrationKeys() {\n"
      "        return new String[] { Money.class.getName() };\n"
      "    }\n"
      "\n"
      "        public int[] sqlTypes(Mapping mapping) {\n"
      "            // We will simply use delegation to the standard basic types for BigDecimal and Currency for many of the\n"
      "            // Type methods...\n"
      "            return new int[] {\n"
      "                     BigDecimalType.INSTANCE.sqlType(),\n"
      "                     CurrencyType.INSTANCE.sqlType(),\n"
      "            };\n"
      "            // we could also have honored any registry overrides via...\n"
      "            //return new int[] {\n"
      "            //         mappings.getTypeResolver().basic( BigDecimal.class.getName() ).sqlTypes( mappings )[0],\n"
      "            //         mappings.getTypeResolver().basic( Currency.class.getName() ).sqlTypes( mappings )[0]\n"
      "            //};\n"
      "        }\n"
      "\n"
      "    public Class getReturnedClass() {\n"
      "        return Money.class;\n"
      "    }\n"
      "\n"
      "    public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner) throws SQLException {\n"
      "        assert names.length == 2;\n"
      "        BigDecimal amount = BigDecimalType.INSTANCE.get( names[0] ); // already handles null check\n"
      "        Currency currency = CurrencyType.INSTANCE.get( names[1] ); // already handles null check\n"
      "        return amount == null && currency == null\n"
      "                ? null\n"
      "                : new Money( amount, currency );\n"
      "    }\n"
      "\n"
      "    public void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable, SessionImplementor session)\n"
      "            throws SQLException {\n"
      "        if ( value == null ) {\n"
      "            BigDecimalType.INSTANCE.set( st, null, index );\n"
      "            CurrencyType.INSTANCE.set( st, null, index+1 );\n"
      "        }\n"
      "        else {\n"
      "            final Money money = (Money) value;\n"
      "            BigDecimalType.INSTANCE.set( st, money.getAmount(), index );\n"
      "            CurrencyType.INSTANCE.set( st, money.getCurrency(), index+1 );\n"
      "        }\n"
      "    }\n"
      "\n"
      "    ...\n"
      "}\n"
      "\n"
      "Configuration cfg = new Configuration();\n"
      "cfg.registerTypeOverride( new MoneyType() );\n"
      "cfg...;\n"
      "]]>"
msgstr ""

#. Tag: para
#: type.xml:789
#, no-c-format
msgid "It is important that we registered the type <emphasis>before</emphasis> adding mappings."
msgstr ""

#. Tag: title
#: type.xml:796
#, no-c-format
msgid "Custom types using <interfacename>org.hibernate.usertype.UserType</interfacename>"
msgstr ""

#. Tag: para
#: type.xml:798
#, no-c-format
msgid "Both <interfacename>org.hibernate.usertype.UserType</interfacename> and <interfacename>org.hibernate.usertype.CompositeUserType</interfacename> were originally added to isolate user code from internal changes to the <interfacename>org.hibernate.type.Type</interfacename> interfaces."
msgstr ""

#. Tag: para
#: type.xml:805
#, no-c-format
msgid "The second approach is the use the <interfacename>org.hibernate.usertype.UserType</interfacename> interface, which presents a somewhat simplified view of the <interfacename>org.hibernate.type.Type</interfacename> interface. Using a <interfacename>org.hibernate.usertype.UserType</interfacename>, our <classname>Money</classname> custom type would look as follows:"
msgstr ""

#. Tag: title
#: type.xml:812
#, no-c-format
msgid "Defining the custom UserType"
msgstr ""

#. Tag: programlisting
#: type.xml:813
#, no-c-format
msgid ""
      "<![CDATA[public class MoneyType implements UserType {\n"
      "    public int[] sqlTypes() {\n"
      "        return new int[] {\n"
      "                BigDecimalType.INSTANCE.sqlType(),\n"
      "                CurrencyType.INSTANCE.sqlType(),\n"
      "        };\n"
      "    }\n"
      "\n"
      "    public Class getReturnedClass() {\n"
      "        return Money.class;\n"
      "    }\n"
      "\n"
      "    public Object nullSafeGet(ResultSet rs, String[] names, Object owner) throws SQLException {\n"
      "        assert names.length == 2;\n"
      "        BigDecimal amount = BigDecimalType.INSTANCE.get( names[0] ); // already handles null check\n"
      "        Currency currency = CurrencyType.INSTANCE.get( names[1] ); // already handles null check\n"
      "        return amount == null && currency == null\n"
      "                ? null\n"
      "                : new Money( amount, currency );\n"
      "    }\n"
      "\n"
      "    public void nullSafeSet(PreparedStatement st, Object value, int index) throws SQLException {\n"
      "        if ( value == null ) {\n"
      "            BigDecimalType.INSTANCE.set( st, null, index );\n"
      "            CurrencyType.INSTANCE.set( st, null, index+1 );\n"
      "        }\n"
      "        else {\n"
      "            final Money money = (Money) value;\n"
      "            BigDecimalType.INSTANCE.set( st, money.getAmount(), index );\n"
      "            CurrencyType.INSTANCE.set( st, money.getCurrency(), index+1 );\n"
      "        }\n"
      "    }\n"
      "\n"
      "    ...\n"
      "}]]>"
msgstr ""

#. Tag: para
#: type.xml:815
#, no-c-format
msgid "There is not much difference between the <interfacename>org.hibernate.type.Type</interfacename> example and the <interfacename>org.hibernate.usertype.UserType</interfacename> example, but that is only because of the snippets shown. If you choose the <interfacename>org.hibernate.type.Type</interfacename> approach there are quite a few more methods you would need to implement as compared to the <interfacename>org.hibernate.usertype.UserType</interfacename>."
msgstr ""

#. Tag: title
#: type.xml:825
#, no-c-format
msgid "Custom types using <interfacename>org.hibernate.usertype.CompositeUserType</interfacename>"
msgstr ""

#. Tag: para
#: type.xml:826
#, no-c-format
msgid "The third and final approach is the use the <interfacename>org.hibernate.usertype.CompositeUserType</interfacename> interface, which differs from <interfacename>org.hibernate.usertype.UserType</interfacename> in that it gives us the ability to provide Hibernate the information to handle the composition within the <classname>Money</classname> class (specifically the 2 attributes). This would give us the capability, for example, to reference the <literal>amount</literal> attribute in an HQL query. Using a <interfacename>org.hibernate.usertype.CompositeUserType</interfacename>, our <classname>Money</classname> custom type would look as follows:"
msgstr ""

#. Tag: title
#: type.xml:837
#, no-c-format
msgid "Defining the custom CompositeUserType"
msgstr ""

#. Tag: programlisting
#: type.xml:838
#, no-c-format
msgid ""
      "<![CDATA[public class MoneyType implements CompositeUserType {\n"
      "    public String[] getPropertyNames() {\n"
      "        // ORDER IS IMPORTANT!  it must match the order the columns are defined in the property mapping\n"
      "        return new String[] { \"amount\", \"currency\" };\n"
      "    }\n"
      "\n"
      "    public Type[] getPropertyTypes() {\n"
      "        return new Type[] { BigDecimalType.INSTANCE, CurrencyType.INSTANCE };\n"
      "    }\n"
      "\n"
      "    public Class getReturnedClass() {\n"
      "        return Money.class;\n"
      "    }\n"
      "\n"
      "    public Object getPropertyValue(Object component, int propertyIndex) {\n"
      "        if ( component == null ) {\n"
      "            return null;\n"
      "        }\n"
      "\n"
      "        final Money money = (Money) component;\n"
      "        switch ( propertyIndex ) {\n"
      "            case 0: {\n"
      "                return money.getAmount();\n"
      "            }\n"
      "            case 1: {\n"
      "                return money.getCurrency();\n"
      "            }\n"
      "            default: {\n"
      "                throw new HibernateException( \"Invalid property index [\" + propertyIndex + \"]\" );\n"
      "            }\n"
      "        }\n"
      "    }\n"
      "\n"
      "        public void setPropertyValue(Object component, int propertyIndex, Object value) throws HibernateException {\n"
      "        if ( component == null ) {\n"
      "            return;\n"
      "        }\n"
      "\n"
      "        final Money money = (Money) component;\n"
      "        switch ( propertyIndex ) {\n"
      "            case 0: {\n"
      "                money.setAmount( (BigDecimal) value );\n"
      "                break;\n"
      "            }\n"
      "            case 1: {\n"
      "                money.setCurrency( (Currency) value );\n"
      "                break;\n"
      "            }\n"
      "            default: {\n"
      "                throw new HibernateException( \"Invalid property index [\" + propertyIndex + \"]\" );\n"
      "            }\n"
      "        }\n"
      "        }\n"
      "\n"
      "    public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner) throws SQLException {\n"
      "        assert names.length == 2;\n"
      "        BigDecimal amount = BigDecimalType.INSTANCE.get( names[0] ); // already handles null check\n"
      "        Currency currency = CurrencyType.INSTANCE.get( names[1] ); // already handles null check\n"
      "        return amount == null && currency == null\n"
      "                ? null\n"
      "                : new Money( amount, currency );\n"
      "    }\n"
      "\n"
      "    public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session) throws SQLException {\n"
      "        if ( value == null ) {\n"
      "            BigDecimalType.INSTANCE.set( st, null, index );\n"
      "            CurrencyType.INSTANCE.set( st, null, index+1 );\n"
      "        }\n"
      "        else {\n"
      "            final Money money = (Money) value;\n"
      "            BigDecimalType.INSTANCE.set( st, money.getAmount(), index );\n"
      "            CurrencyType.INSTANCE.set( st, money.getCurrency(), index+1 );\n"
      "        }\n"
      "    }\n"
      "\n"
      "    ...\n"
      "}]]>"
msgstr ""

#. Tag: title
#: type.xml:845
#, no-c-format
msgid "Type registry"
msgstr ""

#. Tag: para
#: type.xml:846
#, no-c-format
msgid "Internally Hibernate uses a registry of basic types (see <xref linkend=\"types-value-basic\"/>) when it needs to resolve the specific <interfacename>org.hibernate.type.Type</interfacename> to use in certain situations. It also provides a way for applications to add extra basic type registrations as well as override the standard basic type registrations."
msgstr ""

#. Tag: para
#: type.xml:852
#, no-c-format
msgid "To register a new type or to override an existing type registration, applications would make use of the <methodname>registerTypeOverride</methodname> method of the <classname>org.hibernate.cfg.Configuration</classname> class when bootstrapping Hibernate. For example, lets say you want Hibernate to use your custom <classname>SuperDuperStringType</classname>; during bootstrap you would call:"
msgstr ""

#. Tag: title
#: type.xml:859
#, no-c-format
msgid "Overriding the standard <classname>StringType</classname>"
msgstr ""

#. Tag: programlisting
#: type.xml:860
#, no-c-format
msgid ""
      "<![CDATA[Configuration cfg = ...;\n"
      "cfg.registerTypeOverride( new SuperDuperStringType() );]]>"
msgstr ""

#. Tag: para
#: type.xml:862
#, no-c-format
msgid "The argument to <methodname>registerTypeOverride</methodname> is a <interfacename>org.hibernate.type.BasicType</interfacename> which is a specialization of the <interfacename>org.hibernate.type.Type</interfacename> we saw before. It adds a single method:"
msgstr ""

#. Tag: title
#: type.xml:868
#, no-c-format
msgid "Snippet from BasicType.java"
msgstr ""

#. Tag: programlisting
#: type.xml:869
#, no-c-format
msgid ""
      "/**\n"
      "         * Get the names under which this type should be registered in the type registry.\n"
      "         *\n"
      "         * @return The keys under which to register this type.\n"
      "         */\n"
      "        public String[] getRegistrationKeys();"
msgstr ""

#. Tag: para
#: type.xml:871
#, no-c-format
msgid "One approach is to use inheritance (<classname>SuperDuperStringType</classname> extends <classname>org.hibernate.type.StringType</classname>); another is to use delegation."
msgstr ""

