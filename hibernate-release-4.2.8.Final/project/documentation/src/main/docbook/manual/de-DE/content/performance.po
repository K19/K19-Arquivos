# translation of Collection_Mapping.po to 
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# Language /mnt/hgfs/base/Hibernate/Reference translations for PACKAGE package.
# Copyright (C) 2006, 2007 Free Software Foundation, Inc.
# Automatically generated, 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
#
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-20 21:02+0000\n"
"PO-Revision-Date: 2007-02-26 10:27+1000\n"
"Last-Translator: \n"
"Language-Team:  <de@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.9.1\n"

#. Tag: title
#: performance.xml:31
#, no-c-format
msgid "Improving performance"
msgstr "Verbesserung der Performance"

#. Tag: title
#: performance.xml:34
#, no-c-format
msgid "Fetching strategies"
msgstr "Abrufstrategien"

#. Tag: para
#: performance.xml:36
#, fuzzy, no-c-format
msgid ""
"Hibernate uses a <emphasis>fetching strategy</emphasis> to retrieve "
"associated objects if the application needs to navigate the association. "
"Fetch strategies can be declared in the O/R mapping metadata, or over-ridden "
"by a particular HQL or <literal>Criteria</literal> query."
msgstr ""
"Eine <emphasis>Abrufstrategie</emphasis> (sog. \"Fetching Strategy\") ist "
"die Abrufstrategie, die Hibernate beim Abruf assoziierter Objekte verwendet, "
"wenn die Anwendung die Assoziation navigieren muss. Abrufstrategien können "
"in den O/R Mapping-Metadaten deklariert werden oder durch eine bestimmte HQL "
"oder <literal>Criteria</literal>-Anfrage außer Kraft gesetzt werden."

#. Tag: para
#: performance.xml:42
#, no-c-format
msgid "Hibernate3 defines the following fetching strategies:"
msgstr "Hibernate3 definiert die folgenden Abrufstrategien:"

#. Tag: para
#: performance.xml:46
#, fuzzy, no-c-format
msgid ""
"<emphasis>Join fetching</emphasis>: Hibernate retrieves the associated "
"instance or collection in the same <literal>SELECT</literal>, using an "
"<literal>OUTER JOIN</literal>."
msgstr ""
"<emphasis>\"Join Fetching\"</emphasis> - Hibernate ruft unter Verwendung von "
"<literal>OUTER JOIN</literal> die zugehörige Instanz oder Collection im "
"selben <literal>SELECT</literal> auf."

#. Tag: para
#: performance.xml:53
#, fuzzy, no-c-format
msgid ""
"<emphasis>Select fetching</emphasis>: a second <literal>SELECT</literal> is "
"used to retrieve the associated entity or collection. Unless you explicitly "
"disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this "
"second select will only be executed when you access the association."
msgstr ""
"<emphasis>\"Select Fetching\"</emphasis> - ein zweites <literal>SELECT</"
"literal> wird für den Abruf der assoziierten Entity oder Collection "
"verwendet. Falls Sie nicht explizit das \"lazy Fetching\" (d.h. das "
"Nachladen assoziierter Objekte bei Bedarf) durch Spezifizierung von "
"<literal>lazy=\"false\"</literal> deaktivieren, wird dieses zweite \"Select"
"\" nur ausgeführt, wenn Sie tatsächlich auf die Assoziation zugreifen."

#. Tag: para
#: performance.xml:61
#, fuzzy, no-c-format
msgid ""
"<emphasis>Subselect fetching</emphasis>: a second <literal>SELECT</literal> "
"is used to retrieve the associated collections for all entities retrieved in "
"a previous query or fetch. Unless you explicitly disable lazy fetching by "
"specifying <literal>lazy=\"false\"</literal>, this second select will only "
"be executed when you access the association."
msgstr ""
"<emphasis>\"Subselect Fetching\"</emphasis> - ein zweites <literal>SELECT</"
"literal> wird verwendet, um die assoziierten Collections für alle in einer "
"vorausgegangenen Anfrage oder Abruf erhaltenen Entities abzurufen. Falls Sie "
"\"lazy Fetching\" nicht durch <literal>lazy=\"false\"</literal> explizit "
"deaktivieren, wird dieses zweite \"Select\" nur ausgeführt, wenn Sie "
"tatsächlich auf die Assoziation zugreifen."

#. Tag: para
#: performance.xml:70
#, fuzzy, no-c-format
msgid ""
"<emphasis>Batch fetching</emphasis>: an optimization strategy for select "
"fetching. Hibernate retrieves a batch of entity instances or collections in "
"a single <literal>SELECT</literal> by specifying a list of primary or "
"foreign keys."
msgstr ""
"<emphasis>Stapelabruf</emphasis> (sog. \"Batch Fetching\") - eine "
"Optimierungsstrategie für die Abrufauswahl - Hibernate ruft einen Stapel von "
"Entity-Instanzen oder Collections in einem einzelnen <literal>SELECT</"
"literal> ab, indem es eine Liste von Primärschlüsseln oder Fremdschlüsseln "
"bestimmt."

#. Tag: para
#: performance.xml:77
#, no-c-format
msgid "Hibernate also distinguishes between:"
msgstr "Hibernate unterscheidet außerdem zwischen:"

#. Tag: para
#: performance.xml:81
#, fuzzy, no-c-format
msgid ""
"<emphasis>Immediate fetching</emphasis>: an association, collection or "
"attribute is fetched immediately when the owner is loaded."
msgstr ""
"<emphasis>\"Immediate Fetching\"</emphasis> (d.h. sofortiger Abruf) - eine "
"Assoziation, Collection oder Attribut werden beim Laden des Eigentümers "
"sofort abgerufen."

#. Tag: para
#: performance.xml:87
#, fuzzy, no-c-format
msgid ""
"<emphasis>Lazy collection fetching</emphasis>: a collection is fetched when "
"the application invokes an operation upon that collection. This is the "
"default for collections."
msgstr ""
"<emphasis>\"Lazy Collection Fetching\"</emphasis> - eine Collection wird "
"abgerufen, wenn die Anwendung einen Vorgang an dieser Collection aufruft. "
"(Das ist die Standardeinstellung für Collections)."

#. Tag: para
#: performance.xml:93
#, fuzzy, no-c-format
msgid ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis>: individual elements "
"of the collection are accessed from the database as needed. Hibernate tries "
"not to fetch the whole collection into memory unless absolutely needed. It "
"is suitable for large collections."
msgstr ""
"<emphasis>\"Extra-lazy Collection Fetching\"</emphasis> - auf einzelne "
"Elemente der Collection wird je nach Bedarf in der Datenbank zugegriffen. "
"Hibernate versucht, nicht die gesamte Collection in den Speicher aufzurufen, "
"außer es ist unbedingt nötig (besonders geeignet für sehr große Collections)."

#. Tag: para
#: performance.xml:101
#, fuzzy, no-c-format
msgid ""
"<emphasis>Proxy fetching</emphasis>: a single-valued association is fetched "
"when a method other than the identifier getter is invoked upon the "
"associated object."
msgstr ""
"<emphasis>\"Proxy Fetching\"</emphasis> (d.h. Proxy-Abruf) - eine einwertige "
"Assoziation wird abgerufen, wenn eine andere Methode als Bezeichner-\"Getter"
"\" am zugehörigen Objekt aufgerufen wird."

#. Tag: para
#: performance.xml:107
#, fuzzy, no-c-format
msgid ""
"<emphasis>\"No-proxy\" fetching</emphasis>: a single-valued association is "
"fetched when the instance variable is accessed. Compared to proxy fetching, "
"this approach is less lazy; the association is fetched even when only the "
"identifier is accessed. It is also more transparent, since no proxy is "
"visible to the application. This approach requires buildtime bytecode "
"instrumentation and is rarely necessary."
msgstr ""
"<emphasis>\"No-Proxy-Fetching\"</emphasis> - eine einwertige Assoziation "
"wird abgerufen, wenn auf die Instanzvariable zugegriffen wird. Im Vergleich "
"zu Proxy-Fetching, ist diese Herangehensweise weniger \"lazy\" (die "
"Assoziation wird sogar abgerufen wenn nur auf den Bezeichner zugegriffen "
"wird), jedoch transparenter, da für die Anwendung kein Proxy sichtbar ist. "
"Diese Vorgehensweise erfordert Buildtime Bytecode Instrumentierung und wird "
"selten benötigt."

#. Tag: para
#: performance.xml:117
#, fuzzy, no-c-format
msgid ""
"<emphasis>Lazy attribute fetching</emphasis>: an attribute or single valued "
"association is fetched when the instance variable is accessed. This approach "
"requires buildtime bytecode instrumentation and is rarely necessary."
msgstr ""
"<emphasis>\"Lazy Attribute Fetching</emphasis> - ein Attribut oder eine "
"einwertige Assoziation werden abgerufen, wenn auf die Instanzvariable "
"zugegriffen wird. Diese Vorgehensweise erfordert Buildtime Bytecode "
"Instrumentierung und wird selten benötigt."

#. Tag: para
#: performance.xml:124
#, fuzzy, no-c-format
msgid ""
"We have two orthogonal notions here: <emphasis>when</emphasis> is the "
"association fetched and <emphasis>how</emphasis> is it fetched. It is "
"important that you do not confuse them. We use <literal>fetch</literal> to "
"tune performance. We can use <literal>lazy</literal> to define a contract "
"for what data is always available in any detached instance of a particular "
"class."
msgstr ""
"Es gibt hier zwei orthogonale Begriffe: <emphasis>Wann</emphasis> die "
"Assoziation abgerufen wird und <emphasis>wie</emphasis> sie abgerufen wird "
"(welche SQL verwendet wird). Verwechseln Sie diese nicht! Wir verwenden "
"<literal>fetch</literal>, um die Performance abzustimmen. Wir können "
"<literal>lazy</literal> verwenden, um ein Interface (sog. \"contract\") "
"darüber zu definieren, welche Daten in sämtlichen abgesetzten Instanzen "
"einer bestimmten Klasse stets verfügbar sind."

#. Tag: title
#: performance.xml:132
#, no-c-format
msgid "Working with lazy associations"
msgstr "Der Umgang mit \"lazy\"-Assoziationen"

#. Tag: para
#: performance.xml:134
#, fuzzy, no-c-format
msgid ""
"By default, Hibernate3 uses lazy select fetching for collections and lazy "
"proxy fetching for single-valued associations. These defaults make sense for "
"most associations in the majority of applications."
msgstr ""
"In der Standardeinstellung verwendet Hibernate3 \"lazy\" Auswahlabruf für "
"Collections und \"lazy\" Proxy-Abruf für einwertige Assoziationen. Diese "
"Standardeinstellung ist für nahezu alle Assoziationen in den meisten "
"Anwendungen sinnvoll."

#. Tag: para
#: performance.xml:138
#, fuzzy, no-c-format
msgid ""
"If you set <literal>hibernate.default_batch_fetch_size</literal>, Hibernate "
"will use the batch fetch optimization for lazy fetching. This optimization "
"can also be enabled at a more granular level."
msgstr ""
"<emphasis>Hinweis:</emphasis> Wenn Sie <literal>hibernate."
"default_batch_fetch_size</literal> setzen, so verwendet Hibernate die "
"Stapelabrufoptimierung für \"lazy\" Fetching (diese Optimierung kann auch "
"auf feinkörnigerer Ebene aktiviert werden)."

#. Tag: para
#: performance.xml:142
#, fuzzy, no-c-format
msgid ""
"Please be aware that access to a lazy association outside of the context of "
"an open Hibernate session will result in an exception. For example:"
msgstr ""
"Jedoch stellt sich beim \"lazy\" Fetching ein Problem, dessen Sie sich "
"bewusst sein sollten: Der Zugriff auf eine \"lazy\" Assoziation außerhalb "
"des Kontexts einer geöffneten Hibernate Session führt zu einer "
"Ausnahmemeldung. Zum Beispiel:"

#. Tag: programlisting
#: performance.xml:146
#, fuzzy, no-c-format
msgid ""
"s = sessions.openSession();\n"
"Transaction tx = s.beginTransaction();\n"
"            \n"
"User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
"    .setString(\"userName\", userName).uniqueResult();\n"
"Map permissions = u.getPermissions();\n"
"\n"
"tx.commit();\n"
"s.close();\n"
"\n"
"Integer accessLevel = (Integer) permissions.get(\"accounts\");  // Error!"
msgstr ""
"s = sessions.openSession();\n"
"Transaction tx = s.beginTransaction();\n"
"            \n"
"User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
"    .setString(\"userName\", userName).uniqueResult();\n"
"Map permissions = u.getPermissions();\n"
"\n"
"tx.commit();\n"
"s.close();\n"
"\n"
"Integer accessLevel = (Integer) permissions.get(\"accounts\");  // Error!"

#. Tag: para
#: performance.xml:148
#, fuzzy, no-c-format
msgid ""
"Since the permissions collection was not initialized when the "
"<literal>Session</literal> was closed, the collection will not be able to "
"load its state. <emphasis>Hibernate does not support lazy initialization for "
"detached objects</emphasis>. This can be fixed by moving the code that reads "
"from the collection to just before the transaction is committed."
msgstr ""
"Da die \"Permissions\"-Collection nicht initialisiert war als die "
"<literal>Session</literal> geschlossen wurde, wird die Collection den Status "
"nicht laden können. <emphasis>Hibernate unterstützt keine \"lazy\" "
"Initialisierung für abgesetzte Objekte</emphasis>. Die Lösung besteht darin, "
"den Code, der die Collection liest, erst unmittelbar ehe die Transaktion "
"festgeschrieben wird, zu bewegen."

#. Tag: para
#: performance.xml:155
#, fuzzy, no-c-format
msgid ""
"Alternatively, you can use a non-lazy collection or association, by "
"specifying <literal>lazy=\"false\"</literal> for the association mapping. "
"However, it is intended that lazy initialization be used for almost all "
"collections and associations. If you define too many non-lazy associations "
"in your object model, Hibernate will fetch the entire database into memory "
"in every transaction."
msgstr ""
"Alternativ könnten Sie eine nicht-\"lazy\" Collection oder Assoziation "
"verwenden, indem Sie <literal>lazy=\"false\"</literal> für das "
"Assoziationsmapping festlegen. Es ist jedoch vorgesehen, dass \"lazy\" "
"Initialisierung für fast alle Collections und Assoziationen verwendet wird. "
"Wenn Sie in Ihrem Objektmodell zu viele nicht-\"lazy\" Assoziationen "
"definieren, wird Hibernate am Ende für jede Transaktion die gesamte "
"Datenbank in den Speicher abrufen müssen!"

#. Tag: para
#: performance.xml:162
#, fuzzy, no-c-format
msgid ""
"On the other hand, you can use join fetching, which is non-lazy by nature, "
"instead of select fetching in a particular transaction. We will now explain "
"how to customize the fetching strategy. In Hibernate3, the mechanisms for "
"choosing a fetch strategy are identical for single-valued associations and "
"collections."
msgstr ""
"Andererseits wollen wir oft \"Join\"-Fetching (das von Natur aus nicht \"lazy"
"\" ist) anstelle des Auswahlabrufs (sog. \"Select-Fetching\") in einer "
"bestimmten Transaktion verwenden. Wir wollen nun einen Blick darauf werfen, "
"wie eine Abrufstrategie individuell angepasst werden kann. In Hibernate3 ist "
"der Mechanismus zur Auswahl einer Abrufstrategie für einwertige "
"Assoziationen und Collections identisch."

#. Tag: title
#: performance.xml:170
#, no-c-format
msgid "Tuning fetch strategies"
msgstr "Abstimmung von Abrufstrategien"

#. Tag: para
#: performance.xml:172
#, no-c-format
msgid ""
"Select fetching (the default) is extremely vulnerable to N+1 selects "
"problems, so we might want to enable join fetching in the mapping document:"
msgstr ""
"Der Auswahlabruf - \"Select Fetching\" (Standard) ist extrem anfällig für N"
"+1 Auswahlprobleme, weswegen sich die Aktivierung von \"Join-Fetching\" im "
"Mapping-Dokument empfiehlt:"

#. Tag: programlisting
#: performance.xml:176
#, fuzzy, no-c-format
msgid ""
"&lt;set name=\"permissions\"\n"
"            fetch=\"join\"&gt;\n"
"    &lt;key column=\"userId\"/&gt;\n"
"    &lt;one-to-many class=\"Permission\"/&gt;\n"
"&lt;/set"
msgstr ""
"&lt;set name=\"permissions\" \n"
"            fetch=\"join\"&gt;\n"
"    &lt;key column=\"userId\"/&gt;\n"
"    &lt;one-to-many class=\"Permission\"/&gt;\n"
"&lt;/set"

#. Tag: programlisting
#: performance.xml:178
#, fuzzy, no-c-format
msgid "&lt;many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/&gt;"
msgstr "&lt;many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/&gt;"

#. Tag: para
#: performance.xml:180
#, no-c-format
msgid ""
"The <literal>fetch</literal> strategy defined in the mapping document "
"affects:"
msgstr ""
"Die im Mapping-Dokument definierte <literal>fetch</literal>-Strategie hat "
"Auswirkungen auf:"

#. Tag: para
#: performance.xml:185
#, no-c-format
msgid "retrieval via <literal>get()</literal> or <literal>load()</literal>"
msgstr "Abruf mittels <literal>get()</literal> oder <literal>load()</literal>"

#. Tag: para
#: performance.xml:190
#, no-c-format
msgid "retrieval that happens implicitly when an association is navigated"
msgstr "einem impliziten Abruf, der beim Navigieren der Assoziation erfolgt"

#. Tag: para
#: performance.xml:195
#, no-c-format
msgid "<literal>Criteria</literal> queries"
msgstr "<literal>Criteria</literal>-Anfragen"

#. Tag: para
#: performance.xml:199
#, no-c-format
msgid "HQL queries if <literal>subselect</literal> fetching is used"
msgstr "HQL-Anfragen, wenn <literal>subselect</literal>-Abruf verwendet wird"

#. Tag: para
#: performance.xml:204
#, fuzzy, no-c-format
msgid ""
"Irrespective of the fetching strategy you use, the defined non-lazy graph is "
"guaranteed to be loaded into memory. This might, however, result in several "
"immediate selects being used to execute a particular HQL query."
msgstr ""
"Unabhängig davon, welche Abrufstrategie Sie verwenden wird das definierte "
"nicht-\"lazy\" Diagramm garantiert im Speicher geladen. Bitte beachten Sie, "
"dass dies zur Verwendung von mehreren unmittelbaren \"Selects\" bei der "
"Ausführung einer bestimmten HQL-Anfrage führen kann."

#. Tag: para
#: performance.xml:209
#, fuzzy, no-c-format
msgid ""
"Usually, the mapping document is not used to customize fetching. Instead, we "
"keep the default behavior, and override it for a particular transaction, "
"using <literal>left join fetch</literal> in HQL. This tells Hibernate to "
"fetch the association eagerly in the first select, using an outer join. In "
"the <literal>Criteria</literal> query API, you would use "
"<literal>setFetchMode(FetchMode.JOIN)</literal>."
msgstr ""
"Normalerweise wird das Mapping-Dokument nicht für die Anpassung des Abrufs "
"verwendet. Stattdessen behalten wir das Standardverhalten und setzen es "
"mittels <literal>left join fetch</literal> in HQL für eine bestimmte "
"Transaktion außer Kraft. Dadurch setzt Hibernate bei der Assoziation im "
"ersten \"Select\" unter Verwendung eines \"outer Join\" \"eager Fetching\" "
"ein. Im <literal>Criteria</literal>-Anfragen API, würden Sie "
"<literal>setFetchMode(FetchMode.JOIN)</literal> benutzen."

#. Tag: para
#: performance.xml:216
#, fuzzy, no-c-format
msgid ""
"If you want to change the fetching strategy used by <literal>get()</literal> "
"or <literal>load()</literal>, you can use a <literal>Criteria</literal> "
"query. For example:"
msgstr ""
"Falls Sie die verwendete Abrufstrategie irgendwann ändern möchten, so können "
"Sie dies durch <literal>get()</literal> oder <literal>load()</literal> tun, "
"verwenden Sie einfach eine <literal>Criteria</literal>-Anfrage, zum Beispiel:"

#. Tag: programlisting
#: performance.xml:220
#, fuzzy, no-c-format
msgid ""
"User user = (User) session.createCriteria(User.class)\n"
"                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
"                .add( Restrictions.idEq(userId) )\n"
"                .uniqueResult();"
msgstr ""
"User user = (User) session.createCriteria(User.class)\n"
"                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
"                .add( Restrictions.idEq(userId) )\n"
"                .uniqueResult();"

#. Tag: para
#: performance.xml:222
#, fuzzy, no-c-format
msgid ""
"This is Hibernate's equivalent of what some ORM solutions call a \"fetch plan"
"\"."
msgstr ""
"(Das ist Hibernates Äquivalent zu dem, was einige ORM-Lösungen als Abrufplan "
"oder \"Fetch Plan\" bezeichnen)."

#. Tag: para
#: performance.xml:225
#, fuzzy, no-c-format
msgid ""
"A completely different approach to problems with N+1 selects is to use the "
"second-level cache."
msgstr ""
"Eine ganz andere Art Probleme mit N+1 \"Selects\" zu vermeiden, ist die "
"Verwendung des Cachespeichers der zweiten Ebene."

#. Tag: title
#: performance.xml:230
#, no-c-format
msgid "Single-ended association proxies"
msgstr "Einendige Assoziationsproxies"

#. Tag: para
#: performance.xml:232
#, fuzzy, no-c-format
msgid ""
"Lazy fetching for collections is implemented using Hibernate's own "
"implementation of persistent collections. However, a different mechanism is "
"needed for lazy behavior in single-ended associations. The target entity of "
"the association must be proxied. Hibernate implements lazy initializing "
"proxies for persistent objects using runtime bytecode enhancement which is "
"accessed via the CGLIB library."
msgstr ""
"\"Lazy-Fetching\" für Collections wird unter Verwendung von Hibernates "
"eigener Implementierung von persistenten Klassen implementiert. Für \"lazy-"
"Fetching\" in einendigen Assoziationen wird jedoch ein anderer Mechanismus "
"benötigt. Die Ziel-Entity der Assoziation muss geproxied werden. Hibernate "
"implementiert \"lazy\" Initialisierungsproxies für persistente Objekte unter "
"Verwendung von Runtime Bytecode-Steigerung (durch die hervorragende CGLIB-"
"Bibliothek)."

#. Tag: para
#: performance.xml:239
#, fuzzy, no-c-format
msgid ""
"At startup, Hibernate3 generates proxies by default for all persistent "
"classes and uses them to enable lazy fetching of <literal>many-to-one</"
"literal> and <literal>one-to-one</literal> associations."
msgstr ""
"Im Standard generiert Hibernate3 Proxies (beim Startup) für alle "
"persistenten Klassen und verwendet diese, um das \"lazy-Fetching\" von "
"<literal>many-to-one</literal> und <literal>one-to-one</literal>-"
"Assoziationen zu aktivieren."

#. Tag: para
#: performance.xml:244
#, fuzzy, no-c-format
msgid ""
"The mapping file may declare an interface to use as the proxy interface for "
"that class, with the <literal>proxy</literal> attribute. By default, "
"Hibernate uses a subclass of the class. <emphasis>The proxied class must "
"implement a default constructor with at least package visibility. This "
"constructor is recommended for all persistent classes</emphasis>."
msgstr ""
"Die Mapping-Datei kann mit dem <literal>proxy</literal>-Attribut ein als "
"Proxy-Interface zu verwendendes Interface deklarieren. In der "
"Standardeinstellung verwendet Hibernate eine Subklasse der Klasse. "
"<emphasis>Beachten Sie, das die geproxiete Klasse einen Standard-Konstruktor "
"mit mindestens Paket-Sichtbarkeit implementieren muss. Wir empfehlen diesen "
"Konstruktor für alle persistenten Klassen!</emphasis>"

#. Tag: para
#: performance.xml:251
#, fuzzy, no-c-format
msgid ""
"There are potential problems to note when extending this approach to "
"polymorphic classes.For example:"
msgstr ""
"Es gibt einige Fallstricke, derer man sich bewusst sein sollte, wenn man "
"diese Vorgehensweise zum Beispiel auf polymorphe Klassen ausweitet."

#. Tag: programlisting
#: performance.xml:254
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Cat\" proxy=\"Cat\"&gt;\n"
"    ......\n"
"    &lt;subclass name=\"DomesticCat\"&gt;\n"
"        .....\n"
"    &lt;/subclass&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Cat\" proxy=\"Cat\"&gt;\n"
"    ......\n"
"    &lt;subclass name=\"DomesticCat\"&gt;\n"
"        .....\n"
"    &lt;/subclass&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: performance.xml:256
#, no-c-format
msgid ""
"Firstly, instances of <literal>Cat</literal> will never be castable to "
"<literal>DomesticCat</literal>, even if the underlying instance is an "
"instance of <literal>DomesticCat</literal>:"
msgstr ""
"Zunächst einmal werden Instanzen von <literal>Cat</literal> hinsichtlich "
"ihres Datentyps niemals in <literal>DomesticCat</literal> konvertierbar "
"sein, selbst wenn die zu Grunde liegende Instanz eine Instanz von "
"<literal>DomesticCat</literal> ist:"

#. Tag: programlisting
#: performance.xml:260
#, fuzzy, no-c-format
msgid ""
"Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does "
"not hit the db)\n"
"if ( cat.isDomesticCat() ) {                  // hit the db to initialize "
"the proxy\n"
"    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
"    ....\n"
"}"
msgstr ""
"Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does "
"not hit the db)\n"
"if ( cat.isDomesticCat() ) {                  // hit the db to initialize "
"the proxy\n"
"    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
"    ....\n"
"}"

#. Tag: para
#: performance.xml:262
#, fuzzy, no-c-format
msgid "Secondly, it is possible to break proxy <literal>==</literal>:"
msgstr "Zweitens ist es möglich, Proxy <literal>==</literal> zu brechen."

#. Tag: programlisting
#: performance.xml:265
#, fuzzy, no-c-format
msgid ""
"Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat "
"proxy\n"
"DomesticCat dc = \n"
"        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new "
"DomesticCat proxy!\n"
"System.out.println(cat==dc);                            // false"
msgstr ""
"Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat "
"proxy\n"
"DomesticCat dc = \n"
"        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new "
"DomesticCat proxy!\n"
"System.out.println(cat==dc);                            // false"

#. Tag: para
#: performance.xml:267
#, no-c-format
msgid ""
"However, the situation is not quite as bad as it looks. Even though we now "
"have two references to different proxy objects, the underlying instance will "
"still be the same object:"
msgstr ""
"Allerdings ist die Situation nicht so schlimm wie sie aussieht. Obwohl wir "
"jetzt zwei Verweise auf verschiedene Proxy-Objekte besitzen, so bleibt die "
"zu Grunde liegende Instanz nach wie vor dasselbe Objekt:"

#. Tag: programlisting
#: performance.xml:271
#, fuzzy, no-c-format
msgid ""
"cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
"System.out.println( dc.getWeight() );  // 11.0"
msgstr ""
"cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
"System.out.println( dc.getWeight() );  // 11.0"

#. Tag: para
#: performance.xml:273
#, fuzzy, no-c-format
msgid ""
"Third, you cannot use a CGLIB proxy for a <literal>final</literal> class or "
"a class with any <literal>final</literal> methods."
msgstr ""
"Drittens können Sie kein CGLIB-Proxy für eine <literal>final</literal>-"
"Klasse oder eine Klasse mit einer <literal>final</literal>-Methode verwenden."

#. Tag: para
#: performance.xml:276
#, fuzzy, no-c-format
msgid ""
"Finally, if your persistent object acquires any resources upon instantiation "
"(e.g. in initializers or default constructor), then those resources will "
"also be acquired by the proxy. The proxy class is an actual subclass of the "
"persistent class."
msgstr ""
"Wenn Ihr persistentes Objekt bei der Instantiierung Ressourcen erhält (z.B. "
"Initialisierungsprogramme oder den Standard-Konstruktor), so erhält auch das "
"Proxy diese Ressourcen. Die Proxy-Klasse ist eine Subklasse der persistenten "
"Klasse."

#. Tag: para
#: performance.xml:281
#, fuzzy, no-c-format
msgid ""
"These problems are all due to fundamental limitations in Java's single "
"inheritance model. To avoid these problems your persistent classes must each "
"implement an interface that declares its business methods. You should "
"specify these interfaces in the mapping file where <literal>CatImpl</"
"literal> implements the interface <literal>Cat</literal> and "
"<literal>DomesticCatImpl</literal> implements the interface "
"<literal>DomesticCat</literal>. For example:"
msgstr ""
"Diese Probleme wurzeln in fundamentalen Einschränkungen des "
"Einzelvererbungsmodells in Java. Falls Sie diese Probleme umgehen möchten, "
"muss jede Ihrer persistenten Klassen ein Interface implementieren, das seine "
"Business-Methoden deklariert. Diese Interfaces sollten Sie z.B. in der "
"Mapping-Datei spezifizieren."

#. Tag: programlisting
#: performance.xml:289
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"CatImpl\" proxy=\"Cat\"&gt;\n"
"    ......\n"
"    &lt;subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\"&gt;\n"
"        .....\n"
"    &lt;/subclass&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"CatImpl\" proxy=\"Cat\"&gt;\n"
"    ......\n"
"    &lt;subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\"&gt;\n"
"        .....\n"
"    &lt;/subclass&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: performance.xml:291
#, fuzzy, no-c-format
msgid ""
"Then proxies for instances of <literal>Cat</literal> and "
"<literal>DomesticCat</literal> can be returned by <literal>load()</literal> "
"or <literal>iterate()</literal>."
msgstr ""
"Zunächst einmal werden Instanzen von <literal>Cat</literal> hinsichtlich "
"ihres Datentyps niemals in <literal>DomesticCat</literal> konvertierbar "
"sein, selbst wenn die zu Grunde liegende Instanz eine Instanz von "
"<literal>DomesticCat</literal> ist:"

#. Tag: programlisting
#: performance.xml:295
#, fuzzy, no-c-format
msgid ""
"Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
"Iterator iter = session.createQuery(\"from CatImpl as cat where cat."
"name='fritz'\").iterate();\n"
"Cat fritz = (Cat) iter.next();"
msgstr ""
"Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
"Iterator iter = session.iterate(\"from CatImpl as cat where cat."
"name='fritz'\");\n"
"Cat fritz = (Cat) iter.next();"

#. Tag: title
#: performance.xml:298
#, no-c-format
msgid "Note"
msgstr ""

#. Tag: para
#: performance.xml:300
#, fuzzy, no-c-format
msgid "<literal>list()</literal> does not usually return proxies."
msgstr "<literal>full join</literal> (in der Regel nicht sehr nützlich)"

#. Tag: para
#: performance.xml:304
#, no-c-format
msgid ""
"Relationships are also lazily initialized. This means you must declare any "
"properties to be of type <literal>Cat</literal>, not <literal>CatImpl</"
"literal>."
msgstr ""
"Beziehungen werden ebenfalls \"lazy\" initialisiert. Das bedeutet, dass Sie "
"sämtliche Properties als Typ <literal>Cat</literal>, nicht <literal>CatImpl</"
"literal> deklarieren müssen."

#. Tag: para
#: performance.xml:308
#, fuzzy, no-c-format
msgid ""
"Certain operations do <emphasis>not</emphasis> require proxy initialization:"
msgstr ""
"Bestimmte Vorgänge benötigen <emphasis>keine</emphasis> Proxy-Initialisierung"

#. Tag: para
#: performance.xml:313
#, fuzzy, no-c-format
msgid ""
"<literal>equals()</literal>: if the persistent class does not override "
"<literal>equals()</literal>"
msgstr ""
"<literal>equals()</literal>, falls die persistente Klasse <literal>equals()</"
"literal> nicht außer Kraft setzt"

#. Tag: para
#: performance.xml:318
#, fuzzy, no-c-format
msgid ""
"<literal>hashCode()</literal>: if the persistent class does not override "
"<literal>hashCode()</literal>"
msgstr ""
"<literal>hashCode()</literal>, falls die persistente Klasse <literal>hashCode"
"()</literal> nicht außer Kraft setzt"

#. Tag: para
#: performance.xml:323
#, no-c-format
msgid "The identifier getter method"
msgstr "Die \"Getter\"-Methode des Bezeichners"

#. Tag: para
#: performance.xml:327
#, no-c-format
msgid ""
"Hibernate will detect persistent classes that override <literal>equals()</"
"literal> or <literal>hashCode()</literal>."
msgstr ""
"Hibernate erkennt persistente Klassen, die <literal>equals()</literal> oder "
"<literal>hashCode()</literal> außer Kraft setzen."

#. Tag: para
#: performance.xml:330
#, fuzzy, no-c-format
msgid ""
"By choosing <literal>lazy=\"no-proxy\"</literal> instead of the default "
"<literal>lazy=\"proxy\"</literal>, you can avoid problems associated with "
"typecasting. However, buildtime bytecode instrumentation is required, and "
"all operations will result in immediate proxy initialization."
msgstr ""
"Durch Auswahl von <literal>lazy=\"no-proxy\"</literal> anstelle des "
"standardmäßigen <literal>lazy=\"proxy\"</literal>, lassen sich mit der Typ-"
"Umwandlung zusammenhängende Probleme vermeiden. Es wird jedoch \"Buildtime "
"Bytecode\"-Instrumentierung benötigt und sämtliche Vorgänge führen zu einer "
"unmittelbaren Proxy-Initialisierung."

#. Tag: title
#: performance.xml:338
#, no-c-format
msgid "Initializing collections and proxies"
msgstr "Initialisierung von Collections und Proxies"

#. Tag: para
#: performance.xml:340
#, fuzzy, no-c-format
msgid ""
"A <literal>LazyInitializationException</literal> will be thrown by Hibernate "
"if an uninitialized collection or proxy is accessed outside of the scope of "
"the <literal>Session</literal>, i.e., when the entity owning the collection "
"or having the reference to the proxy is in the detached state."
msgstr ""
"Eine <literal>LazyInitializationException</literal>-Ausnahme wird durch "
"Hibernate gemeldet, wenn auf eine nicht initialisierte Collection oder Proxy "
"außerhalb des Gültigkeitsbereichs der <literal>Session</literal> zugegriffen "
"wird, d.h. wenn die Entity, die die Collection besitzt oder einen Verweis "
"auf das Proxy hat, sich in abgesetztem Status befindet."

#. Tag: para
#: performance.xml:346
#, fuzzy, no-c-format
msgid ""
"Sometimes a proxy or collection needs to be initialized before closing the "
"<literal>Session</literal>. You can force initialization by calling "
"<literal>cat.getSex()</literal> or <literal>cat.getKittens().size()</"
"literal>, for example. However, this can be confusing to readers of the code "
"and it is not convenient for generic code."
msgstr ""
"In manchen Fällen muss sichergestellt werden, dass ein Proxy oder eine "
"Collection initialisiert ist, ehe die <literal>Session</literal> geschlossen "
"wird. Natürlich kann die Initialisierung durch Aufruf von <literal>cat.getSex"
"()</literal> oder <literal>cat.getKittens().size()</literal> immer auch "
"erzwungen werden. Allerdings ist das recht verwirrend für Leser des Codes "
"und nicht praktisch für generischen Code."

#. Tag: para
#: performance.xml:353
#, fuzzy, no-c-format
msgid ""
"The static methods <literal>Hibernate.initialize()</literal> and "
"<literal>Hibernate.isInitialized()</literal>, provide the application with a "
"convenient way of working with lazily initialized collections or proxies. "
"<literal>Hibernate.initialize(cat)</literal> will force the initialization "
"of a proxy, <literal>cat</literal>, as long as its <literal>Session</"
"literal> is still open. <literal>Hibernate.initialize( cat.getKittens() )</"
"literal> has a similar effect for the collection of kittens."
msgstr ""
"Die statischen Methoden <literal>Hibernate.initialize()</literal> und "
"<literal>Hibernate.isInitialized()</literal> liefern der Anwendung eine "
"praktische Art mit nach \"lazy\" Art initialisierten Collections oder "
"Proxies umzugehen. <literal>Hibernate.initialize(cat)</literal> erzwingt die "
"Initialisierung einesProxy, <literal>cat</literal> solange dessen "
"<literal>Session</literal> noch geöffnet ist. <literal>Hibernate.initialize"
"( cat.getKittens() )</literal> hat eine ähnliche Wirkung auf die Collection "
"von \"kittens\"."

#. Tag: para
#: performance.xml:362
#, fuzzy, no-c-format
msgid ""
"Another option is to keep the <literal>Session</literal> open until all "
"required collections and proxies have been loaded. In some application "
"architectures, particularly where the code that accesses data using "
"Hibernate, and the code that uses it are in different application layers or "
"different physical processes, it can be a problem to ensure that the "
"<literal>Session</literal> is open when a collection is initialized. There "
"are two basic ways to deal with this issue:"
msgstr ""
"Eine weitere Möglichkeit ist es, die <literal>Session</literal> geöffnet zu "
"halten, bis alle benötigten Collections und Proxies geladen sind. In einigen "
"Anwendungsarchitekturen - insbesondere wenn der Code unter Verwendung von "
"Hibernate auf Daten zugreift und der diese benutzende Code sich in "
"unterschiedlichen Anwendungsschichten oder verschiedenen physikalischen "
"Prozessen befindet, kann es problematisch sein sicherzustellen, dass die "
"<literal>Session</literal> bei der Initialisierung der Collection geöffnet "
"ist. Es gibt zwei einfache Wege, damit umzugehen:"

#. Tag: para
#: performance.xml:372
#, fuzzy, no-c-format
msgid ""
"In a web-based application, a servlet filter can be used to close the "
"<literal>Session</literal> only at the end of a user request, once the "
"rendering of the view is complete (the <emphasis>Open Session in View</"
"emphasis> pattern). Of course, this places heavy demands on the correctness "
"of the exception handling of your application infrastructure. It is vitally "
"important that the <literal>Session</literal> is closed and the transaction "
"ended before returning to the user, even when an exception occurs during "
"rendering of the view. See the Hibernate Wiki for examples of this \"Open "
"Session in View\" pattern."
msgstr ""
"In einer Web-basierten Anwendung kann die <literal>Session</literal> nur am "
"Ende der Benutzeranfrage und nachdem das Rendering der Ansicht (das "
"<emphasis>Offene Session in Ansicht</emphasis>-Modell) abgeschlossen ist, "
"mittels eines Servlet-Filters geschlossen werden. Natürlich stellt dies "
"große Anforderungen auf den ordnungsgemäßen Umgang mit Ausnahmen Ihrer "
"Anwendungsinfrastruktur. Es ist von maßgeblicher Bedeutung, dass die "
"<literal>Session</literal> geschlossen und die Transaktion beendet ist, ehe "
"zum Benutzer zurückgekehrt wird, selbst wenn während des Renderings der "
"Ansicht eine Ausnahme gemeldet wird. Beispiele für dieses \"Offene Session "
"in Ansicht\"-Modell finden Sie im Hibernate Wiki."

#. Tag: para
#: performance.xml:385
#, fuzzy, no-c-format
msgid ""
"In an application with a separate business tier, the business logic must "
"\"prepare\" all collections that the web tier needs before returning. This "
"means that the business tier should load all the data and return all the "
"data already initialized to the presentation/web tier that is required for a "
"particular use case. Usually, the application calls <literal>Hibernate."
"initialize()</literal> for each collection that will be needed in the web "
"tier (this call must occur before the session is closed) or retrieves the "
"collection eagerly using a Hibernate query with a <literal>FETCH</literal> "
"clause or a <literal>FetchMode.JOIN</literal> in <literal>Criteria</"
"literal>. This is usually easier if you adopt the <emphasis>Command</"
"emphasis> pattern instead of a <emphasis>Session Facade</emphasis>."
msgstr ""
"In einer Anwendung mit separatem Business-\"Tier\" muss die Business-Logik "
"alle Collections auf deren Verwendung durch den Web-\"Tier\" vor der "
"Rückkehr \"vorbereiten\". Das bedeutet, dass der Business-Tier sämtliche "
"Daten laden und alle bereits initialisierten Daten an den Präsentations-/Web-"
"Tier, der in einem bestimmten Fall benötigt wird, wiedergeben muss. In der "
"Regel erfolgt durch die Anwendung der Aufruf <literal>Hibernate.initialize()"
"</literal> für jede Collection, die im Web-Tier benötigt werden wird (dieser "
"Aufruf muss erfolgen, ehe die Session geschlossen wird) oder die Collection "
"wird nach \"eager\"-Art mittels einer Hibernate Anfrage mit einer "
"<literal>FETCH</literal>-Klausel oder <literal>FetchMode.JOIN</literal> in "
"<literal>Criteria</literal> abgerufen. Dies ist in der Regel einfacher, wenn "
"Sie das <emphasis>Command</emphasis>-Modell anstelle einer <emphasis>Session "
"Fassade</emphasis> einsetzen."

#. Tag: para
#: performance.xml:401
#, fuzzy, no-c-format
msgid ""
"You can also attach a previously loaded object to a new <literal>Session</"
"literal> with <literal>merge()</literal> or <literal>lock()</literal> before "
"accessing uninitialized collections or other proxies. Hibernate does not, "
"and certainly <emphasis>should</emphasis> not, do this automatically since "
"it would introduce impromptu transaction semantics."
msgstr ""
"Sie können auch zuvor geladene Objekte mittels <literal>merge()</literal> or "
"<literal>lock()</literal> an eine neue <literal>Session</literal> anhängen, "
"ehe Sie auf nicht initialisierte Collections (oder andere Proxies) "
"zugreifen. Hibernate tut dies nicht von selbst und <emphasis>sollte</"
"emphasis> es auch nicht automatisch tun, da es dadurch zu Ad-hoc-"
"Transaktionssemantik käme!"

#. Tag: para
#: performance.xml:410
#, fuzzy, no-c-format
msgid ""
"Sometimes you do not want to initialize a large collection, but still need "
"some information about it, like its size, for example, or a subset of the "
"data."
msgstr ""
"Manchmal möchten Sie eine große Collection nicht initialisieren, aber "
"benötigen dennoch Informationen (etwa deren Größe) oder einen Untersatz der "
"Daten."

#. Tag: para
#: performance.xml:414
#, no-c-format
msgid ""
"You can use a collection filter to get the size of a collection without "
"initializing it:"
msgstr ""
"Sie können einen Collection-Filter verwenden, um die Größe der Collection zu "
"ermitteln ohne diese zu initialisieren:"

#. Tag: programlisting
#: performance.xml:417
#, fuzzy, no-c-format
msgid ""
"( (Integer) s.createFilter( collection, \"select count(*)\" ).list().get"
"(0) ).intValue()"
msgstr ""
"( (Integer) s.createFilter( collection, \"select count(*)\" ).list().get"
"(0) ).intValue()"

#. Tag: para
#: performance.xml:419
#, no-c-format
msgid ""
"The <literal>createFilter()</literal> method is also used to efficiently "
"retrieve subsets of a collection without needing to initialize the whole "
"collection:"
msgstr ""
"Die <literal>createFilter()</literal>-Methode wird außerdem benutzt, um "
"effizient Untersätze einer Collection abzurufen, ohne die gesamte Collection "
"zu initialisieren:"

#. Tag: programlisting
#: performance.xml:423
#, fuzzy, no-c-format
msgid ""
"s.createFilter( lazyCollection, \"\").setFirstResult(0).setMaxResults(10)."
"list();"
msgstr ""
"s.createFilter( lazyCollection, \"\").setFirstResult(0).setMaxResults(10)."
"list();"

#. Tag: title
#: performance.xml:427
#, no-c-format
msgid "Using batch fetching"
msgstr "Die Verwendung von Stapelabruf (\"Batch-Fetching\")"

#. Tag: para
#: performance.xml:429
#, fuzzy, no-c-format
msgid ""
"Using batch fetching, Hibernate can load several uninitialized proxies if "
"one proxy is accessed. Batch fetching is an optimization of the lazy select "
"fetching strategy. There are two ways you can configure batch fetching: on "
"the class level and the collection level."
msgstr ""
"Hibernate kann den Stapelabruf effizient nutzen, d.h. Hibernate kann mehrere "
"nicht initialisierte Proxies laden, wenn auf einen Proxy zugegriffen wird "
"(oder Collections). Beim Stapelabruf handelt es sich um eine Optimierung der "
"\"lazy\" Auswahlabruf-Strategie (\"Select-Fetching\"). Es gibt zwei Arten, "
"auf die sich der Stapelabruf abstimmen lässt: Auf der Klassen- sowie auf der "
"Collection-Ebene."

#. Tag: para
#: performance.xml:434
#, fuzzy, no-c-format
msgid ""
"Batch fetching for classes/entities is easier to understand. Consider the "
"following example: at runtime you have 25 <literal>Cat</literal> instances "
"loaded in a <literal>Session</literal>, and each <literal>Cat</literal> has "
"a reference to its <literal>owner</literal>, a <literal>Person</literal>. "
"The <literal>Person</literal> class is mapped with a proxy, <literal>lazy="
"\"true\"</literal>. If you now iterate through all cats and call "
"<literal>getOwner()</literal> on each, Hibernate will, by default, execute "
"25 <literal>SELECT</literal> statements to retrieve the proxied owners. You "
"can tune this behavior by specifying a <literal>batch-size</literal> in the "
"mapping of <literal>Person</literal>:"
msgstr ""
"Der Stapelabruf für Klassen/Entities ist leichter zu verstehen. Stellen Sie "
"sich vor, Sie hätten zur Runtime folgende Situation: Sie haben 25 "
"<literal>Cat</literal>-Instanzen in einer <literal>Session</literal> "
"geladen, jede <literal>Cat</literal> besitzt eine Referenz zu ihrem "
"<literal>owner</literal>, einer <literal>Person</literal>. Die "
"<literal>Person</literal>-Klasse ist mit einem Proxy <literal>lazy=\"true\"</"
"literal> gemappt. Falls Sie nun über alle \"Cats\" hinweg iterieren und für "
"jede <literal>getOwner()</literal> aufrufen, so wird Hibernate in der "
"Standardeinstellung 25 <literal>SELECT</literal>-Anweisungen ausführen, um "
"die geproxieten Besitzer zu erhalten. Sie können dieses Verhalten durch "
"Bestimmung eines <literal>batch-size</literal> im Mapping von "
"<literal>Person</literal> festlegen:"

#. Tag: programlisting
#: performance.xml:447
#, fuzzy, no-c-format
msgid "&lt;class name=\"Person\" batch-size=\"10\"&gt;...&lt;/class&gt;"
msgstr "&lt;class name=\"Person\" batch-size=\"10\"&gt;...&lt;/class&gt;"

#. Tag: para
#: performance.xml:449
#, fuzzy, no-c-format
msgid ""
"Hibernate will now execute only three queries: the pattern is 10, 10, 5."
msgstr ""
"Hibernate führt nun nur drei Anfragen aus, das Muster lautet 10, 10, 5."

#. Tag: para
#: performance.xml:452
#, fuzzy, no-c-format
msgid ""
"You can also enable batch fetching of collections. For example, if each "
"<literal>Person</literal> has a lazy collection of <literal>Cat</literal>s, "
"and 10 persons are currently loaded in the <literal>Session</literal>, "
"iterating through all persons will generate 10 <literal>SELECT</literal>s, "
"one for every call to <literal>getCats()</literal>. If you enable batch "
"fetching for the <literal>cats</literal> collection in the mapping of "
"<literal>Person</literal>, Hibernate can pre-fetch collections:"
msgstr ""
"Sie können auch den Stapelabruf für Collections aktivieren. Wenn zum "
"Beispiel jede <literal>Person</literal> eine \"lazy\" Collection von "
"<literal>Cat</literal>s besitzt und zum aktuellen Zeitpunkt 10 Personen in "
"der <literal>Sesssion</literal> geladen sind, so wird die Iterierung über "
"alle Personen 10 <literal>SELECT</literal>s generieren, eines für jeden "
"Aufruf von <literal>getCats()</literal>. Falls Sie den Stapelabruf für die "
"<literal>cats</literal>-Collection im Mapping von <literal>Person</literal> "
"aktivieren, kann Hibernate Collections vorab abrufen:"

#. Tag: programlisting
#: performance.xml:461
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;set name=\"cats\" batch-size=\"3\"&gt;\n"
"        ...\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;set name=\"cats\" batch-size=\"3\"&gt;\n"
"        ...\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: performance.xml:463
#, fuzzy, no-c-format
msgid ""
"With a <literal>batch-size</literal> of 3, Hibernate will load 3, 3, 3, 1 "
"collections in four <literal>SELECT</literal>s. Again, the value of the "
"attribute depends on the expected number of uninitialized collections in a "
"particular <literal>Session</literal>."
msgstr ""
"Bei einem <literal>batch-size</literal> von 8, lädt Hibernate 3, 3, 3, 1 "
"Collections in vier <literal>SELECT</literal>s. Auch hier hängt der Wert des "
"Attributs von der zu erwartenden Anzahl nicht initialisierter Collections in "
"einer bestimmten <literal>Session</literal> ab."

#. Tag: para
#: performance.xml:468
#, fuzzy, no-c-format
msgid ""
"Batch fetching of collections is particularly useful if you have a nested "
"tree of items, i.e. the typical bill-of-materials pattern. However, a "
"<emphasis>nested set</emphasis> or a <emphasis>materialized path</emphasis> "
"might be a better option for read-mostly trees."
msgstr ""
"Der Stapelabruf von Collections ist besonders hilfreich, wenn Sie einen "
"verschachtelten Baum von Posten besitzen, d.h. das typische \"Bill-of-"
"Materials\"-Modell. (Obwohl ein <emphasis>verschachtelter Satz</emphasis> "
"oder ein <emphasis>realisierter Pfad</emphasis> eine möglicherweise bessere "
"Option für \"read-mostly\"-Bäume ist)."

#. Tag: title
#: performance.xml:475
#, no-c-format
msgid "Using subselect fetching"
msgstr "Die Verwendung von \"Subselect-Fetching\""

#. Tag: para
#: performance.xml:477
#, fuzzy, no-c-format
msgid ""
"If one lazy collection or single-valued proxy has to be fetched, Hibernate "
"will load all of them, re-running the original query in a subselect. This "
"works in the same way as batch-fetching but without the piecemeal loading."
msgstr ""
"Falls eine \"lazy\" Collection oder ein einwertiges Proxy abgerufen werden "
"muss, so lädt Hibernate alle und führt die ursprüngliche Anfrage in einer "
"Unterauswahl (\"Subselect\") erneut aus. Das funktioniert auf diesselbe "
"Weise wie Stapelabruf, ohne das stückweise Laden."

#. Tag: title
#: performance.xml:486
#, fuzzy, no-c-format
msgid "Fetch profiles"
msgstr "Abrufstrategien"

#. Tag: para
#: performance.xml:488
#, no-c-format
msgid ""
"Another way to affect the fetching strategy for loading associated objects "
"is through something called a fetch profile, which is a named configuration "
"associated with the <interfacename>org.hibernate.SessionFactory</"
"interfacename> but enabled, by name, on the <interfacename>org.hibernate."
"Session</interfacename>. Once enabled on a <interfacename>org.hibernate."
"Session</interfacename>, the fetch profile will be in affect for that "
"<interfacename>org.hibernate.Session</interfacename> until it is explicitly "
"disabled."
msgstr ""

#. Tag: para
#: performance.xml:498
#, no-c-format
msgid ""
"So what does that mean? Well lets explain that by way of an example which "
"show the different available approaches to configure a fetch profile:"
msgstr ""

#. Tag: title
#: performance.xml:503
#, no-c-format
msgid "Specifying a fetch profile using <classname>@FetchProfile</classname>"
msgstr ""

#. Tag: programlisting
#: performance.xml:506
#, no-c-format
msgid ""
"@Entity\n"
"@FetchProfile(name = \"customer-with-orders\", fetchOverrides = {\n"
"   @FetchProfile.FetchOverride(entity = Customer.class, association = "
"\"orders\", mode = FetchMode.JOIN)\n"
"})\n"
"public class Customer {\n"
"   @Id\n"
"   @GeneratedValue\n"
"   private long id;\n"
"\n"
"   private String name;\n"
"\n"
"   private long customerNumber;\n"
"\n"
"   @OneToMany\n"
"   private Set&lt;Order&gt; orders;\n"
"\n"
"   // standard getter/setter\n"
"   ...\n"
"}"
msgstr ""

#. Tag: title
#: performance.xml:510
#, no-c-format
msgid ""
"Specifying a fetch profile using <literal>&lt;fetch-profile&gt;</literal> "
"outside <literal>&lt;class&gt;</literal> node"
msgstr ""

#. Tag: programlisting
#: performance.xml:514
#, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"    &lt;class name=\"Customer\"&gt;\n"
"        ...\n"
"        &lt;set name=\"orders\" inverse=\"true\"&gt;\n"
"            &lt;key column=\"cust_id\"/&gt;\n"
"            &lt;one-to-many class=\"Order\"/&gt;\n"
"        &lt;/set&gt;\n"
"    &lt;/class&gt;\n"
"    &lt;class name=\"Order\"&gt;\n"
"        ...\n"
"    &lt;/class&gt;\n"
"    &lt;fetch-profile name=\"customer-with-orders\"&gt;\n"
"        &lt;fetch entity=\"Customer\" association=\"orders\" style=\"join\"/"
"&gt;\n"
"    &lt;/fetch-profile&gt;\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: title
#: performance.xml:518
#, no-c-format
msgid ""
"Specifying a fetch profile using <literal>&lt;fetch-profile&gt;</literal> "
"inside <literal>&lt;class&gt;</literal> node"
msgstr ""

#. Tag: programlisting
#: performance.xml:522
#, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"    &lt;class name=\"Customer\"&gt;\n"
"        ...\n"
"        &lt;set name=\"orders\" inverse=\"true\"&gt;\n"
"            &lt;key column=\"cust_id\"/&gt;\n"
"            &lt;one-to-many class=\"Order\"/&gt;\n"
"        &lt;/set&gt;\n"
"        &lt;fetch-profile name=\"customer-with-orders\"&gt;\n"
"            &lt;fetch association=\"orders\" style=\"join\"/&gt;\n"
"        &lt;/fetch-profile&gt;\n"
"    &lt;/class&gt;\n"
"    &lt;class name=\"Order\"&gt;\n"
"        ...\n"
"    &lt;/class&gt;\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: performance.xml:525
#, no-c-format
msgid ""
"Now normally when you get a reference to a particular customer, that "
"customer's set of orders will be lazy meaning we will not yet have loaded "
"those orders from the database. Normally this is a good thing. Now lets say "
"that you have a certain use case where it is more efficient to load the "
"customer and their orders together. One way certainly is to use \"dynamic "
"fetching\" strategies via an HQL or criteria queries. But another option is "
"to use a fetch profile to achieve that. The following code will load both "
"the customer <emphasis>and</emphasis>their orders:"
msgstr ""

#. Tag: title
#: performance.xml:536
#, no-c-format
msgid "Activating a fetch profile for a given <classname>Session</classname>"
msgstr ""

#. Tag: programlisting
#: performance.xml:539
#, no-c-format
msgid ""
"Session session = ...;\n"
"session.enableFetchProfile( \"customer-with-orders\" );  // name matches "
"from mapping\n"
"Customer customer = (Customer) session.get( Customer.class, customerId );"
msgstr ""

#. Tag: para
#: performance.xml:543
#, no-c-format
msgid ""
"<classname>@FetchProfile </classname>definitions are global and it does not "
"matter on which class you place them. You can place the "
"<classname>@FetchProfile</classname> annotation either onto a class or "
"package (package-info.java). In order to define multiple fetch profiles for "
"the same class or package <classname>@FetchProfiles</classname> can be used."
msgstr ""

#. Tag: para
#: performance.xml:551
#, no-c-format
msgid ""
"Currently only join style fetch profiles are supported, but they plan is to "
"support additional styles. See <ulink url=\"http://opensource.atlassian.com/"
"projects/hibernate/browse/HHH-3414\">HHH-3414</ulink> for details."
msgstr ""

#. Tag: title
#: performance.xml:558
#, no-c-format
msgid "Using lazy property fetching"
msgstr "Die Verwendung von \"Lazy-Property-Fetching\""

#. Tag: para
#: performance.xml:560
#, fuzzy, no-c-format
msgid ""
"Hibernate3 supports the lazy fetching of individual properties. This "
"optimization technique is also known as <emphasis>fetch groups</emphasis>. "
"Please note that this is mostly a marketing feature; optimizing row reads is "
"much more important than optimization of column reads. However, only loading "
"some properties of a class could be useful in extreme cases. For example, "
"when legacy tables have hundreds of columns and the data model cannot be "
"improved."
msgstr ""
"Hibernate3 unterstützt das \"lazy\" Fetching einzelner Properties. Diese "
"Optimierungstechnik ist auch unter dem Namen <emphasis>Abrufgruppen</"
"emphasis> (sog. Fetch Groups\") bekannt. Bitte beachten Sie, dass es sich "
"hierbei meist um ein Marketing-Feature handelt, da in der Praxis die "
"Optimierung des Lesens von Reihen wesentlich wichtiger ist als die "
"Optimierung des Lesens von Spalten. Jedoch kann es in manchen Fällen "
"nützlich sein, einige Properties einer Klasse zu laden, wenn Stammtabellen "
"hunderte von Spalten besitzen und das Datenmodell nicht verbessert werden "
"kann."

#. Tag: para
#: performance.xml:568
#, no-c-format
msgid ""
"To enable lazy property loading, set the <literal>lazy</literal> attribute "
"on your particular property mappings:"
msgstr ""
"Um das \"lazy\" Laden von Properties zu aktivieren, setzen Sie das "
"<literal>lazy</literal>-Attribut auf Ihr bestimmtes Property-Mapping:"

#. Tag: programlisting
#: performance.xml:571
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Document\"&gt;\n"
"       &lt;id name=\"id\"&gt;\n"
"        &lt;generator class=\"native\"/&gt;\n"
"    &lt;/id&gt;\n"
"    &lt;property name=\"name\" not-null=\"true\" length=\"50\"/&gt;\n"
"    &lt;property name=\"summary\" not-null=\"true\" length=\"200\" lazy="
"\"true\"/&gt;\n"
"    &lt;property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true"
"\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Document\"&gt;\n"
"       &lt;id name=\"id\"&gt;\n"
"        &lt;generator class=\"native\"/&gt;\n"
"    &lt;/id&gt;\n"
"    &lt;property name=\"name\" not-null=\"true\" length=\"50\"/&gt;\n"
"    &lt;property name=\"summary\" not-null=\"true\" length=\"200\" lazy="
"\"true\"/&gt;\n"
"    &lt;property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true"
"\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: performance.xml:573
#, fuzzy, no-c-format
msgid ""
"Lazy property loading requires buildtime bytecode instrumentation. If your "
"persistent classes are not enhanced, Hibernate will ignore lazy property "
"settings and return to immediate fetching."
msgstr ""
"Das \"lazy\" Property Laden erfordert Buildtime-Bytecode Instrumentierung! "
"Falls Ihre persistenten Klassen nicht erweitert sind, so übergeht Hibernate "
"stillschweigend die \"lazy\" Property-Einstellungen und verwendet erneut "
"unmittelbaren Abruf (sog. \"immediate Fetching\")."

#. Tag: para
#: performance.xml:577
#, no-c-format
msgid "For bytecode instrumentation, use the following Ant task:"
msgstr "Für die Bytecode-Instrumentierung verwenden Sie folgende Ant-Funktion:"

#. Tag: programlisting
#: performance.xml:579
#, fuzzy, no-c-format
msgid ""
"&lt;target name=\"instrument\" depends=\"compile\"&gt;\n"
"    &lt;taskdef name=\"instrument\" classname=\"org.hibernate.tool."
"instrument.InstrumentTask\"&gt;\n"
"        &lt;classpath path=\"${jar.path}\"/&gt;\n"
"        &lt;classpath path=\"${classes.dir}\"/&gt;\n"
"        &lt;classpath refid=\"lib.class.path\"/&gt;\n"
"    &lt;/taskdef&gt;\n"
"\n"
"    &lt;instrument verbose=\"true\"&gt;\n"
"        &lt;fileset dir=\"${testclasses.dir}/org/hibernate/auction/model"
"\"&gt;\n"
"            &lt;include name=\"*.class\"/&gt;\n"
"        &lt;/fileset&gt;\n"
"    &lt;/instrument&gt;\n"
"&lt;/target&gt;"
msgstr ""
"&lt;target name=\"instrument\" depends=\"compile\"&gt;\n"
"    &lt;taskdef name=\"instrument\" classname=\"org.hibernate.tool."
"instrument.InstrumentTask\"&gt;\n"
"        &lt;classpath path=\"&#36;{jar.path}\"/&gt;\n"
"        &lt;classpath path=\"&#36;{classes.dir}\"/&gt;\n"
"        &lt;classpath refid=\"lib.class.path\"/&gt;\n"
"    &lt;/taskdef&gt;\n"
"\n"
"    &lt;instrument verbose=\"true\"&gt;\n"
"        &lt;fileset dir=\"&#36;{testclasses.dir}/org/hibernate/auction/model"
"\"&gt;\n"
"            &lt;include name=\"*.class\"/&gt;\n"
"        &lt;/fileset&gt;\n"
"    &lt;/instrument&gt;\n"
"&lt;/target&gt;"

#. Tag: para
#: performance.xml:581
#, fuzzy, no-c-format
msgid ""
"A different way of avoiding unnecessary column reads, at least for read-only "
"transactions, is to use the projection features of HQL or Criteria queries. "
"This avoids the need for buildtime bytecode processing and is certainly a "
"preferred solution."
msgstr ""
"Eine andere (möglicherweise bessere) Art der Vermeidung unnötigen Lesens von "
"Spalten besteht zumindest bei \"read-only\" (schreibgeschützten) "
"Transaktionen in der Verwendung der Projektionsfeatures von HQL- oder "
"Kriterienanfragen. Dadurch wird Buildtime Bytecode-Verarbeitung vermieden, "
"und dies ist daher die bevorzugte Lösung."

#. Tag: para
#: performance.xml:586
#, fuzzy, no-c-format
msgid ""
"You can force the usual eager fetching of properties using <literal>fetch "
"all properties</literal> in HQL."
msgstr ""
"Mittels <literal>fetch all properties</literal> in HQL können Sie das "
"übliche \"eager Fetching\" von Properties erzwingen."

#. Tag: title
#: performance.xml:592
#, no-c-format
msgid "The Second Level Cache"
msgstr "Das Cache der zweiten Ebene"

#. Tag: para
#: performance.xml:594
#, fuzzy, no-c-format
msgid ""
"A Hibernate <literal>Session</literal> is a transaction-level cache of "
"persistent data. It is possible to configure a cluster or JVM-level "
"(<literal>SessionFactory</literal>-level) cache on a class-by-class and "
"collection-by-collection basis. You can even plug in a clustered cache. Be "
"aware that caches are not aware of changes made to the persistent store by "
"another application. They can, however, be configured to regularly expire "
"cached data."
msgstr ""
"Bei einer Hibernate <literal>Session</literal> handelt es sich um ein Cache "
"persistenter Daten auf Transaktionsebene. Es ist möglich, auf Klasse-nach-"
"Klasse und Collection-nach-Collection-Basis ein Cache auf Cluster- oder JVM-"
"Ebene zu konfigurieren (<literal>SessionFactory</literal>-Ebene). Sie können "
"sogar in ein geclustertes Cache einbinden. Lassen Sie jedoch Vorsicht "
"walten. Caches sind nie über Änderungen durch eine andere Anwendung im "
"persistenten Speicher informiert (obwohl sie so konfiguriert werden können, "
"dass gecachte Daten in regelmäßigen Abständen gelöscht werden)."

#. Tag: para
#: performance.xml:602
#, fuzzy, no-c-format
msgid ""
"You have the option to tell Hibernate which caching implementation to use by "
"specifying the name of a class that implements <literal>org.hibernate.cache."
"CacheProvider</literal> using the property <literal>hibernate.cache."
"provider_class</literal>. Hibernate is bundled with a number of built-in "
"integrations with the open-source cache providers that are listed in <xref "
"linkend=\"cacheproviders\"/>. You can also implement your own and plug it in "
"as outlined above. Note that versions prior to Hibernate 3.2 use EhCache as "
"the default cache provider."
msgstr ""
"Sie haben die Möglichkeit Hibernate mitzuteilen, welche Caching-"
"Implementierung es verwenden soll, indem Sie den Namen der Klasse bestimmen, "
"die <literal>org.hibernate.cache.CacheProvider</literal> unter Verwendung "
"der Property <literal>hibernate.cache.provider_class</literal> "
"implementiert. Hibernate kommt gebündelt mit einer Reihe eingebauter "
"Integrationen mit Open Source Cache-Providern (unten aufgeführt); Sie können "
"zusätzlich Ihren eigenen implementieren und diesen wie oben beschrieben "
"einbinden. Bitte beachten Sie, dass Versionen, die älter sind als 3.2 "
"standardmäßig EhCache als Standard-Cache-Provider verwenden, dies ist seit "
"3.2 jedoch nicht mehr der Fall."

#. Tag: title
#: performance.xml:613
#, no-c-format
msgid "Cache Providers"
msgstr "Cache-Provider"

#. Tag: entry
#: performance.xml:628 performance.xml:976
#, no-c-format
msgid "Cache"
msgstr "Cache"

#. Tag: entry
#: performance.xml:630
#, no-c-format
msgid "Provider class"
msgstr "Provider-Klasse"

#. Tag: entry
#: performance.xml:632
#, no-c-format
msgid "Type"
msgstr "Typ"

#. Tag: entry
#: performance.xml:634
#, no-c-format
msgid "Cluster Safe"
msgstr "Cluster-sicher"

#. Tag: entry
#: performance.xml:636
#, no-c-format
msgid "Query Cache Supported"
msgstr "Anfragen-Cache unterstützt"

#. Tag: entry
#: performance.xml:642 performance.xml:990
#, no-c-format
msgid "Hashtable (not intended for production use)"
msgstr "Hash-Tabelle (nicht für den Produktionsgebrauch vorgesehen)"

#. Tag: literal
#: performance.xml:644
#, fuzzy, no-c-format
msgid "org.hibernate.cache.HashtableCacheProvider"
msgstr "org.hibernate.cache.HashtableCacheProvider"

#. Tag: entry
#: performance.xml:646
#, no-c-format
msgid "memory"
msgstr "Speicher"

#. Tag: entry
#: performance.xml:650 performance.xml:662 performance.xml:674
#: performance.xml:992 performance.xml:994 performance.xml:996
#: performance.xml:1004 performance.xml:1006 performance.xml:1008
#: performance.xml:1016 performance.xml:1018 performance.xml:1020
#: performance.xml:1028 performance.xml:1030 performance.xml:1040
#: performance.xml:1046 performance.xml:1052 performance.xml:1058
#, no-c-format
msgid "<entry>yes</entry>"
msgstr "<entry>Ja</entry>"

#. Tag: entry
#: performance.xml:654 performance.xml:1002
#, no-c-format
msgid "EHCache"
msgstr "EHCache"

#. Tag: literal
#: performance.xml:656
#, fuzzy, no-c-format
msgid "org.hibernate.cache.EhCacheProvider"
msgstr "org.hibernate.cache.EhCacheProvider"

#. Tag: entry
#: performance.xml:658 performance.xml:670
#, no-c-format
msgid "memory, disk"
msgstr "Speicher, Disk"

#. Tag: entry
#: performance.xml:666 performance.xml:1014
#, no-c-format
msgid "OSCache"
msgstr "OSCache"

#. Tag: literal
#: performance.xml:668
#, fuzzy, no-c-format
msgid "org.hibernate.cache.OSCacheProvider"
msgstr "org.hibernate.cache.OSCacheProvider"

#. Tag: entry
#: performance.xml:678 performance.xml:1026
#, no-c-format
msgid "SwarmCache"
msgstr "SwarmCache"

#. Tag: literal
#: performance.xml:680
#, fuzzy, no-c-format
msgid "org.hibernate.cache.SwarmCacheProvider"
msgstr "org.hibernate.cache.SwarmCacheProvider"

#. Tag: entry
#: performance.xml:682
#, no-c-format
msgid "clustered (ip multicast)"
msgstr "geclustert (ip multicast)"

#. Tag: entry
#: performance.xml:684
#, no-c-format
msgid "yes (clustered invalidation)"
msgstr "ja (geclusterte Außerkraftsetzung)"

#. Tag: entry
#: performance.xml:690 performance.xml:1038
#, fuzzy, no-c-format
msgid "JBoss Cache 1.x"
msgstr "JBoss TreeCache"

#. Tag: literal
#: performance.xml:692
#, fuzzy, no-c-format
msgid "org.hibernate.cache.TreeCacheProvider"
msgstr "org.hibernate.cache.TreeCacheProvider"

#. Tag: entry
#: performance.xml:694 performance.xml:706
#, no-c-format
msgid "clustered (ip multicast), transactional"
msgstr "geclustert (ip multicast), transaktional"

#. Tag: entry
#: performance.xml:696
#, no-c-format
msgid "yes (replication)"
msgstr "ja (Replikation)"

#. Tag: entry
#: performance.xml:698 performance.xml:710
#, no-c-format
msgid "yes (clock sync req.)"
msgstr "ja (clock sync req.)"

#. Tag: entry
#: performance.xml:702 performance.xml:1050
#, fuzzy, no-c-format
msgid "JBoss Cache 2"
msgstr "JBoss TreeCache"

#. Tag: literal
#: performance.xml:704
#, fuzzy, no-c-format
msgid "org.hibernate.cache.jbc.JBossCacheRegionFactory"
msgstr "org.hibernate.transaction.JDBCTransactionFactory"

#. Tag: entry
#: performance.xml:708
#, fuzzy, no-c-format
msgid "yes (replication or invalidation)"
msgstr "ja (geclusterte Außerkraftsetzung)"

#. Tag: title
#: performance.xml:717
#, no-c-format
msgid "Cache mappings"
msgstr "Cache-Mappings"

#. Tag: para
#: performance.xml:719
#, no-c-format
msgid ""
"As we have done in previous chapters we are looking at the two different "
"possibiltites to configure caching. First configuration via annotations and "
"then via Hibernate mapping files."
msgstr ""

#. Tag: para
#: performance.xml:723
#, no-c-format
msgid ""
"By default, entities are not part of the second level cache and we recommend "
"you to stick to this setting. However, you can override this by setting the "
"<literal>shared-cache-mode</literal> element in your <filename>persistence."
"xml</filename> file or by using the <literal>javax.persistence.sharedCache."
"mode </literal>property in your configuration. The following values are "
"possible:"
msgstr ""

#. Tag: para
#: performance.xml:732
#, no-c-format
msgid ""
"<literal>ENABLE_SELECTIVE</literal> (Default and recommended value): "
"entities are not cached unless explicitly marked as cacheable."
msgstr ""

#. Tag: para
#: performance.xml:738
#, no-c-format
msgid ""
"<literal>DISABLE_SELECTIVE</literal>: entities are cached unless explicitly "
"marked as not cacheable."
msgstr ""

#. Tag: para
#: performance.xml:743
#, no-c-format
msgid ""
"<literal>ALL</literal>: all entities are always cached even if marked as non "
"cacheable."
msgstr ""

#. Tag: para
#: performance.xml:748
#, no-c-format
msgid ""
"<literal>NONE</literal>: no entity are cached even if marked as cacheable. "
"This option can make sense to disable second-level cache altogether."
msgstr ""

#. Tag: para
#: performance.xml:754
#, no-c-format
msgid ""
"The cache concurrency strategy used by default can be set globaly via the "
"<literal>hibernate.cache.default_cache_concurrency_strategy</literal> "
"configuration property. The values for this property are:"
msgstr ""

#. Tag: literal
#: performance.xml:761
#, fuzzy, no-c-format
msgid "<literal>read-only</literal>"
msgstr "<literal>Criteria</literal>-Anfragen"

#. Tag: literal
#: performance.xml:765
#, fuzzy, no-c-format
msgid "<literal>read-write</literal>"
msgstr "<literal>Criteria</literal>-Anfragen"

#. Tag: literal
#: performance.xml:769
#, fuzzy, no-c-format
msgid "<literal>nonstrict-read-write</literal>"
msgstr "nonstrict-read-write"

#. Tag: literal
#: performance.xml:773
#, fuzzy, no-c-format
msgid "<literal>transactional</literal>"
msgstr "<literal>Criteria</literal>-Anfragen"

#. Tag: para
#: performance.xml:778
#, no-c-format
msgid ""
"It is recommended to define the cache concurrency strategy per entity rather "
"than using a global one. Use the <classname>@org.hibernate.annotations."
"Cache</classname> annotation for that."
msgstr ""

#. Tag: title
#: performance.xml:785
#, no-c-format
msgid ""
"Definition of cache concurrency strategy via <classname>@Cache</classname>"
msgstr ""

#. Tag: programlisting
#: performance.xml:788
#, no-c-format
msgid ""
"@Entity \n"
"@Cacheable\n"
"@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n"
"public class Forest { ... }"
msgstr ""

#. Tag: para
#: performance.xml:791
#, no-c-format
msgid ""
"Hibernate also let's you cache the content of a collection or the "
"identifiers if the collection contains other entities. Use the "
"<classname>@Cache</classname> annotation on the collection property."
msgstr ""

#. Tag: title
#: performance.xml:797
#, fuzzy, no-c-format
msgid "Caching collections using annotations"
msgstr "Initialisierung von Collections und Proxies"

#. Tag: programlisting
#: performance.xml:799
#, no-c-format
msgid ""
"@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)\n"
"@JoinColumn(name=\"CUST_ID\")\n"
"@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)\n"
"public SortedSet&lt;Ticket&gt; getTickets() {\n"
"    return tickets;\n"
"}"
msgstr ""

#. Tag: para
#: performance.xml:802
#, no-c-format
msgid ""
"shows the<literal> @org.hibernate.annotations.Cache</literal> annotations "
"with its attributes. It allows you to define the caching strategy and region "
"of a given second level cache."
msgstr ""

#. Tag: title
#: performance.xml:808
#, no-c-format
msgid "<classname>@Cache</classname> annotation with attributes"
msgstr ""

#. Tag: programlisting
#: performance.xml:820
#, no-c-format
msgid ""
"@Cache(\n"
"    CacheConcurrencyStrategy usage();\n"
"    String region() default \"\";\n"
"    String include() default \"all\";\n"
")"
msgstr ""

#. Tag: para
#: performance.xml:824
#, no-c-format
msgid ""
"usage: the given cache concurrency strategy (NONE, READ_ONLY, "
"NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)"
msgstr ""

#. Tag: para
#: performance.xml:830
#, no-c-format
msgid ""
"region (optional): the cache region (default to the fqcn of the class or the "
"fq role name of the collection)"
msgstr ""

#. Tag: para
#: performance.xml:835
#, no-c-format
msgid ""
"<literal>include</literal> (optional): all to include all properties, non-"
"lazy to only include non lazy properties (default all)."
msgstr ""

#. Tag: para
#: performance.xml:843
#, no-c-format
msgid ""
"Let's now take a look at Hibernate mapping files. There the <literal>&lt;"
"cache&gt;</literal> element of a class or collection mapping is used to "
"configure the second level cache. Looking at <xref linkend=\"example-"
"hibernate-cache-mapping-element\"/> the parallels to anotations is obvious."
msgstr ""

#. Tag: title
#: performance.xml:850
#, no-c-format
msgid "The Hibernate <literal>&lt;cache&gt;</literal> mapping element"
msgstr ""

#. Tag: programlisting
#: performance.xml:862
#, fuzzy, no-c-format
msgid ""
"&lt;cache\n"
"    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
"    region=\"RegionName\"\n"
"    include=\"all|non-lazy\"\n"
"/&gt;"
msgstr ""
"&lt;cache \n"
"    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
"    region=\"RegionName\"\n"
"    include=\"all|non-lazy\"\n"
"/&gt;"

#. Tag: para
#: performance.xml:866
#, no-c-format
msgid ""
"<literal>usage</literal> (required) specifies the caching strategy: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> or <literal>read-only</literal>"
msgstr ""
"<literal>usage</literal> (erforderlich) bestimmt die Caching-Strategie: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> oder <literal>read-only</literal>"

#. Tag: para
#: performance.xml:874
#, fuzzy, no-c-format
msgid ""
"<literal>region</literal> (optional: defaults to the class or collection "
"role name): specifies the name of the second level cache region"
msgstr ""
"<literal>region</literal> (optional, im Standard der Rollenname von Klasse "
"oder Collection) bestimmt den Namen des Cache-Bereichs der zweiten Ebene"

#. Tag: para
#: performance.xml:880
#, fuzzy, no-c-format
msgid ""
"<literal>include</literal> (optional: defaults to <literal>all</literal>) "
"<literal>non-lazy</literal>: specifies that properties of the entity mapped "
"with <literal>lazy=\"true\"</literal> cannot be cached when attribute-level "
"lazy fetching is enabled"
msgstr ""
"<literal>include</literal> (optional, standardmäßig <literal>all</literal>) "
"<literal>non-lazy</literal> bestimmt, dass Properties der mit <literal>lazy="
"\"true\"</literal> gemappten Entity nicht gecacht werden können, wenn auf "
"Attributebene \"lazy Fetching\" aktiviert ist."

#. Tag: para
#: performance.xml:890
#, fuzzy, no-c-format
msgid ""
"Alternatively to <literal>&lt;cache&gt;</literal>, you can use <literal>&lt;"
"class-cache&gt;</literal> and <literal>&lt;collection-cache&gt;</literal> "
"elements in <literal>hibernate.cfg.xml</literal>."
msgstr ""
"Alternativ (vorzugsweise?) können Sie <literal>&lt;class-cache&gt;</literal> "
"und <literal>&lt;collection-cache&gt;</literal>-Elemente in "
"<literal>hibernate.cfg.xml</literal> bestimmen."

#. Tag: para
#: performance.xml:895
#, no-c-format
msgid "Let's now have a closer look at the different usage strategies"
msgstr ""

#. Tag: title
#: performance.xml:900
#, no-c-format
msgid "Strategy: read only"
msgstr "Strategie: \"read only\""

#. Tag: para
#: performance.xml:902
#, fuzzy, no-c-format
msgid ""
"If your application needs to read, but not modify, instances of a persistent "
"class, a <literal>read-only</literal> cache can be used. This is the "
"simplest and optimal performing strategy. It is even safe for use in a "
"cluster."
msgstr ""
"Falls Ihre Anwendungen Instanzen einer persistenten Klasse lesen, aber nie "
"modifizieren muss, kann ein <literal>read-only</literal>-Cache verwendet "
"werden. Das ist die einfachste und leistungsfähigste Strategie. Sie ist "
"sogar bei der Anwendung in einem Cluster völlig sicher."

#. Tag: title
#: performance.xml:909
#, no-c-format
msgid "Strategy: read/write"
msgstr "Strategie: \"read/write\""

#. Tag: para
#: performance.xml:911
#, fuzzy, no-c-format
msgid ""
"If the application needs to update data, a <literal>read-write</literal> "
"cache might be appropriate. This cache strategy should never be used if "
"serializable transaction isolation level is required. If the cache is used "
"in a JTA environment, you must specify the property <literal>hibernate."
"transaction.manager_lookup_class</literal> and naming a strategy for "
"obtaining the JTA <literal>TransactionManager</literal>. In other "
"environments, you should ensure that the transaction is completed when "
"<literal>Session.close()</literal> or <literal>Session.disconnect()</"
"literal> is called. If you want to use this strategy in a cluster, you "
"should ensure that the underlying cache implementation supports locking. The "
"built-in cache providers <emphasis>do not</emphasis> support locking."
msgstr ""
"Falls die Anwendung Daten aktualisieren muss, so ist ein <literal>read-"
"write</literal>-Cache eine geeignete Wahl. Diese Cache-Strategie sollte "
"jedoch nie dann benutzt werden, wenn eine serialisierbare "
"Transaktionsisolationsebene benötigt wird. Falls das Cache in einer JTA-"
"Umgebung verwendet wird, müssen Sie die Property <literal>hibernate."
"transaction.manager_lookup_class</literal> bestimmen und eine Strategie für "
"die Abfrage des JTA <literal>TransactionManager</literal> benennen. In "
"anderen Umgebungen sollten Sie sicherstellen, dass die Transaktion beendet "
"ist, wenn <literal>Session.close()</literal> oder <literal>Session.disconnect"
"()</literal> aufgerufen wird. Falls Sie diese Strategie in einem Cluster "
"benutzen möchten, sollten Sie sicherstellen, dass die zu Grunde liegende "
"Cache-Implementierung \"Locking\" (Sperren) unterstützt. Die eingebauten "
"Cache-Provider tun dies <emphasis>nicht</emphasis>."

#. Tag: title
#: performance.xml:927
#, no-c-format
msgid "Strategy: nonstrict read/write"
msgstr "Strategie: \"nonstrict read/write\""

#. Tag: para
#: performance.xml:929
#, fuzzy, no-c-format
msgid ""
"If the application only occasionally needs to update data (i.e. if it is "
"extremely unlikely that two transactions would try to update the same item "
"simultaneously), and strict transaction isolation is not required, a "
"<literal>nonstrict-read-write</literal> cache might be appropriate. If the "
"cache is used in a JTA environment, you must specify <literal>hibernate."
"transaction.manager_lookup_class</literal>. In other environments, you "
"should ensure that the transaction is completed when <literal>Session.close()"
"</literal> or <literal>Session.disconnect()</literal> is called."
msgstr ""
"Falls die Anwendung nur von Zeit zu Zeit Daten aktualisieren muss (d.h. wenn "
"es sehr unwahrscheinlich ist, dass zwei Transaktionen denselben Posten "
"gleichzeitig zu aktualisieren versuchen würden) und keine strenge "
"Transaktionsisolation erforderlich ist, so kann ein <literal>nonstrict-read-"
"write</literal>-Cache eine passende Wahl sein. Wird das Cache in einer JTA-"
"Umgebung verwendet, so müssen Sie die <literal>hibernate.transaction."
"manager_lookup_class</literal> festlegen. In anderen Umgebungen sollten Sie "
"sicherstellen, dass die Transaktion abgeschlossen ist, wenn <literal>Session."
"close()</literal> oder <literal>Session.disconnect()</literal> aufgerufen "
"wird."

#. Tag: title
#: performance.xml:941
#, no-c-format
msgid "Strategy: transactional"
msgstr "Strategie: transaktional"

#. Tag: para
#: performance.xml:943
#, fuzzy, no-c-format
msgid ""
"The <literal>transactional</literal> cache strategy provides support for "
"fully transactional cache providers such as JBoss TreeCache. Such a cache "
"can only be used in a JTA environment and you must specify "
"<literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""
"Die <literal>transactional</literal> Cache-Strategie liefert Support für "
"vollständig transaktionale Cache-Provider wie etwa JBoss TreeCache. Ein "
"solches Cache kann nur in einer JTA-Umgebung verwendet werden, und Sie "
"müssen <literal>hibernate.transaction.manager_lookup_class</literal> "
"bestimmen."

#. Tag: title
#: performance.xml:950
#, fuzzy, no-c-format
msgid "Cache-provider/concurrency-strategy compatibility"
msgstr "Cache-Nebenläufigkeitsstrategie-Support"

#. Tag: para
#: performance.xml:953
#, fuzzy, no-c-format
msgid ""
"None of the cache providers support all of the cache concurrency strategies."
msgstr ""
"Keiner der Cache-Provider unterstützt alle Cache-Nebenläufigkeitsstrategien. "
"Die folgende Tabelle zeigt, welche Provider mit welchen "
"Nebenläufigkeitsstrategien kompatibel sind."

#. Tag: para
#: performance.xml:957
#, fuzzy, no-c-format
msgid ""
"The following table shows which providers are compatible with which "
"concurrency strategies."
msgstr ""
"Keiner der Cache-Provider unterstützt alle Cache-Nebenläufigkeitsstrategien. "
"Die folgende Tabelle zeigt, welche Provider mit welchen "
"Nebenläufigkeitsstrategien kompatibel sind."

#. Tag: title
#: performance.xml:961
#, no-c-format
msgid "Cache Concurrency Strategy Support"
msgstr "Cache-Nebenläufigkeitsstrategie-Support"

#. Tag: entry
#: performance.xml:978
#, fuzzy, no-c-format
msgid "<entry>read-only</entry>"
msgstr "<entry>Ja</entry>"

#. Tag: entry
#: performance.xml:980
#, fuzzy, no-c-format
msgid "<entry>nonstrict-read-write</entry>"
msgstr "nonstrict-read-write"

#. Tag: entry
#: performance.xml:982
#, fuzzy, no-c-format
msgid "<entry>read-write</entry>"
msgstr "<entry>Ja</entry>"

#. Tag: entry
#: performance.xml:984
#, fuzzy, no-c-format
msgid "<entry>transactional</entry>"
msgstr "<entry>Ja</entry>"

#. Tag: title
#: performance.xml:1067
#, no-c-format
msgid "Managing the caches"
msgstr "Management der Caches"

#. Tag: para
#: performance.xml:1069
#, fuzzy, no-c-format
msgid ""
"Whenever you pass an object to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, and whenever you retrieve an "
"object using <literal>load()</literal>, <literal>get()</literal>, "
"<literal>list()</literal>, <literal>iterate()</literal> or <literal>scroll()"
"</literal>, that object is added to the internal cache of the "
"<literal>Session</literal>."
msgstr ""
"Jedesmal wenn ein Objekt an <literal>save()</literal>, <literal>update()</"
"literal> oder <literal>saveOrUpdate()</literal> weitergegeben wird und Sie "
"ein Objekt unter Verwendung von <literal>load()</literal>, <literal>get()</"
"literal>, <literal>list()</literal>, <literal>iterate()</literal> oder "
"<literal>scroll()</literal> abrufen, wird das Objekt dem internen Cache der "
"<literal>Session</literal> hinzugefügt."

#. Tag: para
#: performance.xml:1076
#, fuzzy, no-c-format
msgid ""
"When <literal>flush()</literal> is subsequently called, the state of that "
"object will be synchronized with the database. If you do not want this "
"synchronization to occur, or if you are processing a huge number of objects "
"and need to manage memory efficiently, the <literal>evict()</literal> method "
"can be used to remove the object and its collections from the first-level "
"cache."
msgstr ""
"Wenn anschließend <literal>flush()</literal> aufgerufen wird, wird der "
"Status des Objekts mit der Datenbank synchronisiert. Falls Sie nicht "
"möchten, dass diese Synchronisierung stattfindet oder falls Sie eine riesige "
"Anzahl von Objekten bearbeiten und effizient mit dem Speicher haushalten "
"müssen, so können mittels der <literal>evict()</literal>-Methode das Objekt "
"und dessen Collections aus dem Cache der ersten Ebene entfernt werden."

#. Tag: title
#: performance.xml:1084
#, no-c-format
msgid ""
"Explcitly evicting a cached instance from the first level cache using "
"<methodname>Session.evict()</methodname>"
msgstr ""

#. Tag: programlisting
#: performance.xml:1087
#, fuzzy, no-c-format
msgid ""
"ScrollableResult cats = sess.createQuery(\"from Cat as cat\").scroll(); //a "
"huge result set\n"
"while ( cats.next() ) {\n"
"    Cat cat = (Cat) cats.get(0);\n"
"    doSomethingWithACat(cat);\n"
"    sess.evict(cat);\n"
"}"
msgstr ""
"ScrollableResult cats = sess.createQuery(\"from Cat as cat\").scroll(); //a "
"huge result set\n"
"while ( cats.next() ) {\n"
"    Cat cat = (Cat) cats.get(0);\n"
"    doSomethingWithACat(cat);\n"
"    sess.evict(cat);\n"
"}"

#. Tag: para
#: performance.xml:1090
#, no-c-format
msgid ""
"The <literal>Session</literal> also provides a <literal>contains()</literal> "
"method to determine if an instance belongs to the session cache."
msgstr ""
"Die <literal>Session</literal> bietet außerdem eine <literal>contains()</"
"literal>-Methode um zu bestimmen, ob eine Instanz zu dem Session-Cache "
"gehört."

#. Tag: para
#: performance.xml:1094
#, fuzzy, no-c-format
msgid ""
"To evict all objects from the session cache, call <literal>Session.clear()</"
"literal>"
msgstr ""
"Um sämtliche Objekte vollständig aus dem Session-Cache zu entfernen, "
"verwenden Sie <literal>Session.clear()</literal>"

#. Tag: para
#: performance.xml:1097
#, no-c-format
msgid ""
"For the second-level cache, there are methods defined on "
"<literal>SessionFactory</literal> for evicting the cached state of an "
"instance, entire class, collection instance or entire collection role."
msgstr ""
"Für das Cache der zweiten Ebene gibt es in der <literal>SessionFactory</"
"literal> definierte Methoden, um den gecachten Status einer Instanz, "
"gesamten Klasse, Collection-Instanz oder der gesamten Collection-Rolle zu "
"räumen."

#. Tag: title
#: performance.xml:1103
#, no-c-format
msgid ""
"Second-level cache eviction via <methodname>SessionFactoty.evict() </"
"methodname>and <methodname>SessionFacyory.evictCollection()</methodname>"
msgstr ""

#. Tag: programlisting
#: performance.xml:1107
#, fuzzy, no-c-format
msgid ""
"sessionFactory.evict(Cat.class, catId); //evict a particular Cat\n"
"sessionFactory.evict(Cat.class);  //evict all Cats\n"
"sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a particular "
"collection of kittens\n"
"sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten "
"collections"
msgstr ""
"sessionFactory.evict(Cat.class, catId); //evict a particular Cat\n"
"sessionFactory.evict(Cat.class);  //evict all Cats\n"
"sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a particular "
"collection of kittens\n"
"sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten "
"collections"

#. Tag: para
#: performance.xml:1110
#, fuzzy, no-c-format
msgid ""
"The <literal>CacheMode</literal> controls how a particular session interacts "
"with the second-level cache:"
msgstr ""
"Mit <literal>CacheMode</literal> wird gesteuert, wie eine bestimmte Session "
"mit dem Cache der zweiten Ebene interagiert."

#. Tag: para
#: performance.xml:1115
#, fuzzy, no-c-format
msgid ""
"<literal>CacheMode.NORMAL</literal>: will read items from and write items to "
"the second-level cache"
msgstr ""
"<literal>CacheMode.NORMAL</literal> - liest Posten aus dem und schreibt "
"Posten in das Cache der zweiten Ebene"

#. Tag: para
#: performance.xml:1120
#, fuzzy, no-c-format
msgid ""
"<literal>CacheMode.GET</literal>: will read items from the second-level "
"cache. Do not write to the second-level cache except when updating data"
msgstr ""
"<literal>CacheMode.GET</literal> - liest Posten aus dem Cache der zweiten "
"Ebene, schreibt jedoch nichts in das Cache der zweiten Ebene außer bei "
"Aktualisierung der Daten"

#. Tag: para
#: performance.xml:1126
#, fuzzy, no-c-format
msgid ""
"<literal>CacheMode.PUT</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache"
msgstr ""
"<literal>CacheMode.PUT</literal> - schreibt Posten in das Cache der zweiten "
"Ebene, aber liest nicht aus dem Cache der zweiten Ebene"

#. Tag: para
#: performance.xml:1131
#, fuzzy, no-c-format
msgid ""
"<literal>CacheMode.REFRESH</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache. Bypass the effect of "
"<literal>hibernate.cache.use_minimal_puts</literal> forcing a refresh of the "
"second-level cache for all items read from the database"
msgstr ""
"<literal>CacheMode.REFRESH</literal> - schreibt Posten in das Cache der "
"zweiten Ebene, aber liest nicht aus dem Cache der zweiten Ebene, umgeht die "
"Wirkung von <literal>hibernate.cache.use_minimal_puts</literal> und erzwingt "
"ein erneutes Laden des Cache der zweiten Ebene für alle aus der Datenbank "
"gelesenen Objekte."

#. Tag: para
#: performance.xml:1139
#, no-c-format
msgid ""
"To browse the contents of a second-level or query cache region, use the "
"<literal>Statistics</literal> API:"
msgstr ""
"Um die Inhalte eines Cache der zweiten Ebene oder eines Cache-Bereichs zu "
"durchsuchen, verwenden Sie die <literal>Statistics</literal>-API:"

#. Tag: title
#: performance.xml:1143
#, fuzzy, no-c-format
msgid ""
"Browsing the second-level cache entries via the <classname>Statistics</"
"classname> API"
msgstr ""
"Um die Inhalte eines Cache der zweiten Ebene oder eines Cache-Bereichs zu "
"durchsuchen, verwenden Sie die <literal>Statistics</literal>-API:"

#. Tag: programlisting
#: performance.xml:1146
#, fuzzy, no-c-format
msgid ""
"Map cacheEntries = sessionFactory.getStatistics()\n"
"        .getSecondLevelCacheStatistics(regionName)\n"
"        .getEntries();"
msgstr ""
"Map cacheEntries = sessionFactory.getStatistics()\n"
"        .getSecondLevelCacheStatistics(regionName)\n"
"        .getEntries();"

#. Tag: para
#: performance.xml:1149
#, fuzzy, no-c-format
msgid ""
"You will need to enable statistics and, optionally, force Hibernate to keep "
"the cache entries in a more readable format:"
msgstr ""
"Sie werden die Statistik aktivieren müssen und können optional Hibernate "
"zwingen, Cache-Eingaben in einem lesbaren Format zu halten:"

#. Tag: title
#: performance.xml:1153
#, no-c-format
msgid "Enabling Hibernate statistics"
msgstr ""

#. Tag: programlisting
#: performance.xml:1155
#, fuzzy, no-c-format
msgid ""
"hibernate.generate_statistics true\n"
"hibernate.cache.use_structured_entries true"
msgstr ""
"hibernate.generate_statistics true\n"
"hibernate.cache.use_structured_entries true"

#. Tag: title
#: performance.xml:1160
#, no-c-format
msgid "The Query Cache"
msgstr "Das Anfragen-Cache"

#. Tag: para
#: performance.xml:1162
#, fuzzy, no-c-format
msgid ""
"Query result sets can also be cached. This is only useful for queries that "
"are run frequently with the same parameters."
msgstr ""
"Ergebnissätze von Anfragen können ebenfalls gecacht werden. Das ist jedoch "
"nur für Anfragen, die oft und mit denselben Parametern laufen, sinnvoll. Um "
"das Anfragen-Cache zu benutzen, müssen Sie es zuerst aktivieren:"

#. Tag: title
#: performance.xml:1166
#, no-c-format
msgid "Enabling query caching"
msgstr ""

#. Tag: para
#: performance.xml:1168
#, no-c-format
msgid ""
"Caching of query results introduces some overhead in terms of your "
"applications normal transactional processing. For example, if you cache "
"results of a query against Person Hibernate will need to keep track of when "
"those results should be invalidated because changes have been committed "
"against Person. That, coupled with the fact that most applications simply "
"gain no benefit from caching query results, leads Hibernate to disable "
"caching of query results by default. To use query caching, you will first "
"need to enable the query cache:"
msgstr ""

#. Tag: programlisting
#: performance.xml:1177
#, fuzzy, no-c-format
msgid "hibernate.cache.use_query_cache true"
msgstr "hibernate.cache.use_query_cache true"

#. Tag: para
#: performance.xml:1179
#, no-c-format
msgid "This setting creates two new cache regions:"
msgstr ""

#. Tag: para
#: performance.xml:1181
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.StandardQueryCache</classname>, holding the "
"cached query results"
msgstr ""

#. Tag: para
#: performance.xml:1186
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.UpdateTimestampsCache</classname>, holding "
"timestamps of the most recent updates to queryable tables. These are used to "
"validate the results as they are served from the query cache."
msgstr ""

#. Tag: para
#: performance.xml:1194
#, no-c-format
msgid ""
"If you configure your underlying cache implementation to use expiry or "
"timeouts is very important that the cache timeout of the underlying cache "
"region for the UpdateTimestampsCache be set to a higher value than the "
"timeouts of any of the query caches. In fact, we recommend that the the "
"UpdateTimestampsCache region not be configured for expiry at all. Note, in "
"particular, that an LRU cache expiry policy is never appropriate."
msgstr ""

#. Tag: para
#: performance.xml:1203
#, fuzzy, no-c-format
msgid ""
"As mentioned above, most queries do not benefit from caching or their "
"results. So by default, individual queries are not cached even after "
"enabling query caching. To enable results caching for a particular query, "
"call <literal>org.hibernate.Query.setCacheable(true)</literal>. This call "
"allows the query to look for existing cache results or add its results to "
"the cache when it is executed."
msgstr ""
"Bei den meisten Anfragen ist Caching von keinem großen Nutzen, daher werden "
"Anfragen in der Standardeinstellung nicht gecacht. Um Caching zu aktivieren "
"rufen Sie <literal>Query.setCacheable(true)</literal> auf. Dieser Aufruf "
"ermöglicht es der Anfrage nach bestehenden Cache-Ergebnissen zu suchen oder "
"ihre Ergebnisse dem Cache hinzuzufügen, wenn sie ausgeführt wird."

#. Tag: para
#: performance.xml:1211
#, no-c-format
msgid ""
"The query cache does not cache the state of the actual entities in the "
"cache; it caches only identifier values and results of value type. For this "
"reaso, the query cache should always be used in conjunction with the second-"
"level cache for those entities expected to be cached as part of a query "
"result cache (just as with collection caching)."
msgstr ""

#. Tag: title
#: performance.xml:1221
#, fuzzy, no-c-format
msgid "Query cache regions"
msgstr "Anfragen-Cache unterstützt"

#. Tag: para
#: performance.xml:1223
#, fuzzy, no-c-format
msgid ""
"If you require fine-grained control over query cache expiration policies, "
"you can specify a named cache region for a particular query by calling "
"<literal>Query.setCacheRegion()</literal>."
msgstr ""
"Falls Sie eine feinstufige Steuerung der Fälligkeitsrichtlinien benötigen, "
"können Sie einen benannten Cache-Bereich für eine bestimmte Anfrage "
"festlegen, indem Sie <literal>Query.setCacheRegion()</literal> aufrufen."

#. Tag: programlisting
#: performance.xml:1227
#, fuzzy, no-c-format
msgid ""
"List blogs = sess.createQuery(\"from Blog blog where blog.blogger = :blogger"
"\")\n"
"        .setEntity(\"blogger\", blogger)\n"
"        .setMaxResults(15)\n"
"        .setCacheable(true)\n"
"        .setCacheRegion(\"frontpages\")\n"
"        .list();"
msgstr ""
"List blogs = sess.createQuery(\"from Blog blog where blog.blogger = :blogger"
"\")\n"
"    .setEntity(\"blogger\", blogger)\n"
"    .setMaxResults(15)\n"
"    .setCacheable(true)\n"
"    .setCacheRegion(\"frontpages\")\n"
"    .list();"

#. Tag: para
#: performance.xml:1229
#, fuzzy, no-c-format
msgid ""
"If you want to force the query cache to refresh one of its regions "
"(disregard any cached results it finds there) you can use <literal>org."
"hibernate.Query.setCacheMode(CacheMode.REFRESH)</literal>. In conjunction "
"with the region you have defined for the given query, Hibernate will "
"selectively force the results cached in that particular region to be "
"refreshed. This is particularly useful in cases where underlying data may "
"have been updated via a separate process and is a far more efficient "
"alternative to bulk eviction of the region via <literal>org.hibernate."
"SessionFactory.evictQueries()</literal>."
msgstr ""
"Falls die Anfrage ein erneutes Laden des Cache-Bereichs der Anfrage "
"erzwingen soll, so rufen Sie <literal>Query.setCacheMode(CacheMode.REFRESH)</"
"literal> auf. Das ist besonders in Fällen von Nutzen, wenn die zu Grunde "
"liegenden Daten mittels eines separaten Vorgangs (d.h. nicht durch Hibernate "
"modifiziert) aktualisiert wurden. Dadurch ist es der Anwendung möglich, "
"selektiv bestimmte Ergenissätze der Anfrage neu zu laden. Das ist eine "
"effizientere Alternative als die Räumung eines Cache-Bereichs der Anfrage "
"durch <literal>SessionFactory.evictQueries()</literal>."

#. Tag: title
#: performance.xml:1242
#, no-c-format
msgid "Understanding Collection performance"
msgstr "Die Perfomance der Collection verstehen"

#. Tag: para
#: performance.xml:1244
#, no-c-format
msgid ""
"In the previous sections we have covered collections and their applications. "
"In this section we explore some more issues in relation to collections at "
"runtime."
msgstr ""

#. Tag: title
#: performance.xml:1249
#, no-c-format
msgid "Taxonomy"
msgstr "Taxonomie"

#. Tag: para
#: performance.xml:1251
#, no-c-format
msgid "Hibernate defines three basic kinds of collections:"
msgstr "Hibernate unterscheidet drei Grundtypen von Collections:"

#. Tag: para
#: performance.xml:1255
#, no-c-format
msgid "collections of values"
msgstr "Collections von Werten"

#. Tag: para
#: performance.xml:1259
#, fuzzy, no-c-format
msgid "one-to-many associations"
msgstr "\"One-to-Many\"-Assoziationen"

#. Tag: para
#: performance.xml:1263
#, fuzzy, no-c-format
msgid "many-to-many associations"
msgstr "\"Many-to-Many\"-Assoziationen"

#. Tag: para
#: performance.xml:1267
#, no-c-format
msgid ""
"This classification distinguishes the various table and foreign key "
"relationships but does not tell us quite everything we need to know about "
"the relational model. To fully understand the relational structure and "
"performance characteristics, we must also consider the structure of the "
"primary key that is used by Hibernate to update or delete collection rows. "
"This suggests the following classification:"
msgstr ""
"Diese Klassifizierung unterscheidet die verschiedenen Tabellen- und "
"Fremdschlüsselbeziehungen, aber sagt so gut wie nichts über das relationale "
"Modell aus. Um die relationale Struktur und Performance-Eigenschaften "
"vollständig zu verstehen, müssen wir die Struktur des von Hibernate zur "
"Aktualisierung und Löschung von Reihen der Collection verwendeten "
"Primärschlüssels berücksichtigen. Das legt die folgende Klassifizierung nahe:"

#. Tag: para
#: performance.xml:1276
#, no-c-format
msgid "indexed collections"
msgstr "indizierte Collections"

#. Tag: para
#: performance.xml:1280
#, no-c-format
msgid "sets"
msgstr "Sets"

#. Tag: para
#: performance.xml:1284
#, no-c-format
msgid "bags"
msgstr "Bags"

#. Tag: para
#: performance.xml:1288
#, fuzzy, no-c-format
msgid ""
"All indexed collections (maps, lists, and arrays) have a primary key "
"consisting of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</"
"literal> columns. In this case, collection updates are extremely efficient. "
"The primary key can be efficiently indexed and a particular row can be "
"efficiently located when Hibernate tries to update or delete it."
msgstr ""
"Alle indizierten Collections (Maps, Listen, Arrays) besitzen einen "
"Primärschlüssel, der aus den <literal>&lt;key&gt;</literal> und <literal>&lt;"
"index&gt;</literal>-Spalten besteht. In diesem Fall sind Aktualisierungen "
"der Collection sehr effizient - der Primärschlüssel kann effizient indiziert "
"werden und eine bestimmte Reihe kann effizient lokalisiert werden, wenn "
"Hibernate diese zu aktualisieren oder löschen versucht."

#. Tag: para
#: performance.xml:1295
#, fuzzy, no-c-format
msgid ""
"Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and "
"element columns. This can be less efficient for some types of collection "
"element, particularly composite elements or large text or binary fields, as "
"the database may not be able to index a complex primary key as efficiently. "
"However, for one-to-many or many-to-many associations, particularly in the "
"case of synthetic identifiers, it is likely to be just as efficient. If you "
"want <literal>SchemaExport</literal> to actually create the primary key of a "
"<literal>&lt;set&gt;</literal>, you must declare all columns as <literal>not-"
"null=\"true\"</literal>."
msgstr ""
"Sets besitzen einen Primärschlüssel, der aus <literal>&lt;key&gt;</literal> "
"und Elementspalten besteht. Das kann für einige Typen von Collection-Element "
"weniger effizient sein, insbesondere im Fall von zusammengesetzten Elementen "
"oder großem Text oder Binärfeldern ist es möglich, dass die Datenbank einen "
"komplexen Primärschlüssel nicht so effizient indizieren kann. Andererseits "
"kann für \"One-to-Many\" und \"Many-to-Many\"-Assoziationen - insbesondere "
"bei synthetischem Bezeichner - dieselbe Effizienz existieren."
"(Nebenbemerkung: Falls <literal>SchemaExport</literal> tatsächlich den "
"Primärschlüssel eines <literal>&lt;set&gt;</literal> für Sie erstellen soll, "
"so müssen Sie alle Spalten als <literal>not-null=\"true\"</literal> "
"deklarieren)."

#. Tag: para
#: performance.xml:1306
#, fuzzy, no-c-format
msgid ""
"<literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they "
"are efficient to update. In fact, they are the best case."
msgstr ""
"<literal>&lt;idbag&gt;</literal>-Mappings definieren einen "
"Surrogatschlüssel, so dass sie sich immer sehr effizient aktualisieren "
"lassen. Genau genommen, ist das der beste Fall."

#. Tag: para
#: performance.xml:1309
#, fuzzy, no-c-format
msgid ""
"Bags are the worst case since they permit duplicate element values and, as "
"they have no index column, no primary key can be defined. Hibernate has no "
"way of distinguishing between duplicate rows. Hibernate resolves this "
"problem by completely removing in a single <literal>DELETE</literal> and "
"recreating the collection whenever it changes. This can be inefficient."
msgstr ""
"Mit den Bags verhält es sich am schwierigsten. Da eine Bag doppelte "
"Elementwerte gestattet und keine Indexspalte besitzt, kann kein "
"Primärschlüssel definiert werden. Hibernate hat keine Möglichkeit, doppelte "
"Reihen zu unterscheiden. Hibernate löst dieses Problem, indem es die "
"Collection bei jeder Änderung vollständig entfernt (in einem einzelnen "
"<literal>DELETE</literal>) und erneut herstellt. Das kann jedoch sehr "
"ineffizient sein."

#. Tag: para
#: performance.xml:1316
#, fuzzy, no-c-format
msgid ""
"For a one-to-many association, the \"primary key\" may not be the physical "
"primary key of the database table. Even in this case, the above "
"classification is still useful. It reflects how Hibernate \"locates\" "
"individual rows of the collection."
msgstr ""
"Bitte beachten Sie, dass für eine \"One-to-Many\"-Assoziation der "
"\"Primärschlüssel\" möglicherweise nicht der physische Primärschlüssel der "
"Datenbanktabelle ist - aber selbst in diesem Fall ist die vorherige "
"Klassifizierung noch sinnvoll. (Sie spiegelt nach wie vor wider, wie "
"Hibernate einzelne Reihen der Collection \"lokalisiert\")."

#. Tag: title
#: performance.xml:1323
#, no-c-format
msgid ""
"Lists, maps, idbags and sets are the most efficient collections to update"
msgstr ""
"Listen, Maps, \"idbags\" und Sets sind die am effizientesten zu "
"aktualisierenden Collections"

#. Tag: para
#: performance.xml:1326
#, fuzzy, no-c-format
msgid ""
"From the discussion above, it should be clear that indexed collections and "
"sets allow the most efficient operation in terms of adding, removing and "
"updating elements."
msgstr ""
"Die vorangegangene Erläuterung zeigt deutlich, dass indizierte Collections "
"und (in der Regel) Sets hinsichtlich des Hinzufügens, Entfernens und "
"Aktualisierens von Reihen die effizientesten Vorgänge erlauben."

#. Tag: para
#: performance.xml:1330
#, fuzzy, no-c-format
msgid ""
"There is, arguably, one more advantage that indexed collections have over "
"sets for many-to-many associations or collections of values. Because of the "
"structure of a <literal>Set</literal>, Hibernate does not <literal>UPDATE</"
"literal> a row when an element is \"changed\". Changes to a <literal>Set</"
"literal> always work via <literal>INSERT</literal> and <literal>DELETE</"
"literal> of individual rows. Once again, this consideration does not apply "
"to one-to-many associations."
msgstr ""
"Es gibt wohl einen weiteren Vorteil, den indizierte Collections vor Sets für "
"\"Many-to-Many\"-Assoziationen oder Collections von Werten besitzen. "
"Aufgrund der Struktur eines <literal>Set</literal>, führt Hibernate nie ein "
"<literal>UPDATE</literal> einer Reihe durch, wenn ein Element \"verändert\" "
"ist. Änderungen an einem <literal>Set</literal> laufen immer mittels "
"<literal>INSERT</literal> und <literal>DELETE</literal> (einzelner Reihen) "
"ab. Auch hier gilt diese Überlegung nicht für \"One-to-Many\"-Assoziationen."

#. Tag: para
#: performance.xml:1338
#, fuzzy, no-c-format
msgid ""
"After observing that arrays cannot be lazy, you can conclude that lists, "
"maps and idbags are the most performant (non-inverse) collection types, with "
"sets not far behind. You can expect sets to be the most common kind of "
"collection in Hibernate applications. This is because the \"set\" semantics "
"are most natural in the relational model."
msgstr ""
"Nachdem wir gesehen haben, dass Arrays nicht \"lazy\" sein können würden wir "
"schließen, dass Listen, Maps und \"idbags\" die performantesten (nicht-"
"inversen) Collection-Typen gefolgt von Sets sind. Sets sind erwartungsgemäß "
"die gängigsten Arten von Collections in Hibernate Anwendungen. Der Grund "
"hierfür liegt in der Tatsache, dass die \"Set\"-Semantik im relationalen "
"Modell die natürlichste ist."

#. Tag: para
#: performance.xml:1344
#, fuzzy, no-c-format
msgid ""
"However, in well-designed Hibernate domain models, most collections are in "
"fact one-to-many associations with <literal>inverse=\"true\"</literal>. For "
"these associations, the update is handled by the many-to-one end of the "
"association, and so considerations of collection update performance simply "
"do not apply."
msgstr ""
"In guten Hibernate Domain-Modellen sehen wir jedoch, dass es sich bei den "
"meisten Collections um \"One-to-Many\"-Assoziationen mit <literal>inverse="
"\"true\"</literal> handelt. Für diese Assoziationen wird die Aktualisierung "
"vom \"Many-to-One\"-Ende der Assoziation bearbeitet, so dass Überlegungen "
"hinsichtlich der Performance der Collection-Aktualisierung nicht gelten."

#. Tag: title
#: performance.xml:1352
#, no-c-format
msgid "Bags and lists are the most efficient inverse collections"
msgstr "Bags und Listen sind die effizientesten invertierten Collections"

#. Tag: para
#: performance.xml:1354
#, fuzzy, no-c-format
msgid ""
"There is a particular case, however, in which bags, and also lists, are much "
"more performant than sets. For a collection with <literal>inverse=\"true\"</"
"literal>, the standard bidirectional one-to-many relationship idiom, for "
"example, we can add elements to a bag or list without needing to initialize "
"(fetch) the bag elements. This is because, unlike a <literal>set</literal>, "
"<literal>Collection.add()</literal> or <literal>Collection.addAll()</"
"literal> must always return true for a bag or <literal>List</literal>. This "
"can make the following common code much faster:"
msgstr ""
"Ehe Sie jetzt \"Bags\" für immer verwerfen sollten wir erwähnen, dass ein "
"spezieller Fall existiert, in dem \"Bags\" (und ebenso Listen) wesentlich "
"performanter als Sets sind. Für eine Collection mit <literal>inverse=\"true"
"\"</literal> (z.B. das standardmäßige bidirektionale Idiom einer \"One-to-"
"Many\"-Beziehung) können wir einer \"Bag\" oder Liste Elemente hinzufügen, "
"ohne die Elemente der \"Bag\" initialisieren (abrufen) zu müssen! Das kommt "
"daher, dass <literal>Collection.add()</literal> oder <literal>Collection."
"addAll()</literal> stets mit \"true\" für eine \"Bag\" oder <literal>List</"
"literal> reagieren müssen (anders als bei einem <literal>Set</literal>). "
"Dadurch kann der folgende Code wesentlich schneller werden."

#. Tag: programlisting
#: performance.xml:1365
#, fuzzy, no-c-format
msgid ""
"Parent p = (Parent) sess.load(Parent.class, id);\n"
"Child c = new Child();\n"
"c.setParent(p);\n"
"p.getChildren().add(c);  //no need to fetch the collection!\n"
"sess.flush();"
msgstr ""
"Parent p = (Parent) sess.load(Parent.class, id);\n"
"Child c = new Child();\n"
"c.setParent(p);\n"
"p.getChildren().add(c);  //no need to fetch the collection!\n"
"sess.flush();"

#. Tag: title
#: performance.xml:1369
#, no-c-format
msgid "One shot delete"
msgstr "\"One-Shot-Löschung\""

#. Tag: para
#: performance.xml:1371
#, fuzzy, no-c-format
msgid ""
"Deleting collection elements one by one can sometimes be extremely "
"inefficient. Hibernate knows not to do that in the case of an newly-empty "
"collection (if you called <literal>list.clear()</literal>, for example). In "
"this case, Hibernate will issue a single <literal>DELETE</literal>."
msgstr ""
"In manchen Fällen kann das einzelne Löschen von Elementen einer Collection "
"sehr ineffizient sein. Hibernate weiß, was im Fall einer neu-geleerten "
"Collection zu tun ist (falls Sie etwa <literal>list.clear()</literal> "
"aufgerufen haben). Hibernate gibt dann ein einzelnes <literal>DELETE</"
"literal> heraus, und wir sind fertig!"

#. Tag: para
#: performance.xml:1377
#, fuzzy, no-c-format
msgid ""
"Suppose you added a single element to a collection of size twenty and then "
"remove two elements. Hibernate will issue one <literal>INSERT</literal> "
"statement and two <literal>DELETE</literal> statements, unless the "
"collection is a bag. This is certainly desirable."
msgstr ""
"Nehmen wir an, wir fügen ein einzelnes Element einer Collection von 20 hinzu "
"und wollten dann zwei Elemente entfernen. Hibernate gibt in diesem Fall eine "
"<literal>INSERT</literal>-Anweisung und zwei <literal>DELETE</literal>-"
"Anweisungen heraus (außer es handelt sich bei der Collection um eine \"Bag"
"\"). Das ist auf jeden Fall wünschenswert."

#. Tag: para
#: performance.xml:1383
#, no-c-format
msgid ""
"However, suppose that we remove eighteen elements, leaving two and then add "
"thee new elements. There are two possible ways to proceed"
msgstr ""
"Nehmen wir jedoch an wir entfernen 18 Elemente, ließen also zwei übrig und "
"fügten dann drei weitere hinzu. In diesem Fall gibt es zwei mögliche "
"Vorgehensweisen:"

#. Tag: para
#: performance.xml:1389
#, no-c-format
msgid "delete eighteen rows one by one and then insert three rows"
msgstr ""
"die 18 Reihen eine nach der anderen löschen und anschließend drei Reihen "
"einfügen"

#. Tag: para
#: performance.xml:1394
#, fuzzy, no-c-format
msgid ""
"remove the whole collection in one SQL <literal>DELETE</literal> and insert "
"all five current elements one by one"
msgstr ""
"die gesamte Collection entfernen (in einem SQL <literal>DELETE</literal>) "
"und die fünf aktuellen Elemente (einzeln) einfügen"

#. Tag: para
#: performance.xml:1400
#, fuzzy, no-c-format
msgid ""
"Hibernate cannot know that the second option is probably quicker. It would "
"probably be undesirable for Hibernate to be that intuitive as such behavior "
"might confuse database triggers, etc."
msgstr ""
"Hibernate weiß nicht, dass die zweite Option in diesem Fall die "
"wahrscheinlich schnellere ist. (Und es ist auch zweifelhaft, ob es gut wäre "
"wenn Hibernate dies wüsste, da ein solches Verhalten Datenbank-Trigger "
"verwirren könnte usw.)"

#. Tag: para
#: performance.xml:1404
#, fuzzy, no-c-format
msgid ""
"Fortunately, you can force this behavior (i.e. the second strategy) at any "
"time by discarding (i.e. dereferencing) the original collection and "
"returning a newly instantiated collection with all the current elements."
msgstr ""
"Glücklicherweise können Sie dieses Verhalten jederzeit durchsetzen (d.h. die "
"zweite Option), indem Sie etwa die ursprüngliche Collection verwerfen und "
"dann eine neu instantiierte Collection mit allen aktuellen Elementen "
"wiedergeben. Das kann sich von Zeit zu Zeit als sehr hilfreich und "
"leistungsfähig erweisen."

#. Tag: para
#: performance.xml:1409
#, fuzzy, no-c-format
msgid ""
"One-shot-delete does not apply to collections mapped <literal>inverse=\"true"
"\"</literal>."
msgstr ""
"Natürlich gilt das \"One-Shot-Delete\" nicht für als <literal>inverse=\"true"
"\"</literal> gemappte Collections."

#. Tag: title
#: performance.xml:1415
#, no-c-format
msgid "Monitoring performance"
msgstr "Leistungsüberwachung"

#. Tag: para
#: performance.xml:1417
#, no-c-format
msgid ""
"Optimization is not much use without monitoring and access to performance "
"numbers. Hibernate provides a full range of figures about its internal "
"operations. Statistics in Hibernate are available per "
"<literal>SessionFactory</literal>."
msgstr ""
"Optimierungen machen ohne Überwachung und Zugriff auf Performanzzahlen wenig "
"Sinn. Hibernate liefert eine ganze Bandbreite von Zahlen zu seinen internen "
"Vorgängen. Statistiken sind in Hibernate über die <literal>SessionFactory</"
"literal> verfügbar."

#. Tag: title
#: performance.xml:1423
#, no-c-format
msgid "Monitoring a SessionFactory"
msgstr "Die Überwachung einer SessionFactory"

#. Tag: para
#: performance.xml:1425
#, no-c-format
msgid ""
"You can access <literal>SessionFactory</literal> metrics in two ways. Your "
"first option is to call <literal>sessionFactory.getStatistics()</literal> "
"and read or display the <literal>Statistics</literal> yourself."
msgstr ""
"Sie können auf zwei Arten auf <literal>SessionFactory</literal>-Metriken "
"zugreifen. Die erste Möglichkeit ist es, <literal>sessionFactory."
"getStatistics()</literal> aufzurufen und die <literal>Statistics</literal> "
"selbst zu lesen und anzuzeigen."

#. Tag: para
#: performance.xml:1430
#, fuzzy, no-c-format
msgid ""
"Hibernate can also use JMX to publish metrics if you enable the "
"<literal>StatisticsService</literal> MBean. You can enable a single MBean "
"for all your <literal>SessionFactory</literal> or one per factory. See the "
"following code for minimalistic configuration examples:"
msgstr ""
"Hibernate kann außerdem JMX verwenden, um Metriken zu publizieren wenn Sie "
"das <literal>StatisticsService</literal>-MBean aktivieren. Sie können ein "
"einzelnes MBean für alle Ihre <literal>SessionFactory</literal>s oder aber "
"eines pro Factory aktivieren. Sehen Sie sich den folgenden Code für "
"minimalistische Konfigurationsbeispiele an:"

#. Tag: programlisting
#: performance.xml:1435
#, fuzzy, no-c-format
msgid ""
"// MBean service registration for a specific SessionFactory\n"
"Hashtable tb = new Hashtable();\n"
"tb.put(\"type\", \"statistics\");\n"
"tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
"ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
"\n"
"StatisticsService stats = new StatisticsService(); // MBean implementation\n"
"stats.setSessionFactory(sessionFactory); // Bind the stats to a "
"SessionFactory\n"
"server.registerMBean(stats, on); // Register the Mbean on the server"
msgstr ""
"// MBean service registration for a specific SessionFactory\n"
"Hashtable tb = new Hashtable();\n"
"tb.put(\"type\", \"statistics\");\n"
"tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
"ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
"\n"
"StatisticsService stats = new StatisticsService(); // MBean implementation\n"
"stats.setSessionFactory(sessionFactory); // Bind the stats to a "
"SessionFactory\n"
"server.registerMBean(stats, on); // Register the Mbean on the server"

#. Tag: programlisting
#: performance.xml:1437
#, fuzzy, no-c-format
msgid ""
"// MBean service registration for all SessionFactory's\n"
"Hashtable tb = new Hashtable();\n"
"tb.put(\"type\", \"statistics\");\n"
"tb.put(\"sessionFactory\", \"all\");\n"
"ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
"\n"
"StatisticsService stats = new StatisticsService(); // MBean implementation\n"
"server.registerMBean(stats, on); // Register the MBean on the server"
msgstr ""
"// MBean service registration for all SessionFactory's\n"
"Hashtable tb = new Hashtable();\n"
"tb.put(\"type\", \"statistics\");\n"
"tb.put(\"sessionFactory\", \"all\");\n"
"ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
"\n"
"StatisticsService stats = new StatisticsService(); // MBean implementation\n"
"server.registerMBean(stats, on); // Register the MBean on the server"

#. Tag: para
#: performance.xml:1439
#, fuzzy, no-c-format
msgid ""
"You can activate and deactivate the monitoring for a "
"<literal>SessionFactory</literal>:"
msgstr ""
"Sie können die Überwachung für eine <literal>SessionFactory</literal> (de)"
"aktivieren"

#. Tag: para
#: performance.xml:1444
#, no-c-format
msgid ""
"at configuration time, set <literal>hibernate.generate_statistics</literal> "
"to <literal>false</literal>"
msgstr ""
"zum Konfigurationszeitpunkt setzen Sie <literal>hibernate."
"generate_statistics</literal> auf <literal>false</literal>"

#. Tag: para
#: performance.xml:1452
#, no-c-format
msgid ""
"at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> "
"or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"
msgstr ""
"zur Runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</"
"literal> oder <literal>hibernateStatsBean.setStatisticsEnabled(true)</"
"literal>"

#. Tag: para
#: performance.xml:1458
#, fuzzy, no-c-format
msgid ""
"Statistics can be reset programmatically using the <literal>clear()</"
"literal> method. A summary can be sent to a logger (info level) using the "
"<literal>logSummary()</literal> method."
msgstr ""
"Statistiken können programmatisch mit der <literal>clear()</literal>-Methode "
"zurückgesetzt werden. Eine Zusammenfassung kann unter Verwendung der "
"<literal>logSummary()</literal>-Methode auch an einen Logger (Info-Level) "
"geschickt werden."

#. Tag: title
#: performance.xml:1464
#, no-c-format
msgid "Metrics"
msgstr "Metriken"

#. Tag: para
#: performance.xml:1466
#, fuzzy, no-c-format
msgid ""
"Hibernate provides a number of metrics, from basic information to more "
"specialized information that is only relevant in certain scenarios. All "
"available counters are described in the <literal>Statistics</literal> "
"interface API, in three categories:"
msgstr ""
"Hibernate liefert eine Reihe von Metriken, die von ganz basalen bis sehr "
"speziellen und ganz bestimmte Szenarios betreffenden reichen. Alle "
"verfügbaren Zähler sind im <literal>Statistics</literal>-Interface API, in "
"drei Kategorien beschrieben:"

#. Tag: para
#: performance.xml:1473
#, no-c-format
msgid ""
"Metrics related to the general <literal>Session</literal> usage, such as "
"number of open sessions, retrieved JDBC connections, etc."
msgstr ""
"Mit dem allgemeinen <literal>Session</literal>-Gebrauch zusammenhängende "
"Metriken wie etwa die Anzahl geöffneter Sessions, abgerufener JDBC-"
"Verbindungen usw."

#. Tag: para
#: performance.xml:1479
#, fuzzy, no-c-format
msgid ""
"Metrics related to the entities, collections, queries, and caches as a whole "
"(aka global metrics)."
msgstr ""
"Mit Entities, Collections, Anfragen und Caches insgesamt zusammenhängende "
"Metriken (auch als allgemeingültige Metriken bekannt, sog. \"global metrics"
"\")"

#. Tag: para
#: performance.xml:1484
#, no-c-format
msgid ""
"Detailed metrics related to a particular entity, collection, query or cache "
"region."
msgstr ""
"Detaillierte Metriken, die sich auf eine bestimmte Entity, Collection, "
"Anfrage oder Cache-Region beziehen."

#. Tag: para
#: performance.xml:1489
#, fuzzy, no-c-format
msgid ""
"For example, you can check the cache hit, miss, and put ratio of entities, "
"collections and queries, and the average time a query needs. Be aware that "
"the number of milliseconds is subject to approximation in Java. Hibernate is "
"tied to the JVM precision and on some platforms this might only be accurate "
"to 10 seconds."
msgstr ""
"Sie können zum Beispiel Cache-Treffer und Nicht-Treffer, das Verhältnis von "
"Entities, Collections und Anfragen und die durchschnittliche Dauer bis zur "
"Rückmeldung prüfen. Bitte berücksichtigen Sie, dass es sich bei der Anzahl "
"von Millisekunden in Java um eine Näherungswert handelt. Hibernate ist an "
"die Genauigkeit der JVM gebunden und auf manchen Plattformen kann das nur "
"auf 10 Sekunden genau sein."

#. Tag: para
#: performance.xml:1495
#, fuzzy, no-c-format
msgid ""
"Simple getters are used to access the global metrics (i.e. not tied to a "
"particular entity, collection, cache region, etc.). You can access the "
"metrics of a particular entity, collection or cache region through its name, "
"and through its HQL or SQL representation for queries. Please refer to the "
"<literal>Statistics</literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, and <literal>QueryStatistics</"
"literal> API Javadoc for more information. The following code is a simple "
"example:"
msgstr ""
"Einfache \"Getters\" werden für den Zugriff auf allgemeine Metriken (d.h. "
"nicht an eine bestimmte Entity, Collection, Cache-Bereich usw.) verwendet. "
"Sie können auf die Metriken einer bestimmten Entity, Collection oder Cache-"
"Bereichs über dessen Namen und über dessen HQL- oder SQL-Repräsentation für "
"Anfragen zugreifen. Weitere Informationen finden Sie im <literal>Statistics</"
"literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal> und <literal>QueryStatistics</"
"literal> API-Javadoc. Der folgende Code zeigt ein einfaches Beispiel:"

#. Tag: programlisting
#: performance.xml:1506
#, fuzzy, no-c-format
msgid ""
"Statistics stats = HibernateUtil.sessionFactory.getStatistics();\n"
"\n"
"double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
"double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
"double queryCacheHitRatio =\n"
"  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
"\n"
"log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
"\n"
"EntityStatistics entityStats =\n"
"  stats.getEntityStatistics( Cat.class.getName() );\n"
"long changes =\n"
"        entityStats.getInsertCount()\n"
"        + entityStats.getUpdateCount()\n"
"        + entityStats.getDeleteCount();\n"
"log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );"
msgstr ""
"Statistics stats = HibernateUtil.sessionFactory.getStatistics();\n"
"\n"
"double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
"double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
"double queryCacheHitRatio =\n"
"  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
"\n"
"log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
"\n"
"EntityStatistics entityStats =\n"
"  stats.getEntityStatistics( Cat.class.getName() );\n"
"long changes =\n"
"        entityStats.getInsertCount()\n"
"        + entityStats.getUpdateCount()\n"
"        + entityStats.getDeleteCount();\n"
"log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );"

#. Tag: para
#: performance.xml:1508
#, fuzzy, no-c-format
msgid ""
"You can work on all entities, collections, queries and region caches, by "
"retrieving the list of names of entities, collections, queries and region "
"caches using the following methods: <literal>getQueries()</literal>, "
"<literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</"
"literal>, and <literal>getSecondLevelCacheRegionNames()</literal>."
msgstr ""
"Um an sämtlichen Entities, Collections, Anfragen und Cache-Bereichen zu "
"arbeiten, können Sie die Namensliste der Entities, Collections, Anfragen und "
"Cache-Bereiche abrufen, indem Sie die folgenden Methoden verwenden: "
"<literal>getQueries()</literal>, <literal>getEntityNames()</literal>, "
"<literal>getCollectionRoleNames()</literal> und "
"<literal>getSecondLevelCacheRegionNames()</literal>."

#~ msgid ""
#~ "The <literal>&lt;cache&gt;</literal> element of a class or collection "
#~ "mapping has the following form:"
#~ msgstr ""
#~ "Das <literal>&lt;cache&gt;</literal>-Element des Mappings einer Klasse "
#~ "oder Collection besitzt folgende Form:"

#~ msgid ""
#~ "The <literal>usage</literal> attribute specifies a <emphasis>cache "
#~ "concurrency strategy</emphasis>."
#~ msgstr ""
#~ "Das <literal>usage</literal>-Attribut bestimmt eine <emphasis>Cache-"
#~ "Nebenläufigkeitsstrategie</emphasis>."

#~ msgid "read-only"
#~ msgstr "read-only"

#~ msgid "read-write"
#~ msgstr "read-write"

#~ msgid "transactional"
#~ msgstr "transactional"

#, fuzzy
#~ msgid ""
#~ "This setting creates two new cache regions: one holding cached query "
#~ "result sets (<literal>org.hibernate.cache.StandardQueryCache</literal>), "
#~ "the other holding timestamps of the most recent updates to queryable "
#~ "tables (<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). "
#~ "Note that the query cache does not cache the state of the actual entities "
#~ "in the result set; it caches only identifier values and results of value "
#~ "type. The query cache should always be used in conjunction with the "
#~ "second-level cache."
#~ msgstr ""
#~ "Durch diese Einstellung werden zwei neue Cache-Bereiche erstellt - einer, "
#~ "der die gecachten Ergebnissätze der Anfrage enthält (<literal>org."
#~ "hibernate.cache.StandardQueryCache</literal>), und ein zweiter, der die "
#~ "Zeitstempel der letzten Aktualisierungen der anfragbaren Tabellen enthält "
#~ "(<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). Bitte "
#~ "beachten Sie, dass das Anfragen-Cache nicht den Status der tatsächlichen "
#~ "Entities im Ergebnissatz cacht, sondern lediglich Bezeichnerwerte und "
#~ "Ergebnisse vom Wertetyp. Das Anfragen-Cache sollte daher stets in "
#~ "Verbindung mit dem Cache der zweiten Ebene verwendet werden."

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"eg.Immutable\" mutable=\"false\">\n"
#~ "    <cache usage=\"read-only\"/>\n"
#~ "    ....\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"eg.Immutable\" mutable=\"false\"&gt;\n"
#~ "    &lt;cache usage=\"read-only\"/&gt;\n"
#~ "    ....\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"eg.Cat\" .... >\n"
#~ "    <cache usage=\"read-write\"/>\n"
#~ "    ....\n"
#~ "    <set name=\"kittens\" ... >\n"
#~ "        <cache usage=\"read-write\"/>\n"
#~ "        ....\n"
#~ "    </set>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"eg.Cat\" .... &gt;\n"
#~ "    &lt;cache usage=\"read-write\"/&gt;\n"
#~ "    ....\n"
#~ "    &lt;set name=\"kittens\" ... &gt;\n"
#~ "        &lt;cache usage=\"read-write\"/&gt;\n"
#~ "        ....\n"
#~ "    &lt;/set&gt;\n"
#~ "&lt;/class&gt;"
