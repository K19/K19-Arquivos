<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 1. Tutorial</title><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="pr01.html" title="Preface"/><link rel="next" href="ch02.html" title="Chapter 2. Architecture"/><link rel="copyright" href="ln-d5e19.html" title="Legal Notice"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="pr01.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch02.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 1. Tutorial"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial"/>Chapter 1. Tutorial</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="ch01.html#tutorial-firstapp">1.1. Part 1 - The first Hibernate Application</a></span></dt><dd><dl><dt><span class="section"><a href="ch01.html#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-firstapp-firstclass">1.1.2. The first class</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-firstapp-mapping">1.1.3. The mapping file</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-firstapp-configuration">1.1.4. Hibernate configuration</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-firstapp-helpers">1.1.6. Startup and helpers</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-firstapp-workingpersistence">1.1.7. Loading and storing objects</a></span></dt></dl></dd><dt><span class="section"><a href="ch01.html#tutorial-associations">1.2. Part 2 - Mapping associations</a></span></dt><dd><dl><dt><span class="section"><a href="ch01.html#tutorial-associations-mappinguser">1.2.1. Mapping the Person class</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-associations-unidirset">1.2.2. A unidirectional Set-based association</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-associations-working">1.2.3. Working the association</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-associations-valuecollections">1.2.4. Collection of values</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-associations-bidirectional">1.2.5. Bi-directional associations</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-associations-usingbidir">1.2.6. Working bi-directional links</a></span></dt></dl></dd><dt><span class="section"><a href="ch01.html#tutorial-webapp">1.3. Part 3 - The EventManager web application</a></span></dt><dd><dl><dt><span class="section"><a href="ch01.html#tutorial-webapp-servlet">1.3.1. Writing the basic servlet</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-webapp-processing">1.3.2. Processing and rendering</a></span></dt><dt><span class="section"><a href="ch01.html#tutorial-webapp-deploy">1.3.3. Deploying and testing</a></span></dt></dl></dd><dt><span class="section"><a href="ch01.html#tutorial-summary">1.4. Summary</a></span></dt></dl></div>
    

    <p>
        Intended for new users, this chapter provides an step-by-step introduction
        to Hibernate, starting with a simple application using an in-memory database.  The
        tutorial is based on an earlier tutorial developed by Michael Gloegl.  All
        code is contained in the <code class="filename">tutorials/web</code> directory of the project
        source.
    </p>

    <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
        <p>
            This tutorial expects the user have knowledge of both Java and
            SQL.  If you have a limited knowledge of JAVA or SQL, it is advised
            that you start with a good introduction to that technology prior
            to attempting to learn Hibernate.
        </p>
    </div>

    <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            The distribution contains another example application under
            the <code class="filename">tutorial/eg</code> project source
            directory.
        </p>
    </div>

    <div class="section" title="1.1. Part 1 - The first Hibernate Application"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-firstapp"/>1.1. Part 1 - The first Hibernate Application</h2></div></div></div>
        

        <p>
            For this example, we will set up a small database application that can store
            events we want to attend and information about the host(s) of these events.
        </p>

        <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                Although you can use whatever database you feel comfortable using, we
                will use <a class="ulink" href="http://hsqldb.org/">HSQLDB</a>
                (an in-memory, Java database) to avoid describing installation/setup of any particular
                database servers.
            </p>
        </div>

        <div class="section" title="1.1.1. Setup"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-setup"/>1.1.1. Setup</h3></div></div></div>
            

            <p>
                The first thing we need to do is to set up the development environment.  We
                will be using the "standard layout" advocated by alot of build tools such
                as <a class="ulink" href="http://maven.apache.org">Maven</a>.
                Maven, in particular, has a
                good resource describing this
                <a class="ulink" href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">layout</a>.
                As this tutorial is to be a web application, we will be creating and making
                use of <code class="filename">src/main/java</code>, <code class="filename">src/main/resources</code>
                and <code class="filename">src/main/webapp</code> directories.
            </p>

            <p>
                We will be using Maven in this tutorial, taking advantage of its
                transitive dependency management capabilities as well as the ability of
                many IDEs to automatically set up a project for us based on the maven descriptor.
            </p>

        <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.hibernate.tutorials&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-tutorial&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;First Hibernate Tutorial&lt;/name&gt;

    &lt;build&gt;
         &lt;!-- we dont want the version to be part of the generated war file name --&gt;
         &lt;finalName&gt;${artifactId}&lt;/finalName&gt;
    &lt;/build&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Because this is a web app, we also have a dependency on the servlet api. --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate uses slf4j for logging, for our purposes here use the simple backend --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</pre>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2>
                <p>
                    It is not a requirement to use Maven.  If you wish to use something else to
                    build this tutorial (such as Ant), the layout will remain the same.  The only
                    change is that you will need to manually account for all the needed
                    dependencies.  If you use something like
                    <a class="ulink" href="http://ant.apache.org/ivy/">Ivy</a>
                    providing transitive dependency management you would still use the dependencies
                    mentioned below.  Otherwise, you'd need to grab <span class="emphasis"><em>all</em></span>
                    dependencies, both explicit and transitive, and add them to the project's
                    classpath.  If working from the Hibernate distribution bundle, this would mean
                    <code class="filename">hibernate3.jar</code>, all artifacts in the
                    <code class="filename">lib/required</code> directory and all files from either the
                    <code class="filename">lib/bytecode/cglib</code> or <code class="filename">lib/bytecode/javassist</code>
                    directory; additionally you will need both the servlet-api jar and one of the slf4j
                    logging backends.
                </p>
            </div>

            <p>
                Save this file as <code class="filename">pom.xml</code> in the project root directory.
            </p>
        </div>


        <div class="section" title="1.1.2. The first class"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-firstclass"/>1.1.2. The first class</h3></div></div></div>
            
            
            <p>
                Next, we create a class that represents the event we want to store in the
                database; it is a simple JavaBean class with some properties:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.hibernate.tutorial.domain;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre>

            <p>
                This class uses standard JavaBean naming conventions for property
                getter and setter methods, as well as private visibility for the
                fields.  Although this is the recommended design, it is not required.
                Hibernate can also access fields directly,  the benefit of accessor
                methods is robustness for refactoring.
            </p>

            <p>
                The <code class="literal">id</code> property holds a unique identifier value
                for a particular event.  All persistent entity classes (there are
                less important dependent classes as well) will need such an identifier
                property if we want to use the full feature set of Hibernate. In fact,
                most applications, especially web applications, need to distinguish
                objects by identifier, so you should consider this a feature rather
                than a limitation.  However, we usually do not manipulate the identity
                of an object, hence the setter method should be private.  Only Hibernate
                will assign identifiers when an object is saved.  Hibernate can access
                public, private, and protected accessor methods, as well as public,
                private and protected fields directly.  The choice is up to you and
                you can match it to fit your application design.
            </p>

            <p>
                The no-argument constructor is a requirement for all persistent
                classes; Hibernate has to create objects for you, using Java
                Reflection.  The constructor can be private, however package or public
                visibility is required for runtime proxy generation and efficient data
                retrieval without bytecode instrumentation.
            </p>

            <p>
                Save this file to the <code class="filename">src/main/java/org/hibernate/tutorial/domain</code>
                directory.
            </p>
        </div>

        <div class="section" title="1.1.3. The mapping file"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mapping"/>1.1.3. The mapping file</h3></div></div></div>
            

            <p>
                Hibernate needs to know how to load and store objects of the
                persistent class.  This is where the Hibernate mapping file
                comes into play. The mapping file tells Hibernate what table in
                the database it has to access, and what columns in that table
                it should use.
            </p>

            <p>
                The basic structure of a mapping file looks like this:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;
[...]
&lt;/hibernate-mapping&gt;</pre>

            <p>
                Hibernate DTD is sophisticated.  You can use it for auto-completion
                of XML mapping elements and attributes in your editor or IDE.
                Opening up the DTD file in your text editor is the easiest way to
                get an overview of all elements and attributes, and to view the
                defaults, as well as some comments.  Hibernate will not load the
                DTD file from the web, but first look it up from the classpath of
                the application.  The DTD file is included in
                <code class="filename">hibernate-core.jar</code> (it is also included in the
                <code class="filename">hibernate3.jar</code>, if using the distribution bundle).
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
                <p>
                    We will omit the DTD declaration in future examples to shorten the code. It is,
                    of course, not optional.
                </p>
            </div>

            <p>
                Between the two <code class="literal">hibernate-mapping</code> tags, include a
                <code class="literal">class</code> element. All persistent entity classes (again, there
                might be dependent classes later on, which are not first-class entities) need
                a mapping to a table in the SQL database:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre>

            <p>
                So far we have told Hibernate how to persist and load object of
                class <code class="literal">Event</code> to the table
                <code class="literal">EVENTS</code>. Each instance is now represented by a
                row in that table.  Now we can continue by mapping the unique
                identifier property to the tables primary key.  As we do not want
                to care about handling this identifier, we configure Hibernate's
                identifier generation strategy for a surrogate primary key column:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre>

            <p>
                The <code class="literal">id</code> element is the declaration of the
                identifier property.  The <code class="literal">name="id"</code> mapping
                attribute declares the name of the JavaBean property and tells
                Hibernate to use the <code class="literal">getId()</code> and
                <code class="literal">setId()</code> methods to access the property.  The
                column attribute tells Hibernate which column of the
                <code class="literal">EVENTS</code> table holds the primary key value.
            </p>

            <p>
                The nested <code class="literal">generator</code> element specifies the
                identifier generation strategy (aka how are identifier values
                generated?).  In this case we choose <code class="literal">native</code>,
                which offers a level of portability depending on the configured
                database dialect.  Hibernate supports database generated, globally
                unique, as well as application assigned, identifiers.  Identifier
                value generation is also one of Hibernate's many extension points
                and you can plugin in your own strategy.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2>
                <p>
                    <code class="literal">native</code> is no longer consider the best strategy in terms of portability.  for further
                    discussion, see <a class="xref" href="ch27.html#portability-idgen" title="27.4. Identifier generation">Section 27.4, “Identifier generation”</a>
                </p>
            </div>

            <p>
                Lastly, we need to tell Hibernate about the remaining entity class
                properties.  By default, no properties of the class are considered
                persistent:
            </p>
            
            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre>
            
            <p>
                Similar to the <code class="literal">id</code> element, the
                <code class="literal">name</code> attribute of the
                <code class="literal">property</code> element tells Hibernate which getter
                and setter methods to use.  In this case, Hibernate will search
                for <code class="literal">getDate()</code>, <code class="literal">setDate()</code>,
                <code class="literal">getTitle()</code> and <code class="literal">setTitle()</code>
                methods.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    Why does the <code class="literal">date</code> property mapping include the
                    <code class="literal">column</code> attribute, but the <code class="literal">title</code>
                    does not? Without the <code class="literal">column</code> attribute, Hibernate
                    by default uses the property name as the column name. This works for
                    <code class="literal">title</code>, however, <code class="literal">date</code> is a reserved
                    keyword in most databases so you will need to map it to a different name.
                </p>
            </div>

            <p>
                The <code class="literal">title</code> mapping also lacks a <code class="literal">type</code> attribute. The
                types declared and used in the mapping files are not Java data types; they are not SQL
                database types either.  These types are called <span class="emphasis"><em>Hibernate mapping types</em></span>,
                converters which can translate from Java to SQL data types and vice versa.  Again,
                Hibernate will try to determine the correct conversion and mapping type itself if
                the <code class="literal">type</code> attribute is not present in the mapping. In some cases this
                automatic detection using Reflection on the Java class might not have the default you
                expect or need. This is the case with the <code class="literal">date</code> property. Hibernate cannot
                know if the property, which is of <code class="literal">java.util.Date</code>, should map to a
                SQL <code class="literal">date</code>, <code class="literal">timestamp</code>, or <code class="literal">time</code> column.
                Full date and time information is preserved by mapping the property with a
                <code class="literal">timestamp</code> converter.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2>
                <p>
                    Hibernate makes this mapping type determination using reflection when the mapping files
                    are processed.  This can take time and resources, so if startup performance is important
                    you should consider explicitly defining the type to use.
                </p>
            </div>

            <p>
                Save this mapping file as
                <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</code>.
            </p>

        </div>

        <div class="section" title="1.1.4. Hibernate configuration"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-configuration"/>1.1.4. Hibernate configuration</h3></div></div></div>
            

            <p>
                At this point, you should have the persistent class and its mapping
                file in place. It is now time to configure Hibernate.  First let's set up
                HSQLDB to run in "server mode"
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    We do this so that the data remains between runs.
                </p>
            </div>

            <p>
                We will utilize the Maven exec plugin to launch the HSQLDB server
                by running:
                <span class="command"><strong> mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial"</strong></span>
                You will see it start up and bind to a TCP/IP socket; this is where
                our application will connect later.  If you want to start
                with a fresh database during this tutorial, shutdown HSQLDB, delete
                all files in the <code class="filename">target/data</code> directory,
                and start HSQLDB again.
            </p>

            <p>
                Hibernate will be connecting to the database on behalf of your application, so it needs to know
                how to obtain connections.  For this tutorial we will be using a standalone connection
                pool (as opposed to a <code class="interfacename">javax.sql.DataSource</code>).  Hibernate comes with
                support for two third-party open source JDBC connection pools:
                <a class="ulink" href="https://sourceforge.net/projects/c3p0">c3p0</a>
                and
                <a class="ulink" href="http://proxool.sourceforge.net/">proxool</a>.
                However, we will be using the Hibernate built-in connection pool for this tutorial.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Caution</h2>
                <p>
                    The built-in Hibernate connection pool is in no way intended for production use.  It
                    lacks several features found on any decent connection pool.
                </p>
            </div>

            <p>
                For Hibernate's configuration, we can use a simple <code class="literal">hibernate.properties</code> file, a
                more sophisticated <code class="literal">hibernate.cfg.xml</code> file, or even complete
                programmatic setup. Most users prefer the XML configuration file:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.internal.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;mapping resource="org/hibernate/tutorial/domain/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>Notice that this configuration file specifies a different DTD</p>
            </div>

            <p>
                You configure Hibernate's <code class="literal">SessionFactory</code>. SessionFactory is a global
                factory responsible for a particular database. If you have several databases, for easier
                startup you should use several <code class="literal">&lt;session-factory&gt;</code> configurations in
                several configuration files.
            </p>

            <p>
                The first four <code class="literal">property</code> elements contain the necessary
                configuration for the JDBC connection. The dialect <code class="literal">property</code>
                element specifies the particular SQL variant Hibernate generates.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2>
                <p>
                    In most cases, Hibernate is able to properly determine which dialect to use.  See
                    <a class="xref" href="ch27.html#portability-dialectresolver" title="27.3. Dialect resolution">Section 27.3, “Dialect resolution”</a> for more information.
                </p>
            </div>

            <p>
                Hibernate's automatic session management for persistence contexts is particularly useful
                in this context.  The <code class="literal">hbm2ddl.auto</code> option turns on automatic generation of
                database schemas directly into the database. This can also be turned
                off by removing the configuration option, or redirected to a file with the help of
                the <code class="literal">SchemaExport</code> Ant task. Finally, add the mapping file(s)
                for persistent classes to the configuration.
            </p>

            <p>
                Save this file as <code class="filename">hibernate.cfg.xml</code> into the
                <code class="filename">src/main/resources</code> directory.
            </p>

        </div>

        <div class="section" title="1.1.5. Building with Maven"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mvn"/>1.1.5. Building with Maven</h3></div></div></div>
            

            <p>
                We will now build the tutorial with Maven.  You will need to
                have Maven installed; it is available from the
                <a class="ulink" href="http://maven.apache.org/download.html">Maven download page</a>.
                Maven will read the <code class="filename">/pom.xml</code> file we created
                earlier and know how to perform some basic project tasks.  First,
                lets run the <code class="literal">compile</code> goal to make sure we can compile
                everything so far:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">[hibernateTutorial]$ mvn compile
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building First Hibernate Tutorial
[INFO]    task-segment: [compile]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /home/steve/projects/sandbox/hibernateTutorial/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Tue Jun 09 12:25:25 CDT 2009
[INFO] Final Memory: 5M/547M
[INFO] ------------------------------------------------------------------------</pre>

        </div>

        <div class="section" title="1.1.6. Startup and helpers"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-helpers"/>1.1.6. Startup and helpers</h3></div></div></div>
            

            <p>
                It is time to load and store some <code class="literal">Event</code>
                objects, but first you have to complete the setup with some
                infrastructure code. You have to startup Hibernate by building
                a global <code class="interfacename">org.hibernate.SessionFactory</code>
                object and storing it somewhere for easy access in application code.  A
                <code class="interfacename">org.hibernate.SessionFactory</code> is used to
                obtain <code class="interfacename">org.hibernate.Session</code> instances.
                A <code class="interfacename">org.hibernate.Session</code> represents a
                single-threaded unit of work.  The
                <code class="interfacename">org.hibernate.SessionFactory</code> is a
                thread-safe global object that is instantiated once.
            </p>

            <p>
                We will create a <code class="literal">HibernateUtil</code> helper class that
                takes care of startup and makes accessing the
                <code class="interfacename">org.hibernate.SessionFactory</code> more convenient.
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.hibernate.tutorial.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {

    private static final SessionFactory sessionFactory = buildSessionFactory();

    private static SessionFactory buildSessionFactory() {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            return new Configuration().configure().buildSessionFactory();
        }
        catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}</pre>

            <p>
                Save this code as
                <code class="filename">src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</code>
            </p>

            <p>
                This class not only produces the global
                <code class="interfacename">org.hibernate.SessionFactory</code> reference in
                its static initializer; it also hides the fact that it uses a
                static singleton.  We might just as well have looked up the
                <code class="interfacename">org.hibernate.SessionFactory</code> reference from
                JNDI in an application server or any other location for that matter.
            </p>

            <p>
                If you give the <code class="interfacename">org.hibernate.SessionFactory</code>
                a name in your configuration, Hibernate will try to bind it to
                JNDI under that name after it has been built.  Another, better option is to
                use a JMX deployment and let the JMX-capable container instantiate and bind
                a <code class="literal">HibernateService</code> to JNDI. Such advanced options are
                discussed later.
            </p>

            <p>
                You now need to configure a logging
                system.  Hibernate uses commons logging and provides two choices: Log4j and
                JDK 1.4 logging. Most developers prefer Log4j: copy <code class="literal">log4j.properties</code>
                from the Hibernate distribution in the <code class="literal">etc/</code> directory to
                your <code class="literal">src</code> directory, next to <code class="literal">hibernate.cfg.xml</code>.
                If you prefer to have
                more verbose output than that provided in the example configuration, you can change the settings.  By default, only the Hibernate startup message is shown on stdout.
            </p>

            <p>
                The tutorial infrastructure is complete and you are now ready to do some real work with
                Hibernate.
            </p>

        </div>

        <div class="section" title="1.1.7. Loading and storing objects"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-workingpersistence"/>1.1.7. Loading and storing objects</h3></div></div></div>
            

            <p>
                We are now ready to start doing some real work with Hibernate.
                Let's start by writing an <code class="literal">EventManager</code> class
                with a <code class="literal">main()</code> method:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.hibernate.tutorial;

import org.hibernate.Session;

import java.util.*;

import org.hibernate.tutorial.domain.Event;
import org.hibernate.tutorial.util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);
        session.save(theEvent);

        session.getTransaction().commit();
    }

}</pre>

            <p>
                In <code class="literal">createAndStoreEvent()</code> we created a new
                <code class="literal">Event</code> object and handed it over to Hibernate.
                At that point, Hibernate takes care of the SQL and executes an
                <code class="literal">INSERT</code> on the database.
            </p>

            <p>
                A <code class="interfacename">org.hibernate.Session</code> is designed to
                represent a single unit of work (a single atomic piece of work
                to be performed).  For now we will keep things simple and assume
                a one-to-one granularity between a Hibernate
                <code class="interfacename">org.hibernate.Session</code> and a database
                transaction.  To shield our code from the actual underlying
                transaction system we use the Hibernate
                <code class="interfacename">org.hibernate.Transaction</code> API.
                In this particular case we are using JDBC-based transactional
                semantics, but it could also run with JTA.
            </p>

            <p>
                What does <code class="literal">sessionFactory.getCurrentSession()</code> do?
                First, you can call it as many times and anywhere you like
                once you get hold of your
                <code class="interfacename">org.hibernate.SessionFactory</code>.
                The <code class="literal">getCurrentSession()</code> method always returns
                the "current" unit of work.  Remember that we switched
                the configuration option for this mechanism to "thread" in our
                <code class="filename">src/main/resources/hibernate.cfg.xml</code>?
                Due to that setting, the context of a current unit of work is bound
                to the current Java thread that executes the application.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
                <p>
                    Hibernate offers three methods of current session tracking.
                    The "thread" based method is not intended for production use;
                    it is merely useful for prototyping and tutorials such as this
                    one.  Current session tracking is discussed in more detail
                    later on.
                </p>
            </div>

            <p>
                A <code class="interfacename">org.hibernate.Session</code> begins when the
                first call to <code class="literal">getCurrentSession()</code> is made for
                the current thread.  It is then bound by Hibernate to the current
                thread.  When the transaction ends, either through commit or
                rollback, Hibernate automatically unbinds the
                <code class="interfacename">org.hibernate.Session</code> from the thread
                and closes it for you. If you call
                <code class="literal">getCurrentSession()</code> again, you get a new
                <code class="interfacename">org.hibernate.Session</code> and can start a
                new unit of work.
            </p>

            <p>
                Related to the unit of work scope, should the Hibernate
                <code class="interfacename">org.hibernate.Session</code> be used to execute
                one or several database operations?  The above example uses one
                <code class="interfacename">org.hibernate.Session</code> for one operation.
                However this is pure coincidence; the example is just not complex
                enough to show any other approach. The scope of a Hibernate
                <code class="interfacename">org.hibernate.Session</code> is flexible but you
                should never design your application to use a new Hibernate
                <code class="interfacename">org.hibernate.Session</code> for
                <span class="emphasis"><em>every</em></span> database operation. Even though it is
                used in the following examples, consider
                <span class="emphasis"><em>session-per-operation</em></span> an anti-pattern.
                A real web application is shown later in the tutorial which will
                help illustrate this.
            </p>

            <p>
                See <a class="xref" href="ch13.html" title="Chapter 13. Transactions and Concurrency">Chapter 13, <em>Transactions and Concurrency</em></a> for more information
                about transaction handling and demarcation. The previous
                example also skipped any error handling and rollback.
            </p>

            <p>
                To run this, we will make use of the Maven exec plugin to call our class
                with the necessary classpath setup:
                <span class="command"><strong>mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="store"</strong></span>
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    You may need to perform <span class="command"><strong>mvn compile</strong></span> first.
                </p>
            </div>

            <p>
                You should see Hibernate starting up and, depending on your configuration,
                lots of log output. Towards the end, the following line will be displayed:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</pre>

            <p>
                This is the <code class="literal">INSERT</code> executed by Hibernate.
            </p>

            <p>
                To list stored events an option is added to the main method:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }
        else if (args[0].equals("list")) {
            List events = mgr.listEvents();
            for (int i = 0; i &lt; events.size(); i++) {
                Event theEvent = (Event) events.get(i);
                System.out.println(
                        "Event: " + theEvent.getTitle() + " Time: " + theEvent.getDate()
                );
            }
        }</pre>

            <p>
                A new <code class="literal">listEvents() method is also added</code>:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private List listEvents() {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();
        List result = session.createQuery("from Event").list();
        session.getTransaction().commit();
        return result;
    }</pre>

            <p>
                Here, we are using a Hibernate Query Language (HQL) query to load all existing
                <code class="literal">Event</code> objects from the database. Hibernate will generate the
                appropriate SQL, send it to the database and populate <code class="literal">Event</code> objects
                with the data. You can create more complex queries with HQL. See <a class="xref" href="ch16.html" title="Chapter 16. HQL: The Hibernate Query Language">Chapter 16, <em>HQL: The Hibernate Query Language</em></a>
                for more information.
            </p>

            <p>
                Now we can call our new functionality, again using the Maven exec plugin:
                <span class="command"><strong>mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="list"</strong></span>
            </p>

        </div>

    </div>

    <div class="section" title="1.2. Part 2 - Mapping associations"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-associations"/>1.2. Part 2 - Mapping associations</h2></div></div></div>
        

        <p>
            So far we have mapped a single persistent entity class to a table in
            isolation.  Let's expand on that a bit and add some class associations.
            We will add people to the application and store a list of events in
            which they participate.
        </p>

        <div class="section" title="1.2.1. Mapping the Person class"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-mappinguser"/>1.2.1. Mapping the Person class</h3></div></div></div>
            

            <p>
                The first cut of the <code class="literal">Person</code> class looks like this:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.hibernate.tutorial.domain;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre>

            <p>
                Save this to a file named
                <code class="filename">src/main/java/org/hibernate/tutorial/domain/Person.java</code>
            </p>

            <p>
                Next, create the new mapping file as
                <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</code>
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre>

            <p>
                Finally, add the new mapping to Hibernate's configuration:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;mapping resource="org/hibernate/tutorial/domain/Event.hbm.xml"/&gt;
&lt;mapping resource="org/hibernate/tutorial/domain/Person.hbm.xml"/&gt;</pre>

            <p>
                Create an association between these two entities. Persons
                can participate in events, and events have participants. The design questions
                you have to deal with are: directionality, multiplicity, and collection
                behavior.
            </p>

        </div>

        <div class="section" title="1.2.2. A unidirectional Set-based association"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-unidirset"/>1.2.2. A unidirectional Set-based association</h3></div></div></div>
            

            <p>
                By adding a collection of events to the <code class="literal">Person</code>
                class, you can easily navigate to the events for a particular person,
                without executing an explicit query - by calling
                <code class="literal">Person#getEvents</code>.  Multi-valued associations
                are represented in Hibernate by one of the Java Collection Framework
                contracts; here we choose a <code class="interfacename">java.util.Set</code>
                because the collection will not contain duplicate elements and the ordering
                is not relevant to our examples:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre>

            <p>
                Before mapping this association, let's consider the other side.
                We could just keep this unidirectional or create another
                collection on the <code class="literal">Event</code>, if we wanted to be
                able to navigate it from both directions.  This is not necessary,
                from a functional perspective. You can always execute an explicit
                query to retrieve the participants for a particular event.  This
                is a design choice left to you, but what is clear from this
                discussion is the multiplicity of the association: "many" valued
                on both sides is called a <span class="emphasis"><em>many-to-many</em></span>
                association. Hence, we use Hibernate's many-to-many mapping:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre>

            <p>
                Hibernate supports a broad range of collection mappings, a
                <code class="literal">set</code> being most common.  For a many-to-many
                association, or <span class="emphasis"><em>n:m</em></span> entity relationship, an
                association table is required.  Each row in this table represents
                a link between a person and an event.  The table name is
                declared using the <code class="literal">table</code> attribute of the
                <code class="literal">set</code> element.  The identifier column name in
                the association, for the person side, is defined with the
                <code class="literal">key</code> element, the column name for the event's
                side with the <code class="literal">column</code> attribute of the
                <code class="literal">many-to-many</code>. You also have to tell Hibernate
                the class of the objects in your collection (the class on the
                other side of the collection of references).
            </p>

            <p>
                The database schema for this mapping is therefore:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre>

        </div>

        <div class="section" title="1.2.3. Working the association"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-working"/>1.2.3. Working the association</h3></div></div></div>
            

            <p>
                Now we will bring some people and events together in a new method in <code class="literal">EventManager</code>:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        Event anEvent = (Event) session.load(Event.class, eventId);
        aPerson.getEvents().add(anEvent);

        session.getTransaction().commit();
    }</pre>

            <p>
                After loading a <code class="literal">Person</code> and an
                <code class="literal">Event</code>, simply modify the collection using the
                normal collection methods. There is no explicit call to
                <code class="literal">update()</code> or <code class="literal">save()</code>;
                Hibernate automatically detects that the collection has been modified
                and needs to be updated. This is called
                <span class="emphasis"><em>automatic dirty checking</em></span>. You can also try
                it by modifying the name or the date property of any of your
                objects.  As long as they are in <span class="emphasis"><em>persistent</em></span>
                state, that is, bound to a particular Hibernate
                <code class="interfacename">org.hibernate.Session</code>, Hibernate
                monitors any changes and executes SQL in a write-behind fashion.
                The process of synchronizing the memory state with the database,
                usually only at the end of a unit of work, is called
                <span class="emphasis"><em>flushing</em></span>.  In our code, the unit of work
                ends with a commit, or rollback, of the database transaction.
            </p>

            <p>
                You can load person and event in different units of work.  Or
                you can modify an object outside of a
                <code class="interfacename">org.hibernate.Session</code>, when it
                is not in persistent state (if it was persistent before, this
                state is called <span class="emphasis"><em>detached</em></span>).  You can even
                modify a collection when it is detached:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session
                .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
                .setParameter("pid", personId)
                .uniqueResult(); // Eager fetch the collection so we can use it detached
        Event anEvent = (Event) session.load(Event.class, eventId);

        session.getTransaction().commit();

        // End of first unit of work

        aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

        // Begin second unit of work

        Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
        session2.beginTransaction();
        session2.update(aPerson); // Reattachment of aPerson

        session2.getTransaction().commit();
    }</pre>

            <p>
                The call to <code class="literal">update</code> makes a detached object
                persistent again by binding it to a new unit of work, so any
                modifications you made to it while detached can be saved to
                the database. This includes any modifications
                (additions/deletions) you made to a collection of that entity
                object.
            </p>

            <p>
                This is not much use in our example, but it is an important concept you can
                incorporate into your own application. Complete this exercise by adding a new action
                to the  main method of the <code class="literal">EventManager</code> and call it from the command line. If
                you need the identifiers of a person and an event - the <code class="literal">save()</code> method
                returns it (you might have to modify some of the previous methods to return that identifier):
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">        else if (args[0].equals("addpersontoevent")) {
            Long eventId = mgr.createAndStoreEvent("My Event", new Date());
            Long personId = mgr.createAndStorePerson("Foo", "Bar");
            mgr.addPersonToEvent(personId, eventId);
            System.out.println("Added person " + personId + " to event " + eventId);
        }</pre>

            <p>
                This is an example of an association between two equally important
                classes : two entities.  As mentioned earlier, there are other
                classes and types in a typical model, usually "less important".
                Some you have already seen, like an <code class="literal">int</code> or a
                <code class="classname">java.lang.String</code>.  We call these classes
                <span class="emphasis"><em>value types</em></span>, and their instances
                <span class="emphasis"><em>depend</em></span> on a particular entity.  Instances of
                these types do not have their own identity, nor are they shared
                between entities.  Two persons do not reference the same
                <code class="literal">firstname</code> object, even if they have the same
                first name.  Value types cannot only be found in the JDK , but
                you can also write dependent classes yourself
                such as an <code class="literal">Address</code> or
                <code class="literal">MonetaryAmount</code> class.  In fact, in a Hibernate
                application all JDK classes are considered value types.
            </p>

            <p>
                You can also design a collection of value types.  This is
                conceptually different from a collection of references to other
                entities, but looks almost the same in Java.
            </p>

        </div>

        <div class="section" title="1.2.4. Collection of values"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-valuecollections"/>1.2.4. Collection of values</h3></div></div></div>
            

            <p>
                Let's add a collection of email addresses to the
                <code class="literal">Person</code> entity.  This will be represented as a
                <code class="interfacename">java.util.Set</code> of
                <code class="classname">java.lang.String</code> instances:
            </p>
            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private Set emailAddresses = new HashSet();

    public Set getEmailAddresses() {
        return emailAddresses;
    }

    public void setEmailAddresses(Set emailAddresses) {
        this.emailAddresses = emailAddresses;
    }</pre>

            <p>
                The mapping of this <code class="literal">Set</code> is as follows:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">        &lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
            &lt;key column="PERSON_ID"/&gt;
            &lt;element type="string" column="EMAIL_ADDR"/&gt;
        &lt;/set&gt;</pre>

            <p>
                The difference compared with the earlier mapping is the use of
                the <code class="literal">element</code> part which tells Hibernate that the
                collection does not contain references to another entity, but is
                rather a collection whose elements are values types, here specifically
                of type <code class="literal">string</code>.  The lowercase name tells you
                it is a Hibernate mapping type/converter.  Again the
                <code class="literal">table</code> attribute of the <code class="literal">set</code>
                element determines the table name for the collection.   The
                <code class="literal">key</code> element defines the foreign-key column
                name in the collection table. The <code class="literal">column</code>
                attribute in the <code class="literal">element</code> element defines the
                column name where the email address values will actually
                be stored.
            </p>

            <p>
                Here is the updated schema:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre>

            <p>
                You can see that the primary key of the collection table is in fact a composite key that
                uses both columns. This also implies that there cannot be duplicate email addresses
                per person, which is exactly the semantics we need for a set in Java.
            </p>

            <p>
                You can now try to add elements to this collection, just like we did before by
                linking persons and events. It is the same code in Java:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private void addEmailToPerson(Long personId, String emailAddress) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        // adding to the emailAddress collection might trigger a lazy load of the collection
        aPerson.getEmailAddresses().add(emailAddress);

        session.getTransaction().commit();
    }</pre>

            <p>
                This time we did not use a <span class="emphasis"><em>fetch</em></span> query to
                initialize the collection.  Monitor the SQL log and try to
                optimize this with an eager fetch.
            </p>

        </div>

        <div class="section" title="1.2.5. Bi-directional associations"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-bidirectional"/>1.2.5. Bi-directional associations</h3></div></div></div>
            

            <p>
                Next you will map a bi-directional association.  You will make
                the association between person and event work from both sides
                in Java.  The database schema does not change, so you will still
                have many-to-many multiplicity.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    A relational database is more flexible than a network
                    programming language, in that it does not need a navigation
                    direction; data can be viewed and retrieved in any possible
                    way.
                </p>
            </div>

            <p>
                First, add a collection of participants to the
                <code class="literal">Event</code> class:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private Set participants = new HashSet();

    public Set getParticipants() {
        return participants;
    }

    public void setParticipants(Set participants) {
        this.participants = participants;
    }</pre>

            <p>
                Now map this side of the association in <code class="literal">Event.hbm.xml</code>.
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">        &lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
            &lt;key column="EVENT_ID"/&gt;
            &lt;many-to-many column="PERSON_ID" class="Person"/&gt;
        &lt;/set&gt;</pre>

            <p>
                These are normal <code class="literal">set</code> mappings in both mapping documents.
                Notice that the column names in <code class="literal">key</code> and <code class="literal">many-to-many</code> 
                swap in both mapping documents. The most important addition here is the
                <code class="literal">inverse="true"</code> attribute in the <code class="literal">set</code> element of the
                <code class="literal">Event</code>'s collection mapping.
            </p>

            <p>
                What this means is that Hibernate should take the other side, the <code class="literal">Person</code> class,
                when it needs to find out information about the link between the two. This will be a lot easier to
                understand once you see how the bi-directional link between our two entities is created.
            </p>

        </div>

        <div class="section" title="1.2.6. Working bi-directional links"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-usingbidir"/>1.2.6. Working bi-directional links</h3></div></div></div>
            

            <p>
                First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a
                link between a <code class="literal">Person</code> and an <code class="literal">Event</code> in the unidirectional
                example? You add an instance of <code class="literal">Event</code> to the collection of event references,
                of an instance of <code class="literal">Person</code>.  If you want to make this link
                bi-directional, you have to do the same on the other side by adding a <code class="literal">Person</code>
                reference to the collection in an <code class="literal">Event</code>. This process of "setting the link on both sides"
                is absolutely necessary with bi-directional links.
            </p>

            <p>
                Many developers program defensively and create link management methods to
                correctly set both sides (for example, in <code class="literal">Person</code>):
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    protected Set getEvents() {
        return events;
    }

    protected void setEvents(Set events) {
        this.events = events;
    }

    public void addToEvent(Event event) {
        this.getEvents().add(event);
        event.getParticipants().add(this);
    }

    public void removeFromEvent(Event event) {
        this.getEvents().remove(event);
        event.getParticipants().remove(this);
    }</pre>

            <p>
                The get and set methods for the collection are now protected. This allows classes in the
                same package and subclasses to still access the methods, but prevents everybody else from altering
                the collections directly. Repeat the steps for the collection
                on the other side.
            </p>

            <p>
                What about the <code class="literal">inverse</code> mapping attribute? For you, and for Java, a bi-directional
                link is simply a matter of setting the references on both sides correctly. Hibernate, however, does not
                have enough information to correctly arrange SQL <code class="literal">INSERT</code> and <code class="literal">UPDATE</code>
                statements (to avoid constraint violations). Making one side of the association <code class="literal">inverse</code> tells Hibernate to consider it a <span class="emphasis"><em>mirror</em></span> of the other side. That is all that is necessary
                for Hibernate to resolve any issues that arise when transforming a directional navigation model to
                a SQL database schema. The rules are straightforward: all bi-directional associations
                need one side as <code class="literal">inverse</code>. In a one-to-many association it has to be the many-side,
                and in many-to-many association you can select either side.
            </p>

        </div>

    </div>

    <div class="section" title="1.3. Part 3 - The EventManager web application"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-webapp"/>1.3. Part 3 - The EventManager web application</h2></div></div></div>
        

        <p>
            A Hibernate web application uses <code class="literal">Session</code> and <code class="literal">Transaction</code>
            almost like a standalone application. However, some common patterns are useful. You can now write
            an <code class="literal">EventManagerServlet</code>. This servlet can list all events stored in the
            database, and it provides an HTML form to enter new events.
        </p>

        <div class="section" title="1.3.1. Writing the basic servlet"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-servlet"/>1.3.1. Writing the basic servlet</h3></div></div></div>
            

            <p>
                First we need create our basic processing servlet.  Since our
                servlet only handles HTTP <code class="literal">GET</code> requests, we
                will only implement the <code class="literal">doGet()</code> method:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">package org.hibernate.tutorial.web;

// Imports

public class EventManagerServlet extends HttpServlet {

    protected void doGet(
            HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException {

        SimpleDateFormat dateFormatter = new SimpleDateFormat( "dd.MM.yyyy" );

        try {
            // Begin unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().beginTransaction();

            // Process request and render page...

            // End unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().commit();
        }
        catch (Exception ex) {
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().rollback();
            if ( ServletException.class.isInstance( ex ) ) {
                throw ( ServletException ) ex;
            }
            else {
                throw new ServletException( ex );
            }
        }
    }

}</pre>

            <p>
                Save this servlet as
                <code class="filename">src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</code>
            </p>

            <p>
                The pattern applied here is called <span class="emphasis"><em>session-per-request</em></span>.
                When a request hits the servlet, a new Hibernate <code class="literal">Session</code> is
                opened through the first call to <code class="literal">getCurrentSession()</code> on the
                <code class="literal">SessionFactory</code>. A database transaction is then started. All
                data access occurs inside a transaction irrespective of whether the data is read or written.
                Do not use the auto-commit mode in applications.
            </p>

            <p>
                Do <span class="emphasis"><em>not</em></span> use a new Hibernate <code class="literal">Session</code> for
                every database operation. Use one Hibernate <code class="literal">Session</code> that is
                scoped to the whole request. Use <code class="literal">getCurrentSession()</code>, so that
                it is automatically bound to the current Java thread.
            </p>

            <p>
                Next, the possible actions of the request are processed and the response HTML
                is rendered. We will get to that part soon.
            </p>

            <p>
                Finally, the unit of work ends when processing and rendering are complete. If any
                problems occurred during processing or rendering, an exception will be thrown
                and the database transaction rolled back. This completes the
                <code class="literal">session-per-request</code> pattern. Instead of the transaction
                demarcation code in every servlet, you could also write a servlet filter.
                See the Hibernate website and Wiki for more information about this pattern
                called <span class="emphasis"><em>Open Session in View</em></span>. You will need it as soon
                as you consider rendering your view in JSP, not in a servlet.
            </p>

        </div>

        <div class="section" title="1.3.2. Processing and rendering"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-processing"/>1.3.2. Processing and rendering</h3></div></div></div>
            

            <p>
                Now you can implement the processing of the request and the rendering of the page.
            </p>

<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">        // Write HTML header
        PrintWriter out = response.getWriter();
        out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

        // Handle actions
        if ( "store".equals(request.getParameter("action")) ) {

            String eventTitle = request.getParameter("eventTitle");
            String eventDate = request.getParameter("eventDate");

            if ( "".equals(eventTitle) || "".equals(eventDate) ) {
                out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
            }
            else {
                createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
                out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
            }
        }

        // Print page
       printEventForm(out);
       listEvents(out, dateFormatter);

       // Write HTML footer
       out.println("&lt;/body&gt;&lt;/html&gt;");
       out.flush();
       out.close();</pre>

            <p>
                This coding style, with a mix of Java and HTML, would not scale
                in a more complex application;keep in mind that we are only illustrating
                basic Hibernate concepts in this tutorial. The code prints an HTML
                header and a footer. Inside this page, an HTML form for event entry and
                a list of all events in the database are printed. The first method is
                trivial and only outputs HTML:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private void printEventForm(PrintWriter out) {
        out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
        out.println("&lt;form&gt;");
        out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
        out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
        out.println("&lt;input type='submit' name='action' value='store'/&gt;");
        out.println("&lt;/form&gt;");
    }</pre>

            <p>
                The <code class="literal">listEvents()</code> method uses the Hibernate
                <code class="literal">Session</code> bound to the current thread to execute
                a query:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

        List result = HibernateUtil.getSessionFactory()
                .getCurrentSession().createCriteria(Event.class).list();
        if (result.size() &gt; 0) {
            out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
            out.println("&lt;table border='1'&gt;");
            out.println("&lt;tr&gt;");
            out.println("&lt;th&gt;Event title&lt;/th&gt;");
            out.println("&lt;th&gt;Event date&lt;/th&gt;");
            out.println("&lt;/tr&gt;");
            Iterator it = result.iterator();
            while (it.hasNext()) {
                Event event = (Event) it.next();
                out.println("&lt;tr&gt;");
                out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
                out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
                out.println("&lt;/tr&gt;");
            }
            out.println("&lt;/table&gt;");
        }
    }</pre>

            <p>
                Finally, the <code class="literal">store</code> action is dispatched to the
                <code class="literal">createAndStoreEvent()</code> method, which also uses
                the <code class="literal">Session</code> of the current thread:
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">    protected void createAndStoreEvent(String title, Date theDate) {
        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        HibernateUtil.getSessionFactory()
                .getCurrentSession().save(theEvent);
    }</pre>

            <p>
                The servlet is now complete. A request to the servlet will be processed
                in a single <code class="literal">Session</code> and <code class="literal">Transaction</code>. As
                earlier in the standalone application, Hibernate can automatically bind these
                objects to the current thread of execution. This gives you the freedom to layer
                your code and access the <code class="literal">SessionFactory</code> in any way you like.
                Usually you would use a more sophisticated design and move the data access code
                into data access objects (the DAO pattern). See the Hibernate Wiki for more
                examples.
            </p>

        </div>

        <div class="section" title="1.3.3. Deploying and testing"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-deploy"/>1.3.3. Deploying and testing</h3></div></div></div>
            

            <p>
                To deploy this application for testing we must create a
                Web ARchive (WAR).  First we must define the WAR descriptor
                as <code class="filename">src/main/webapp/WEB-INF/web.xml</code>
            </p>

            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.hibernate.tutorial.web.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>

            <p>
                To build and deploy call <code class="literal">mvn package</code> in your
                project directory and copy the <code class="filename">hibernate-tutorial.war</code>
                file into your Tomcat <code class="filename">webapps</code> directory.
            </p>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    If you do not have Tomcat installed, download it from
                    <a class="ulink" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a>
                    and follow the
                    installation instructions.  Our application requires
                    no changes to the standard Tomcat configuration.
                </p>
            </div>

            <p>
                Once deployed and Tomcat is running, access the application at
                <code class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</code>. Make
                sure you watch the Tomcat log to see Hibernate initialize when the first
                request hits your servlet (the static initializer in <code class="literal">HibernateUtil</code>
                is called) and to get the detailed output if any exceptions occurs.
            </p>

        </div>

    </div>

    <div class="section" title="1.4. Summary"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-summary"/>1.4. Summary</h2></div></div></div>
        

        <p>
            This tutorial covered the basics of writing a simple standalone Hibernate application
            and a small web application.  More tutorials are available from the Hibernate
            <a class="ulink" href="http://hibernate.org">website</a>.
        </p>

    </div>

</div><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="pr01.html"><strong>Prev</strong>Preface</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch02.html"><strong>Next</strong>Chapter 2. Architecture</a></li></ul></body></html>