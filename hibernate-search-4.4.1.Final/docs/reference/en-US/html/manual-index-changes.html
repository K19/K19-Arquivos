<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 6. Manual index changes</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Hibernate Search"/><link rel="up" href="index.html" title="Hibernate Search"/><link rel="prev" href="search-query.html" title="Chapter 5. Querying"/><link rel="next" href="search-optimize.html" title="Chapter 7. Index Optimization"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="search-query.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="search-optimize.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="manual-index-changes"/>Chapter 6. Manual index changes</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="manual-index-changes.html#d0e7020">6.1. Adding instances to the index</a></span></dt><dt><span class="section"><a href="manual-index-changes.html#d0e7061">6.2. Deleting instances from the index</a></span></dt><dt><span class="section"><a href="manual-index-changes.html#search-batchindex">6.3. Rebuilding the whole index</a></span></dt><dd><dl><dt><span class="section"><a href="manual-index-changes.html#search-batchindex-flushtoindexes">6.3.1. Using flushToIndexes()</a></span></dt><dt><span class="section"><a href="manual-index-changes.html#search-batchindex-massindexer">6.3.2. Using a MassIndexer</a></span></dt><dt><span class="section"><a href="manual-index-changes.html#d0e7343">6.3.3. Useful parameters for batch indexing</a></span></dt></dl></dd></dl></div><p>As Hibernate core applies changes to the Database, Hibernate Search
  detects these changes and will update the index automatically (unless the
  EventListeners are disabled). Sometimes changes are made to the database
  without using Hibernate, as when backup is restored or your data is
  otherwise affected; for these cases Hibernate Search exposes the Manual
  Index APIs to explicitly update or remove a single entity from the index, or
  rebuild the index for the whole database, or remove all references to a
  specific type.</p><p>All these methods affect the Lucene Index only, no changes are applied
  to the Database.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7020"/>6.1. Adding instances to the index</h2></div></div></div><p>Using <code class="classname">FullTextSession</code>.<code class="methodname">index(T
    entity)</code> you can directly add or update a specific object
    instance to the index. If this entity was already indexed, then the index
    will be updated. Changes to the index are only applied at transaction
    commit.</p><div class="example"><a id="d0e7031"/><p class="title"><b>Example 6.1. Indexing an entity via <code class="methodname">FullTextSession.index(T
      entity)</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">FullTextSession</span><!-- <br/> --><span class="java_plain">&nbsp;fullTextSession&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Search</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getFullTextSession</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">session</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Object</span><span class="java_plain">&nbsp;customer&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">8</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
fullTextSession.index(customer);</span>
<!--  --><br/><span class="java_plain">tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">index&nbsp;only&nbsp;updated&nbsp;at&nbsp;commit&nbsp;time</span></pre></div></div><br class="example-break"/><p>In case you want to add all instances for a type, or for all indexed
    types, the recommended approach is to use a
    <code class="classname">MassIndexer</code>: see <a href="manual-index-changes.html#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a> for more details.</p><p>The method <code class="methodname">FullTextSession.index(T
    entity)</code> is considered an explicit indexing operation, so any
    registered <code class="classname">EntityIndexingInterceptor</code> won't be applied
    in this case. For more information on <code class="classname">EntityIndexingInterceptor</code>
    see <a href="search-mapping.html#search-mapping-indexinginterceptor" title="4.5. Conditional indexing: to index or not based on entity state">Section 4.5, “Conditional indexing: to index or not based on entity state”</a>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7061"/>6.2. Deleting instances from the index</h2></div></div></div><p>It is equally possible to remove an entity or all entities of a
    given type from a Lucene index without the need to physically remove them
    from the database. This operation is named purging and is also done
    through the <code class="classname">FullTextSession</code>.</p><div class="example"><a id="d0e7069"/><p class="title"><b>Example 6.2. Purging a specific instance of an entity from the index</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">FullTextSession</span><!-- <br/> --><span class="java_plain">&nbsp;fullTextSession&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Search</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getFullTextSession</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">session</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_keyword">for</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Customer</span><span class="java_plain">&nbsp;customer&nbsp;</span><span class="java_operator">:</span><span class="java_plain">&nbsp;customers</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span>fullTextSession.purge( Customer.class, customer.getId() );</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">index&nbsp;is&nbsp;updated&nbsp;at&nbsp;commit&nbsp;time</span></pre></div></div><br class="example-break"/><p>Purging will remove the entity with the given id from the Lucene
    index but will not touch the database.</p><p>If you need to remove all entities of a given type, you can use the
    <code class="methodname">purgeAll</code> method. This operation removes all
    entities of the type passed as a parameter as well as all its
    subtypes.</p><div class="example"><a id="d0e7084"/><p class="title"><b>Example 6.3. Purging all instances of an entity from the index</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">FullTextSession</span><!-- <br/> --><span class="java_plain">&nbsp;fullTextSession&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Search</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getFullTextSession</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">session</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
fullTextSession.purgeAll( Customer.class );</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">optionally&nbsp;optimize&nbsp;the&nbsp;index</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">fullTextSession</span><span class="java_separator">.</span><span class="java_plain">getSearchFactory</span><span class="java_separator">().</span><span class="java_plain">optimize</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">index&nbsp;changes&nbsp;are&nbsp;applied&nbsp;at&nbsp;commit&nbsp;time&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div></div><br class="example-break"/><p>As in the previous example, it is suggested to optimize the index
    after many purge operation to actually free the used space.</p><p>As is the case with method <code class="methodname">FullTextSession.index(T
    entity)</code>, also <code class="methodname">purge</code> and
    <code class="methodname">purgeAll</code> are considered explicit indexinging
    operations: any registered <code class="classname">EntityIndexingInterceptor</code>
    won't be applied. For more information on <code class="classname">EntityIndexingInterceptor</code>
    see <a href="search-mapping.html#search-mapping-indexinginterceptor" title="4.5. Conditional indexing: to index or not based on entity state">Section 4.5, “Conditional indexing: to index or not based on entity state”</a>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Methods <code class="methodname">index</code>,
      <code class="methodname">purge</code> and <code class="methodname">purgeAll</code> are
      available on <code class="classname">FullTextEntityManager</code> as
      well.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>All manual indexing methods (<code class="methodname">index</code>,
      <code class="methodname">purge</code> and <code class="methodname">purgeAll</code>)
      only affect the index, not the database, nevertheless they are
      transactional and as such they won't be applied until the transaction is
      successfully committed, or you make use of
      <code class="methodname">flushToIndexes</code>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-batchindex"/>6.3. Rebuilding the whole index</h2></div></div></div><p>If you change the entity mapping to the index, chances are that the
    whole Index needs to be updated; For example if you decide to index a an
    existing field using a different analyzer you'll need to rebuild the index
    for affected types. Also if the Database is replaced (like restored from a
    backup, imported from a legacy system) you'll want to be able to rebuild
    the index from existing data. Hibernate Search provides two main
    strategies to choose from:</p><div class="itemizedlist"><ul><li><p>Using
        <code class="classname">FullTextSession</code>.<code class="methodname">flushToIndexes()</code>
        periodically, while using
        <code class="classname">FullTextSession</code>.<code class="methodname">index()</code>
        on all entities.</p></li><li><p>Use a <code class="classname">MassIndexer</code>.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="search-batchindex-flushtoindexes"/>6.3.1. Using flushToIndexes()</h3></div></div></div><p>This strategy consists in removing the existing index and then
      adding all entities back to the index using
      <code class="classname">FullTextSession</code>.<code class="methodname">purgeAll()</code>
      and
      <code class="classname">FullTextSession</code>.<code class="methodname">index()</code>,
      however there are some memory and efficiency contraints. For maximum
      efficiency Hibernate Search batches index operations and executes them
      at commit time. If you expect to index a lot of data you need to be
      careful about memory consumption since all documents are kept in a queue
      until the transaction commit. You can potentially face an
      <code class="classname">OutOfMemoryException</code> if you don't empty the queue
      periodically: to do this you can use
      <code class="methodname">fullTextSession.flushToIndexes()</code>. Every time
      <code class="methodname">fullTextSession.flushToIndexes()</code> is called (or
      if the transaction is committed), the batch queue is processed applying
      all index changes. Be aware that, once flushed, the changes cannot be
      rolled back.</p><div class="example"><a id="d0e7196"/><p class="title"><b>Example 6.4. Index rebuilding using index() and flushToIndexes()</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">fullTextSession</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">setFlushMode</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">FlushMode</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">MANUAL</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">fullTextSession</span><span class="java_separator">.</span><span class="java_plain">setCacheMode</span><span class="java_separator">(</span><span class="java_type">CacheMode</span><span class="java_separator">.</span><span class="java_plain">IGNORE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">transaction&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_type">Scrollable</span><span class="java_plain">&nbsp;results&nbsp;will&nbsp;avoid&nbsp;loading&nbsp;too&nbsp;many&nbsp;objects&nbsp;in&nbsp;memory</span>
<!--  --><br/><span class="java_type">ScrollableResults</span><span class="java_plain">&nbsp;results&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">createCriteria</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Email</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setFetchSize</span><span class="java_separator">(</span><span class="java_plain">BATCH_SIZE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">scroll</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">ScrollMode</span><span class="java_separator">.</span><span class="java_plain">FORWARD_ONLY&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;index&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">0</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">while</span><span class="java_separator">(</span><span class="java_plain">&nbsp;results</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;index</span><span class="java_operator">++</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">index</span><span class="java_separator">(</span><span class="java_plain">&nbsp;results</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">0</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">index&nbsp;each&nbsp;element</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">index&nbsp;</span><span class="java_operator">%</span><span class="java_plain">&nbsp;BATCH_SIZE&nbsp;</span><span class="java_operator">==</span><span class="java_plain">&nbsp;</span><span class="java_literal">0</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">flushToIndexes</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">apply&nbsp;changes&nbsp;to&nbsp;indexes</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">clear</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">free&nbsp;memory&nbsp;since&nbsp;the&nbsp;queue&nbsp;is&nbsp;processed</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">transaction</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>Try to use a batch size that guarantees that your application will
      not run out of memory: with a bigger batch size objects are fetched
      faster from database but more memory is needed.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="search-batchindex-massindexer"/>6.3.2. Using a MassIndexer</h3></div></div></div><p>Hibernate Search's <code class="classname">MassIndexer</code> uses several
      parallel threads to rebuild the index; you can optionally select which
      entities need to be reloaded or have it reindex all entities. This
      approach is optimized for best performance but requires to set the
      application in maintenance mode: making queries to the index is not
      recommended when a MassIndexer is busy.</p><div class="example"><a id="d0e7211"/><p class="title"><b>Example 6.5. Index rebuilding using a MassIndexer</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">fullTextSession</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createIndexer</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">startAndWait</span><!-- <br/> --><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>This will rebuild the index, deleting it and then reloading all
      entities from the database. Although it's simple to use, some tweaking
      is recommended to speed up the process: there are several parameters
      configurable.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>During the progress of a MassIndexer the content of the index is
        undefined! If a query is performed while the MassIndexer is working
        most likely some results will be missing.</p></div><div class="example"><a id="d0e7221"/><p class="title"><b>Example 6.6. Using a tuned MassIndexer</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">fullTextSession</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">createIndexer</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">User</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">batchSizeToLoadObjects</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">25</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">cacheMode</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheMode</span><span class="java_separator">.</span><span class="java_plain">NORMAL&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">threadsToLoadObjects</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">5</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">idFetchSize</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">150</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">threadsForSubsequentFetching</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">20</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">progressMonitor</span><span class="java_separator">(</span><span class="java_plain">&nbsp;monitor&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">a&nbsp;</span><span class="java_type">MassIndexerProgressMonitor</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">startAndWait</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>This will rebuild the index of all User instances (and subtypes),
      and will create 5 parallel threads to load the User instances using
      batches of 25 objects per query; these loaded User instances are then
      pipelined to 20 parallel threads to load the attached lazy collections
      of User containing some information needed for the index. The number of
      threads working on actual index writing is defined by the backend
      configuration of each index. See the option
      <code class="literal">worker.thread_pool.size</code> in <a href="search-configuration.html#table-work-execution-configuration" title="Table 3.3. Execution configuration">Table 3.3, “Execution configuration”</a>.</p><p>As of Hibernate Search 4.4.0, instead of indexing all the types
      in parallel, the MassIndexer is configured by default to index only
      one type in parallel. It prevents resource exhaustion especially
      database connections and usually does not slow down the indexing.
      You can however configure this behavior using
      <code class="classname">MassIndexer</code>.<code class="methodname">typesToIndexInParallel(int threadsToIndexObjects)</code>:
      </p><div class="example"><a id="d0e7241"/><p class="title"><b>Example 6.7. Configuring the MassIndexer to index several types in parallel</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">fullTextSession</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">createIndexer</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">User</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">typesToIndexInParallel</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">2</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">batchSizeToLoadObjects</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">25</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">cacheMode</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheMode</span><span class="java_separator">.</span><span class="java_plain">NORMAL&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">threadsToLoadObjects</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">5</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">idFetchSize</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">150</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">threadsForSubsequentFetching</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">20</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">progressMonitor</span><span class="java_separator">(</span><span class="java_plain">&nbsp;monitor&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">a&nbsp;</span><span class="java_type">MassIndexerProgressMonitor</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">startAndWait</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>It is recommended to leave cacheMode to
      <code class="literal">CacheMode.IGNORE</code> (the default), as in most reindexing
      situations the cache will be a useless additional overhead; it might be
      useful to enable some other <code class="literal">CacheMode</code> depending on
      your data: it might increase performance if the main entity is relating
      to enum-like data included in the index.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The MassIndexer was designed for speed and is unaware of
        transactions, so there is no need to begin one or committing. Also
        because it is not transactional it is not recommended to let users use
        the system during it's processing, as it is unlikely people will be
        able to find results and the system load might be too high
        anyway.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="search-batchindexing-threadsandconnections"/>6.3.2.1. MassIndexer using threads and JDBC connections</h4></div></div></div><p>The MassIndexer was designed to finish the reindexing task as
      quickly as possible, but this requires a bit of care in its configuration
      to behave fairly with your server resources.</p><p>There is a simple formula to understand how the different options
      applied to the MassIndexer affect the number of used worker threads
      and connections: each thread will require a JDBC connection.</p><pre class="programlisting">threads = typesToIndexInParallel * (threadsToLoadObjects + threadsForSubsequentFetching + 1);
required JDBC connections = threads;</pre><p>Let's see some suggestions for a roughly sane tuning starting point:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Option <code class="literal">typesToIndexInParallel</code> should probably be a low value, like 1 or 2, depending on how
          much of your CPUs have spare cycles and how slow a database round trip will be.</p></li><li><p>Before tuning a parallel run, experiment with options to tune your primary indexed entities in isolation.</p></li><li><p>Making <code class="literal">threadsToLoadObjects</code> higher increases the preloading rate for the picked root entity
          from the database, but also increases memory usage and the pressure on the threads working on subsequent fetching.</p></li><li><p>Option <code class="literal">threadsForSubsequentFetching</code> should generally be higher than <code class="literal">threadsToLoadObjects</code>
          as it needs to perform more work in parallel: loading all the values for relations marked <code class="classname">@IndexedEmbedded</code>
          or other lazily loaded relations needed by your custom <code class="classname">FieldBridge</code>s.
          You could try a lower value if the root entity doesn't have any such relation.</p></li><li><p>Increasing parallelism usually helps as the bottleneck usually is the latency to the database connection,
          but make sure your database can handle all the multiple requests.</p></li><li><p>This advice might not apply to you: always measure the effects! We're providing this as a means to help you
          understand how these options are related.</p></li></ol></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Running the MassIndexer with many threads will require many
        connections to the database. If you don't have a sufficiently large
        connection pool, the MassIndexer itself could deadlock or your other
        applications (or your same application) could starve being unable to serve
        other requests: make sure you size your connection pool accordingly
        to the options as explained in the above paragraph.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>The "sweet spot" of number of threads to achieve best
        performance is highly dependent on your overall architecture, database
        design and even data values. To find out the best number of threads
        for your application it is recommended to use a profiler: all internal
        thread groups have meaningful names to be easily identified with most
        tools.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="search-batchindex-custommassindexer"/>6.3.2.2. Using a custom MassIndexer implementation</h4></div></div></div><p>The provided MassIndexer is quite general purpose, and while we believe
        it's a robust approach, you might be able to squeeze some better performance
        by writing a custom implementation. To run your own <code class="classname">MassIndexer</code>
        instead of using the one shipped with Hibernate Search you have to:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>create an implementation of the <code class="classname">org.hibernate.search.spi.MassIndexerFactory</code> interface;</p></li><li><p>set the property <code class="code">hibernate.search.massindexer.factoryclass</code> with the qualified class name of the factory implementation.</p></li></ol></div><div class="example"><a id="d0e7333"/><p class="title"><b>Example 6.8. Custom <code class="code">MassIndexerFactory</code> example</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">package</span><!-- <br/> --><span class="java_plain">&nbsp;org</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">myproject</span>
<!--  --><br/><span class="java_keyword">import</span><span class="java_plain">&nbsp;org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">search</span><span class="java_separator">.</span><span class="java_plain">spi</span><span class="java_separator">.</span><span class="java_type">MassIndexerFactory</span>
<!--  --><br/><span class="java_separator">[...]</span>
</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">CustomIndexerFactory</span><span class="java_plain">&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">MassIndexerFactory</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;initialize</span><span class="java_separator">(</span><span class="java_type">Properties</span><span class="java_plain">&nbsp;properties</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">MassIndexer</span><span class="java_plain">&nbsp;createMassIndexer</span><span class="java_separator">(...)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">CustomIndexer</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_separator">}</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><pre class="programlisting">hibernate.search.massindexer.factoryclass = org.myproject.CustomIndexerFactory</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7343"/>6.3.3. Useful parameters for batch indexing</h3></div></div></div><p>Other parameters which affect indexing time and memory consumption
      are:</p><div class="itemizedlist"><ul><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code></p></li><li><p><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code></p></li></ul></div><p>Previous versions also had a <code class="literal">max_field_length</code> but
      this was removed from Lucene, it's possible to obtain a similar effect by
      using a <code class="classname">LimitTokenCountAnalyzer</code>.</p><p>All <code class="literal">.indexwriter</code> parameters are Lucene specific
      and Hibernate Search is just passing these parameters through - see <a href="search-configuration.html#lucene-indexing-performance" title="3.7.1. Tuning indexing performance">Section 3.7.1, “Tuning indexing performance”</a> for more details.</p><p>The <code class="classname">MassIndexer</code> uses a forward only
      scrollable result to iterate on the primary keys to be loaded, but MySQL's
      JDBC driver will load all values in memory; to avoid this "optimisation"
      set <code class="literal">idFetchSize</code> to
      <code class="literal">Integer.MIN_VALUE</code>.</p></div></div></div><HR xmlns=""/><a xmlns="" href=""/><ul class="docnav"><li class="previous"><a accesskey="p" href="search-query.html"><strong>Prev</strong>Chapter 5. Querying</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="search-optimize.html"><strong>Next</strong>Chapter 7. Index Optimization</a></li></ul></body></html>