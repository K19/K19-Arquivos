<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 7. Index Optimization</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Hibernate Search"/><link rel="up" href="index.html" title="Hibernate Search"/><link rel="prev" href="manual-index-changes.html" title="Chapter 6. Manual index changes"/><link rel="next" href="search-monitoring.html" title="Chapter 8. Monitoring"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="manual-index-changes.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="search-monitoring.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-optimize"/>Chapter 7. Index Optimization</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="search-optimize.html#d0e7465">7.1. Automatic optimization</a></span></dt><dt><span class="section"><a href="search-optimize.html#d0e7528">7.2. Manual optimization</a></span></dt><dt><span class="section"><a href="search-optimize.html#d0e7551">7.3. Adjusting optimization</a></span></dt></dl></div><p>This section explains some low level tricks to keep your indexes at
  peak performance. We cover some Lucene details which in most cases you don't
  have to know about: Hibernate Search will handle these operations optimally
  and transparently in most cases without the need for further configuration.
  Still, it is good to know that there are ways to configure the behaviour,
  if the need arises.</p><p>The index is physically stored in several smaller segments. Each
  segment is immutable and represents a generation of index writes. Index
  segments are periodically compacted, both to merge smaller segments and to
  remove stale entries; this merging process happens constantly in the
  background and can be tuned with the options specified in <a href="search-configuration.html#lucene-indexing-performance" title="3.7.1. Tuning indexing performance">Section 3.7.1, “Tuning indexing performance”</a>, but you can also define policies to
  fully run index optimizations when it is most suited for your specific
  workload.</p><p>With older versions of Lucene it was important to frequently optimize
  the index to maintain good performance, but with current Lucene versions
  this doesn't apply anymore. The benefit of explicit optimization is very low,
  and in certain cases even counter-productive. During an explicit optimization the
  whole index is processed and rewritten inflicting a significant performance
  cost. Optimization is for this reason a double-edged sword.</p><p>Another reason to avoid optimizing the index too often is that an
  optimization will, as a side effect, invalidate cached filters and field caches
  and internal buffers need to be refreshed. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Optimizing the index is often not needed, does not benefit write
      (update) performance at all, and is a slow operation: make sure you need
      it before activating it.</p></div><p>Of course optimizing the index does not only present drawbacks: after
  the optimization process is completed and new
  <code class="classname">IndexReader</code> instances have loaded their buffers,
  queries will perform at peak performance and you will have reclaimed all
  disk space potentially used by stale entries.</p><p>It is recommended to not schedule any optimization, but if you wish to
  perform it periodically you should run it:</p><div class="itemizedlist"><ul><li><p>on an idle system or when the searches are less frequent</p></li><li><p>after a lot of index modifications</p></li></ul></div><p>When using a <code class="classname">MassIndexer</code> (see <a href="manual-index-changes.html#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>) it will optimize involved indexes
  by default at the start and at the end of processing; you can change this
  behavior by using
  <code class="classname">MassIndexer</code>.<code class="methodname">optimizeAfterPurge</code>
  and
  <code class="classname">MassIndexer</code>.<code class="methodname">optimizeOnFinish</code>
  respectively. The initial optimization is actually very cheap as it is
  performed on an emtpy index: its purpose is to release the storage space
  occupied by the old index.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7465"/>7.1. Automatic optimization</h2></div></div></div><p>While in most cases this is not needed, Hibernate Search can
    automatically optimize an index after:</p><div class="itemizedlist"><ul><li><p>a certain amount of write operations</p></li><li><p>or after a certain amount of transactions</p></li></ul></div><p>The configuration for automatic index optimization can be defined on
    a global level or per index:</p><div class="example"><a id="d0e7479"/><p class="title"><b>Example 7.1. Defining automatic optimization parameters</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre></div></div><br class="example-break"/><p>With the above example an optimization will be triggered to the
    <code class="literal">Animal</code> index as soon as either:</p><div class="itemizedlist"><ul><li><p>the number of additions and deletions reaches 1000</p></li><li><p>the number of transactions reaches 50
        (<code class="constant">hibernate.search.Animal.optimizer.transaction_limit.max</code>
        having priority over
        <code class="constant">hibernate.search.default.optimizer.transaction_limit.max</code>)</p></li></ul></div><p>If none of these parameters are defined, no optimization is
    processed automatically.</p><p>The default implementation of OptimizerStrategy can be overriden by
    implementing
    <code class="literal">org.hibernate.search.store.optimization.OptimizerStrategy</code>
    and setting the <code class="literal">optimizer.implementation</code> property to
    the fully qualified name of your implementation. This implementation must
    implement the interface, be a public class and have a public constructor
    taking no arguments.</p><div class="example"><a id="d0e7512"/><p class="title"><b>Example 7.2. Loading a custom OptimizerStrategy</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.optimizer.implementation = com.acme.worlddomination.SmartOptimizer
hibernate.search.default.optimizer.SomeOption = CustomConfigurationValue
hibernate.search.humans.optimizer.implementation = default</pre></div></div><br class="example-break"/><p>The keyword <code class="literal">default</code> can be used to select the
    Hibernate Search default implementation; all properties after the
    <code class="literal">.optimizer</code> key separator will be passed to the
    implementation's <code class="methodname">initialize</code> method at
    start.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7528"/>7.2. Manual optimization</h2></div></div></div><p>You can programmatically optimize (defragment) a Lucene index from
    Hibernate Search through the <code class="classname">SearchFactory</code>:</p><div class="example"><a id="d0e7536"/><p class="title"><b>Example 7.3. Programmatic index optimization</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">FullTextSession</span><!-- <br/> --><span class="java_plain">&nbsp;fullTextSession&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Search</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getFullTextSession</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">regularSession</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">SearchFactory</span><span class="java_plain">&nbsp;searchFactory&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;fullTextSession</span><span class="java_separator">.</span><span class="java_plain">getSearchFactory</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">searchFactory</span><span class="java_separator">.</span><span class="java_plain">optimize</span><span class="java_separator">(</span><span class="java_type">Order</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;or</span>
<!--  --><br/><span class="java_plain">searchFactory</span><span class="java_separator">.</span><span class="java_plain">optimize</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>The first example optimizes the Lucene index holding
    <code class="classname">Order</code>s; the second, optimizes all indexes.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">searchFactory.optimize()</code> has no effect on a JMS
      or JGroups backend: you must apply the optimize operation on the Master
      node.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7551"/>7.3. Adjusting optimization</h2></div></div></div><p>The Lucene index is constantly being merged in the background to
    keep a good balance between write and read performance; in a sense this is a
    form of background optimization which is always applied.</p><p>The following match attributes of Lucene's <code class="classname">IndexWriter</code>
    and are commonly used to tune how often merging occurs and how aggressive it is
    applied. They are exposed by Hibernate Search via: </p><div class="itemizedlist"><ul><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code></li></ul></div><p> See <a href="search-configuration.html#lucene-indexing-performance" title="3.7.1. Tuning indexing performance">Section 3.7.1, “Tuning indexing performance”</a> for
    a description of these properties.</p></div></div><HR xmlns=""/><a xmlns="" href=""/><ul class="docnav"><li class="previous"><a accesskey="p" href="manual-index-changes.html"><strong>Prev</strong>Chapter 6. Manual index changes</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="search-monitoring.html"><strong>Next</strong>Chapter 8. Monitoring</a></li></ul></body></html>